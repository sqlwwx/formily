{"version":3,"file":"formily.grid.umd.production.js","sources":["../src/observer.ts","../src/index.ts"],"sourcesContent":["const isHTMLElement = (node: Node): node is HTMLElement => node.nodeType === 1\n\ntype ChildNode = {\n  element?: HTMLElement\n  observer?: MutationObserver\n  dispose?: () => void\n}\n\nexport class ChildListMutationObserver {\n  observer: MutationObserver\n  callback: MutationCallback\n  childList: ChildNode[] = []\n  init: MutationObserverInit\n  constructor(callback: MutationCallback) {\n    this.callback = callback\n    this.observer = new MutationObserver(this.handler)\n  }\n\n  observeChildList(element: HTMLElement) {\n    Array.from(element.children).forEach((node: HTMLElement) => {\n      this.addObserver(node)\n    })\n  }\n\n  addObserver(element: HTMLElement) {\n    const child = this.childList.find((t) => t.element === element)\n    if (!child) {\n      const childIndex = this.childList.length\n      const child = {\n        element,\n        observer: new MutationObserver(this.callback),\n        dispose: () => {\n          if (child.observer) {\n            child.observer.disconnect()\n            delete child.observer\n            this.childList.splice(childIndex, 1)\n          }\n        },\n      }\n      child.observer.observe(child.element, {\n        ...this.init,\n        subtree: false,\n        childList: false,\n        characterData: false,\n        characterDataOldValue: false,\n        attributeOldValue: false,\n      })\n      this.childList.push(child)\n    }\n  }\n\n  removeObserver(element: HTMLElement) {\n    const child = this.childList.find((t) => t.element === element)\n    if (child) {\n      child.dispose?.()\n    }\n  }\n\n  handler = (mutations: MutationRecord[]) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === 'childList') {\n        mutation.addedNodes.forEach((node) => {\n          if (isHTMLElement(node)) {\n            this.addObserver(node)\n          }\n        })\n        mutation.removedNodes.forEach((node) => {\n          if (isHTMLElement(node)) {\n            this.removeObserver(node)\n          }\n        })\n      }\n    })\n    this.callback(mutations, this.observer)\n  }\n\n  observe = (element: HTMLElement, init?: MutationObserverInit) => {\n    this.init = init\n    this.observeChildList(element)\n    this.observer.observe(element, {\n      ...this.init,\n      subtree: false,\n      childList: true,\n      characterData: false,\n      characterDataOldValue: false,\n      attributeOldValue: false,\n    })\n  }\n\n  disconnect = () => {\n    this.observer.disconnect()\n  }\n}\n","import { define, observable, batch, reaction } from '@formily/reactive'\nimport { ChildListMutationObserver } from './observer'\n\nexport interface IGridOptions {\n  maxRows?: number\n  maxColumns?: number | number[]\n  minColumns?: number | number[]\n  maxWidth?: number | number[]\n  minWidth?: number | number[]\n  breakpoints?: number[]\n  columnGap?: number\n  rowGap?: number\n  colWrap?: boolean\n  strictAutoFit?: boolean\n  shouldVisible?: (node: GridNode, grid: Grid<HTMLElement>) => boolean\n  onDigest?: (grid: Grid<HTMLElement>) => void\n  onInitialized?: (grid: Grid<HTMLElement>) => void\n}\n\nconst SpanRegExp = /span\\s*(\\d+)/\n\nconst isValid = (value: any) => value !== undefined && value !== null\n\nconst calcBreakpointIndex = (breakpoints: number[], width: number) => {\n  if (Array.isArray(breakpoints)) {\n    for (let i = 0; i < breakpoints.length; i++) {\n      if (width <= breakpoints[i]) {\n        return i\n      }\n    }\n  }\n  return -1\n}\n\nconst calcFactor = <T>(value: T | T[], breakpointIndex: number): T => {\n  if (Array.isArray(value)) {\n    if (breakpointIndex === -1) return value[0]\n    return value[breakpointIndex] ?? value[value.length - 1]\n  } else {\n    return value\n  }\n}\n\nconst parseGridNode = (elements: HTMLCollection): GridNode[] => {\n  return Array.from(elements).reduce((buf, element: HTMLElement, index) => {\n    const style = getComputedStyle(element)\n    const visible = !(style.display === 'none')\n    const origin = element.getAttribute('data-grid-span')\n    const span = parseSpan(style.gridColumnStart) ?? 1\n    const originSpan = Number(origin ?? span)\n    const node: GridNode = {\n      index,\n      span,\n      visible,\n      originSpan,\n      element,\n    }\n    if (!origin) {\n      element.setAttribute('data-grid-span', String(span))\n    }\n    return buf.concat(node)\n  }, [])\n}\n\nconst calcChildTotalColumns = (nodes: GridNode[], shadow = false) =>\n  nodes.reduce((buf, node) => {\n    if (!shadow) {\n      if (!node.visible) return buf\n    }\n    if (node.originSpan === -1) return buf + (node.span ?? 1)\n    return buf + node.span\n  }, 0)\n\nconst calcChildOriginTotalColumns = (nodes: GridNode[], shadow = false) =>\n  nodes.reduce((buf, node) => {\n    if (!shadow) {\n      if (!node.visible) return buf\n    }\n    if (node.originSpan === -1) return buf + (node.span ?? 1)\n    return buf + node.originSpan\n  }, 0)\n\nconst calcSatisfyColumns = (\n  width: number,\n  maxColumns: number,\n  minColumns: number,\n  maxWidth: number,\n  minWidth: number,\n  gap: number\n) => {\n  const results = []\n  for (let columns = minColumns; columns <= maxColumns; columns++) {\n    const innerWidth = width - (columns - 1) * gap\n    const columnWidth = innerWidth / columns\n    if (columnWidth >= minWidth && columnWidth <= maxWidth) {\n      results.push(columns)\n    } else if (columnWidth < minWidth) {\n      results.push(Math.min(Math.floor(innerWidth / minWidth), maxColumns))\n    } else if (columnWidth > maxWidth) {\n      results.push(Math.min(Math.floor(innerWidth / maxWidth), maxColumns))\n    }\n  }\n  return Math.max(...results)\n}\n\nconst parseSpan = (gridColumnStart: string) => {\n  return Number(String(gridColumnStart).match(SpanRegExp)?.[1] ?? 1)\n}\n\nconst factor = <T>(value: T | T[], grid: Grid<HTMLElement>): T =>\n  isValid(value) ? calcFactor(value as any, grid.breakpoint) : value\n\nconst resolveChildren = (grid: Grid<HTMLElement>) => {\n  let walked = 0,\n    shadowWalked = 0,\n    rowIndex = 0,\n    shadowRowIndex = 0\n  if (!grid.ready) return\n  grid.children = grid.children.map((node) => {\n    const columnIndex = walked % grid.columns\n    const shadowColumnIndex = shadowWalked % grid.columns\n    const remainColumns = grid.columns - columnIndex\n    const originSpan = node.originSpan\n    const targetSpan = originSpan > grid.columns ? grid.columns : originSpan\n    const span = grid.options.strictAutoFit\n      ? targetSpan\n      : targetSpan > remainColumns\n      ? remainColumns\n      : targetSpan\n    const gridColumn =\n      originSpan === -1 ? `span ${remainColumns} / -1` : `span ${span} / auto`\n    if (node.element.style.gridColumn !== gridColumn) {\n      node.element.style.gridColumn = gridColumn\n    }\n    if (node.visible) {\n      walked += span\n    }\n    shadowWalked += span\n    if (columnIndex === 0) {\n      rowIndex++\n    }\n    if (shadowColumnIndex == 0) {\n      shadowRowIndex++\n    }\n    node.shadowRow = shadowRowIndex\n    node.shadowColumn = shadowColumnIndex + 1\n    if (node.visible) {\n      node.row = rowIndex\n      node.column = columnIndex + 1\n    }\n    if (grid.options?.shouldVisible) {\n      if (!grid.options.shouldVisible(node, grid)) {\n        if (node.visible) {\n          node.element.style.display = 'none'\n        }\n        node.visible = false\n      } else {\n        if (!node.visible) {\n          node.element.style.display = ''\n        }\n        node.visible = true\n      }\n    }\n    return node\n  })\n}\n\nconst nextTick = (callback?: () => void) => Promise.resolve(0).then(callback)\n\nexport type GridNode = {\n  index?: number\n  visible?: boolean\n  column?: number\n  shadowColumn?: number\n  row?: number\n  shadowRow?: number\n  span?: number\n  originSpan?: number\n  element?: HTMLElement\n}\nexport class Grid<Container extends HTMLElement> {\n  options: IGridOptions\n  width = 0\n  height = 0\n  container: Container\n  children: GridNode[] = []\n  childTotalColumns = 0\n  shadowChildTotalColumns = 0\n  childOriginTotalColumns = 0\n  shadowChildOriginTotalColumns = 0\n  ready = false\n  constructor(options?: IGridOptions) {\n    this.options = {\n      breakpoints: [720, 1280, 1920],\n      columnGap: 8,\n      rowGap: 4,\n      minWidth: 100,\n      colWrap: true,\n      strictAutoFit: false,\n      ...options,\n    }\n    define(this, {\n      options: observable.shallow,\n      width: observable.ref,\n      height: observable.ref,\n      ready: observable.ref,\n      children: observable.ref,\n      childOriginTotalColumns: observable.ref,\n      shadowChildOriginTotalColumns: observable.ref,\n      shadowChildTotalColumns: observable.ref,\n      childTotalColumns: observable.ref,\n      columns: observable.computed,\n      templateColumns: observable.computed,\n      gap: observable.computed,\n      maxColumns: observable.computed,\n      minColumns: observable.computed,\n      maxWidth: observable.computed,\n      minWidth: observable.computed,\n      breakpoints: observable.computed,\n      breakpoint: observable.computed,\n      rowGap: observable.computed,\n      columnGap: observable.computed,\n      colWrap: observable.computed,\n    })\n  }\n\n  set breakpoints(breakpoints) {\n    this.options.breakpoints = breakpoints\n  }\n\n  get breakpoints() {\n    return this.options.breakpoints\n  }\n\n  get breakpoint() {\n    return calcBreakpointIndex(this.options.breakpoints, this.width)\n  }\n\n  set maxWidth(maxWidth) {\n    this.options.maxWidth = maxWidth\n  }\n\n  get maxWidth() {\n    return factor(this.options.maxWidth, this) ?? Infinity\n  }\n\n  set minWidth(minWidth) {\n    this.options.minWidth = minWidth\n  }\n\n  get minWidth() {\n    return factor(this.options.minWidth, this) ?? 100\n  }\n\n  set maxColumns(maxColumns) {\n    this.options.maxColumns = maxColumns\n  }\n\n  get maxColumns() {\n    return factor(this.options.maxColumns, this) ?? Infinity\n  }\n\n  set maxRows(maxRows) {\n    this.options.maxRows = maxRows\n  }\n\n  get maxRows() {\n    return this.options.maxRows ?? Infinity\n  }\n\n  set minColumns(minColumns) {\n    this.options.minColumns = minColumns\n  }\n\n  get minColumns() {\n    return factor(this.options.minColumns, this) ?? 1\n  }\n\n  set rowGap(rowGap) {\n    this.options.rowGap = rowGap\n  }\n\n  get rowGap() {\n    return factor(this.options.rowGap, this) ?? 5\n  }\n\n  set columnGap(columnGap) {\n    this.options.columnGap = columnGap\n  }\n\n  get columnGap() {\n    return factor(this.options.columnGap, this) ?? 10\n  }\n\n  set colWrap(colWrap) {\n    this.options.colWrap = colWrap\n  }\n\n  get colWrap() {\n    return factor(this.options.colWrap, this) ?? true\n  }\n\n  get columns() {\n    if (!this.ready) return 0\n\n    const originTotalColumns = this.childOriginTotalColumns\n\n    if (this.colWrap === false) {\n      return originTotalColumns\n    }\n\n    const baseColumns = this.childSize\n\n    const maxWidthColumns = Math.min(\n      originTotalColumns,\n      Math.round(this.width / (this.maxWidth + this.columnGap))\n    )\n\n    const minWidthColumns = Math.min(\n      originTotalColumns,\n      Math.round(this.width / (this.minWidth + this.columnGap))\n    )\n\n    const minCalculatedColumns = Math.min(\n      baseColumns,\n      maxWidthColumns,\n      minWidthColumns\n    )\n\n    const maxCalculatedColumns = Math.max(\n      baseColumns,\n      maxWidthColumns,\n      minWidthColumns\n    )\n\n    const finalColumns = calcSatisfyColumns(\n      this.width,\n      maxCalculatedColumns,\n      minCalculatedColumns,\n      this.maxWidth,\n      this.minWidth,\n      this.columnGap\n    )\n    if (finalColumns >= this.maxColumns) {\n      return this.maxColumns\n    }\n    if (finalColumns <= this.minColumns) {\n      return this.minColumns\n    }\n    return finalColumns\n  }\n\n  get rows() {\n    return Math.ceil(this.childTotalColumns / this.columns)\n  }\n\n  get shadowRows() {\n    return Math.ceil(this.shadowChildTotalColumns / this.columns)\n  }\n\n  get templateColumns() {\n    if (!this.width) return ''\n    if (this.maxWidth === Infinity) {\n      return `repeat(${this.columns},1fr)`\n    }\n    if (this.options.strictAutoFit !== true) {\n      const columnWidth =\n        (this.width - (this.columns - 1) * this.columnGap) / this.columns\n      if (columnWidth < this.minWidth || columnWidth > this.maxWidth) {\n        return `repeat(${this.columns},1fr)`\n      }\n    }\n    return `repeat(${this.columns},minmax(${this.minWidth}px,${this.maxWidth}px))`\n  }\n\n  get gap() {\n    return `${this.rowGap}px ${this.columnGap}px`\n  }\n\n  get childSize() {\n    return this.children.length\n  }\n\n  get fullnessLastColumn() {\n    return this.columns === this.children[this.childSize - 1]?.span\n  }\n\n  connect = (container: Container) => {\n    if (container) {\n      this.container = container\n      const initialize = batch.bound(() => {\n        digest()\n        this.ready = true\n      })\n      const digest = batch.bound(() => {\n        this.children = parseGridNode(this.container.children)\n        this.childTotalColumns = calcChildTotalColumns(this.children)\n        this.shadowChildTotalColumns = calcChildTotalColumns(\n          this.children,\n          true\n        )\n        this.childOriginTotalColumns = calcChildOriginTotalColumns(\n          this.children\n        )\n        this.shadowChildOriginTotalColumns = calcChildOriginTotalColumns(\n          this.children,\n          true\n        )\n        const rect = this.container.getBoundingClientRect()\n        if (rect.width && rect.height) {\n          this.width = rect.width\n          this.height = rect.height\n        }\n        resolveChildren(this)\n        nextTick(() => {\n          this.options?.onDigest?.(this)\n        })\n        if (!this.ready) {\n          nextTick(() => {\n            this.options?.onInitialized?.(this)\n          })\n        }\n      })\n      const mutationObserver = new ChildListMutationObserver(digest)\n      const resizeObserver = new ResizeObserver(digest)\n      const dispose = reaction(() => ({ ...this.options }), digest)\n      resizeObserver.observe(this.container)\n      mutationObserver.observe(this.container, {\n        attributeFilter: ['style', 'class', 'data-grid-span'],\n        attributes: true,\n      })\n      initialize()\n      return () => {\n        resizeObserver.unobserve(this.container)\n        resizeObserver.disconnect()\n        mutationObserver.disconnect()\n        dispose()\n        this.children = []\n      }\n    }\n\n    return () => {}\n  }\n\n  static id = (options: IGridOptions = {}) =>\n    JSON.stringify(\n      [\n        'maxRows',\n        'maxColumns',\n        'minColumns',\n        'maxWidth',\n        'minWidth',\n        'breakpoints',\n        'columnGap',\n        'rowGap',\n        'colWrap',\n        'strictAutoFit',\n      ].map((key) => options[key])\n    )\n}\n"],"names":["isHTMLElement","node","nodeType","callback","this","mutations","forEach","mutation","type","addedNodes","_this","addObserver","removedNodes","removeObserver","observer","element","init","observeChildList","observe","subtree","childList","characterData","characterDataOldValue","attributeOldValue","disconnect","MutationObserver","handler","ChildListMutationObserver","Array","from","children","find","t","childIndex_1","length","child_1","dispose","splice","push","child","Formily"],"mappings":";;;;;;;;;;;;;;;oNAAA,IAAMA,EAAgB,SAACC,GAAoC,OAAkB,IAAlBA,EAAKC,uBAa9D,WAAYC,GAAZ,WAFAC,eAAyB,GA+CzBA,aAAU,SAACC,GACTA,EAAUC,SAAQ,SAACC,GACK,cAAlBA,EAASC,OACXD,EAASE,WAAWH,SAAQ,SAACL,GACvBD,EAAcC,IAChBS,EAAKC,YAAYV,MAGrBM,EAASK,aAAaN,SAAQ,SAACL,GACzBD,EAAcC,IAChBS,EAAKG,eAAeZ,UAK5BS,EAAKP,SAASE,EAAWK,EAAKI,WAGhCV,aAAU,SAACW,EAAsBC,GAC/BN,EAAKM,KAAOA,EACZN,EAAKO,iBAAiBF,GACtBL,EAAKI,SAASI,QAAQH,SACjBL,EAAKM,OACRG,SAAS,EACTC,WAAW,EACXC,eAAe,EACfC,uBAAuB,EACvBC,mBAAmB,MAIvBnB,gBAAa,WACXM,EAAKI,SAASU,cA5EdpB,KAAKD,SAAWA,EAChBC,KAAKU,SAAW,IAAIW,iBAAiBrB,KAAKsB,SA6E9C,OA1EEC,6BAAA,SAAiBZ,GAAjB,WACEa,MAAMC,KAAKd,EAAQe,UAAUxB,SAAQ,SAACL,GACpCS,EAAKC,YAAYV,OAIrB0B,wBAAA,SAAYZ,GAAZ,WAEE,IADcX,KAAKgB,UAAUW,MAAK,SAACC,GAAM,OAAAA,EAAEjB,UAAYA,KAC3C,CACV,IAAMkB,EAAa7B,KAAKgB,UAAUc,OAC5BC,EAAQ,CACZpB,UACAD,SAAU,IAAIW,iBAAiBrB,KAAKD,UACpCiC,QAAS,WACHD,EAAMrB,WACRqB,EAAMrB,SAASU,oBACRW,EAAMrB,SACbJ,EAAKU,UAAUiB,OAAOJ,EAAY,MAIxCE,EAAMrB,SAASI,QAAQiB,EAAMpB,eACxBX,KAAKY,OACRG,SAAS,EACTC,WAAW,EACXC,eAAe,EACfC,uBAAuB,EACvBC,mBAAmB,KAErBnB,KAAKgB,UAAUkB,KAAKH,KAIxBR,2BAAA,SAAeZ,SACPwB,EAAQnC,KAAKgB,UAAUW,MAAK,SAACC,GAAM,OAAAA,EAAEjB,UAAYA,KACnDwB,cACFA,EAAMH,6BAANG,6gDCgVmBC,6DAIJA,8jDA+BCA,sZAhOlBA,sCACWA,0CACFA,uCACCA,sCACDA,yCACGA,wDACeA,8DACMA,wDACNA,kDACNA,wCACVA,qDACQA,yCACZA,gDACOA,gDACAA,8CACFA,8CACAA,iDACGA,gDACDA,4CACJA,+CACGA,6CACFA"}
{"version":3,"file":"transformer.js","sourceRoot":"","sources":["../src/transformer.ts"],"names":[],"mappings":"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","sourcesContent":["/* istanbul ignore file */\nimport { untracked, autorun, observable } from '@formily/reactive'\nimport {\n  isArr,\n  isStr,\n  toArr,\n  each,\n  isFn,\n  isPlainObj,\n  reduce,\n} from '@formily/shared'\nimport { Schema } from './schema'\nimport {\n  ISchema,\n  ISchemaTransformerOptions,\n  IFieldStateSetterOptions,\n  SchemaReaction,\n} from './types'\nimport {\n  onFieldInit,\n  onFieldMount,\n  onFieldUnmount,\n  onFieldValueChange,\n  onFieldInputValueChange,\n  onFieldInitialValueChange,\n  onFieldValidateStart,\n  onFieldValidateEnd,\n  onFieldValidateFailed,\n  onFieldValidateSuccess,\n  IFieldFactoryProps,\n  Field,\n} from '@formily/core'\nimport { patchCompile, patchSchemaCompile, shallowCompile } from './compiler'\n\nconst FieldEffects = {\n  onFieldInit,\n  onFieldMount,\n  onFieldUnmount,\n  onFieldValueChange,\n  onFieldInputValueChange,\n  onFieldInitialValueChange,\n  onFieldValidateStart,\n  onFieldValidateEnd,\n  onFieldValidateFailed,\n  onFieldValidateSuccess,\n}\n\nconst DefaultFieldEffects = ['onFieldInit', 'onFieldValueChange']\n\nconst getDependencyValue = (\n  field: Field,\n  pattern: string,\n  property?: string\n) => {\n  const [target, path] = String(pattern).split(/\\s*#\\s*/)\n  return field.query(target).getIn(path || property || 'value')\n}\n\nconst getDependencies = (\n  field: Field,\n  dependencies:\n    | Array<string | { name?: string; source?: string; property?: string }>\n    | object\n) => {\n  if (isArr(dependencies)) {\n    const results = []\n    dependencies.forEach((pattern) => {\n      if (isStr(pattern)) {\n        results.push(getDependencyValue(field, pattern))\n      } else if (isPlainObj(pattern)) {\n        if (pattern.name && pattern.source) {\n          results[pattern.name] = getDependencyValue(\n            field,\n            pattern.source,\n            pattern.property\n          )\n        }\n      }\n    })\n    return results\n  } else if (isPlainObj(dependencies)) {\n    return reduce(\n      dependencies,\n      (buf, pattern, key) => {\n        buf[key] = getDependencyValue(field, pattern)\n        return buf\n      },\n      {}\n    )\n  }\n  return []\n}\n\nconst setSchemaFieldState = (\n  options: IFieldStateSetterOptions,\n  demand = false\n) => {\n  const { request, target, runner, field, scope } = options || {}\n  if (!request) return\n  if (target) {\n    if (request.state) {\n      field.form.setFieldState(target, (state) =>\n        patchCompile(state, request.state, {\n          ...scope,\n          $target: state,\n        })\n      )\n    }\n    if (request.schema) {\n      field.form.setFieldState(target, (state) =>\n        patchSchemaCompile(\n          state,\n          request.schema,\n          {\n            ...scope,\n            $target: state,\n          },\n          demand\n        )\n      )\n    }\n    if (isStr(runner) && runner) {\n      field.form.setFieldState(target, (state) => {\n        shallowCompile(`{{function(){${runner}}}}`, {\n          ...scope,\n          $target: state,\n        })()\n      })\n    }\n  } else {\n    if (request.state) {\n      field.setState((state) => patchCompile(state, request.state, scope))\n    }\n    if (request.schema) {\n      field.setState((state) =>\n        patchSchemaCompile(state, request.schema, scope, demand)\n      )\n    }\n    if (isStr(runner) && runner) {\n      shallowCompile(`{{function(){${runner}}}}`, scope)()\n    }\n  }\n}\n\nconst getBaseScope = (\n  field: Field,\n  options: ISchemaTransformerOptions = {}\n) => {\n  const $observable = (target: any, deps?: any[]) =>\n    autorun.memo(() => observable(target), deps)\n  const $props = (props: any) => field.setComponentProps(props)\n  const $effect = autorun.effect\n  const $memo = autorun.memo\n  const $self = field\n  const $form = field.form\n  const $values = field.form.values\n  return {\n    ...options.scope,\n    $form,\n    $self,\n    $observable,\n    $effect,\n    $memo,\n    $props,\n    $values,\n  }\n}\n\nconst getBaseReactions =\n  (schema: ISchema, options: ISchemaTransformerOptions) => (field: Field) => {\n    setSchemaFieldState(\n      {\n        field,\n        request: { schema },\n        scope: getBaseScope(field, options),\n      },\n      true\n    )\n  }\n\nconst getUserReactions =\n  (schema: ISchema, options: ISchemaTransformerOptions) => (field: Field) => {\n    const reactions: SchemaReaction[] = toArr(schema['x-reactions'])\n    const baseScope = getBaseScope(field, options)\n    reactions.forEach((unCompiled) => {\n      const reaction = shallowCompile(unCompiled, baseScope)\n      if (!reaction) return\n      if (isFn(reaction)) {\n        return reaction(field)\n      }\n      const { when, fulfill, otherwise, target, effects } = reaction\n      const run = () => {\n        const $deps = getDependencies(field, reaction.dependencies)\n        const $dependencies = $deps\n        const scope = {\n          ...baseScope,\n          $target: null,\n          $deps,\n          $dependencies,\n        }\n        const compiledWhen = shallowCompile(when, scope)\n        const condition = when ? compiledWhen : true\n        const request = condition ? fulfill : otherwise\n        const runner = condition ? fulfill?.run : otherwise?.run\n        setSchemaFieldState({\n          field,\n          target,\n          request,\n          runner,\n          scope,\n        })\n      }\n\n      if (target) {\n        reaction.effects = effects?.length ? effects : DefaultFieldEffects\n      }\n      if (reaction.effects) {\n        autorun.memo(() => {\n          untracked(() => {\n            each(reaction.effects, (type) => {\n              if (FieldEffects[type]) {\n                FieldEffects[type](field.address, run)\n              }\n            })\n          })\n        }, [])\n      } else {\n        run()\n      }\n    })\n  }\n\nexport const transformFieldProps = (\n  schema: Schema,\n  options: ISchemaTransformerOptions\n): IFieldFactoryProps<any, any> => {\n  return {\n    name: schema.name,\n    reactions: [\n      getBaseReactions(schema, options),\n      getUserReactions(schema, options),\n    ],\n  }\n}\n"]}
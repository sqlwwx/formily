{"version":3,"file":"formily.path.umd.development.js","sources":["../src/contexts.ts","../src/tokens.ts","../src/tokenizer.ts","../src/types.ts","../src/shared.ts","../src/destructor.ts","../src/parser.ts","../src/matcher.ts","../src/index.ts"],"sourcesContent":["export type Context = {\n  flag: string\n  [key: string]: any\n}\n\nconst ContextType = (flag: string, props?: any): Context => {\n  return {\n    flag,\n    ...props,\n  }\n}\n\nexport const bracketContext = ContextType('[]')\n\nexport const bracketArrayContext = ContextType('[\\\\d]')\n\nexport const bracketDContext = ContextType('[[]]')\n\nexport const parenContext = ContextType('()')\n\nexport const braceContext = ContextType('{}')\n\nexport const destructorContext = ContextType('{x}')\n","import {\n  bracketContext,\n  parenContext,\n  bracketArrayContext,\n  bracketDContext,\n  braceContext,\n  destructorContext,\n} from './contexts'\n\ninterface ITokenProps {\n  expectNext?: (next?: Token) => boolean\n  expectPrev?: (prev?: Token) => boolean\n  updateContext?: (prev?: Token) => void\n}\n\nexport type Token = ITokenProps & {\n  flag: string\n}\n\nconst TokenType = (flag: string, props?: ITokenProps): Token => {\n  return {\n    flag,\n    ...props,\n  }\n}\n\nexport const nameTok = TokenType('name', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return (\n        next === nameTok ||\n        next === commaTok ||\n        next === bracketRTok ||\n        next === braceRTok ||\n        next === colonTok\n      )\n    }\n    return (\n      next === dotTok ||\n      next === commaTok ||\n      next === eofTok ||\n      next === bracketRTok ||\n      next === parenRTok ||\n      next === colonTok ||\n      next === expandTok ||\n      next === bracketLTok\n    )\n  },\n})\nexport const starTok = TokenType('*', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === parenLTok ||\n      next === bracketLTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok\n    )\n  },\n})\nexport const dbStarTok = TokenType('**', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === parenLTok ||\n      next === bracketLTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok\n    )\n  },\n})\nexport const dotTok = TokenType('.', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === nameTok ||\n      next === bracketDLTok ||\n      next === starTok ||\n      next === dbStarTok ||\n      next === bracketLTok ||\n      next === braceLTok ||\n      next === eofTok\n    )\n  },\n  expectPrev(prev) {\n    return (\n      prev === dotTok ||\n      prev === nameTok ||\n      prev === bracketDRTok ||\n      prev === starTok ||\n      prev === parenRTok ||\n      prev === bracketRTok ||\n      prev === expandTok ||\n      prev === braceRTok\n    )\n  },\n})\nexport const bangTok = TokenType('!', {\n  expectNext(next) {\n    return next === nameTok || next === bracketDLTok\n  },\n})\nexport const colonTok = TokenType(':', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return next === nameTok || next === braceLTok || next === bracketLTok\n    }\n    return next === nameTok || next === bracketDLTok || next === bracketRTok\n  },\n})\n\nexport const braceLTok = TokenType('{', {\n  expectNext(next) {\n    return next === nameTok\n  },\n  expectPrev(prev) {\n    if (this.includesContext(destructorContext)) {\n      return prev === colonTok || prev === commaTok || prev === bracketLTok\n    }\n    return prev === dotTok || prev === colonTok || prev === parenLTok\n  },\n  updateContext() {\n    this.state.context.push(braceContext)\n  },\n})\n\nexport const braceRTok = TokenType('}', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return (\n        next === commaTok ||\n        next === braceRTok ||\n        next === eofTok ||\n        next === bracketRTok\n      )\n    }\n    return next === dotTok || next === eofTok || next === commaTok\n  },\n  expectPrev(prev) {\n    return prev === nameTok || prev === braceRTok || prev === bracketRTok\n  },\n  updateContext() {\n    this.state.context.pop(braceContext)\n  },\n})\n\nexport const bracketLTok = TokenType('[', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return (\n        next === nameTok ||\n        next === bracketLTok ||\n        next === braceLTok ||\n        next === bracketRTok\n      )\n    }\n    return (\n      next === nameTok ||\n      next === bracketDLTok ||\n      next === colonTok ||\n      next === bracketLTok ||\n      next === ignoreTok ||\n      next === bracketRTok\n    )\n  },\n  expectPrev(prev) {\n    if (this.includesContext(destructorContext)) {\n      return prev === colonTok || prev === commaTok || prev === bracketLTok\n    }\n    return (\n      prev === starTok ||\n      prev === bracketLTok ||\n      prev === dotTok ||\n      prev === nameTok ||\n      prev === parenLTok ||\n      prev == commaTok\n    )\n  },\n  updateContext() {\n    this.state.context.push(bracketContext)\n  },\n})\n\nexport const bracketRTok = TokenType(']', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return (\n        next === commaTok ||\n        next === braceRTok ||\n        next === bracketRTok ||\n        next === eofTok\n      )\n    }\n    return (\n      next === dotTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok ||\n      next === bracketRTok\n    )\n  },\n  updateContext() {\n    if (this.includesContext(bracketArrayContext)) return\n    if (!this.includesContext(bracketContext)) throw this.unexpect()\n    this.state.context.pop()\n  },\n})\n\nexport const bracketDLTok = TokenType('[[', {\n  updateContext() {\n    this.state.context.push(bracketDContext)\n  },\n})\n\nexport const bracketDRTok = TokenType(']]', {\n  updateContext() {\n    if (this.curContext() !== bracketDContext) throw this.unexpect()\n    this.state.context.pop()\n  },\n})\n\nexport const parenLTok = TokenType('(', {\n  expectNext(next) {\n    return (\n      next === nameTok ||\n      next === bracketDLTok ||\n      next === braceLTok ||\n      next === bangTok ||\n      next === bracketLTok\n    )\n  },\n  expectPrev(prev) {\n    return prev === starTok\n  },\n  updateContext() {\n    this.state.context.push(parenContext)\n  },\n})\nexport const parenRTok = TokenType(')', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok\n    )\n  },\n  updateContext() {\n    if (this.curContext() !== parenContext) throw this.unexpect()\n    this.state.context.pop()\n  },\n})\n\nexport const commaTok = TokenType(',', {\n  expectNext(next) {\n    return (\n      next === nameTok ||\n      next === bracketDLTok ||\n      next === bracketLTok ||\n      next === braceLTok\n    )\n  },\n})\nexport const ignoreTok = TokenType('ignore', {\n  expectNext(next) {\n    return next === bracketDRTok\n  },\n  expectPrev(prev) {\n    return prev == bracketDLTok\n  },\n})\n\nexport const expandTok = TokenType('expandTok', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok\n    )\n  },\n})\n\nexport const eofTok = TokenType('eof')\n","import {\n  Token,\n  nameTok,\n  colonTok,\n  dotTok,\n  starTok,\n  dbStarTok,\n  bangTok,\n  bracketLTok,\n  bracketRTok,\n  bracketDRTok,\n  expandTok,\n  parenLTok,\n  parenRTok,\n  commaTok,\n  eofTok,\n  ignoreTok,\n  braceLTok,\n  braceRTok,\n  bracketDLTok,\n} from './tokens'\nimport { bracketDContext, Context } from './contexts'\n\nconst nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/\n\nconst fullCharCodeAtPos = (input: string, pos: number) => {\n  if (String.fromCharCode) return input.codePointAt(pos)\n  const code = input.charCodeAt(pos)\n  if (code <= 0xd7ff || code >= 0xe000) return code\n\n  const next = input.charCodeAt(pos + 1)\n  return (code << 10) + next - 0x35fdc00\n}\n\nconst isRewordCode = (code: number) =>\n  code === 42 ||\n  code === 46 ||\n  code === 33 ||\n  code === 91 ||\n  code === 93 ||\n  code === 40 ||\n  code === 41 ||\n  code === 44 ||\n  code === 58 ||\n  code === 126 ||\n  code === 123 ||\n  code === 125\n\nconst getError = (message?: string, props?: any) => {\n  const err = new Error(message)\n  Object.assign(err, props)\n  return err\n}\n\nconst slice = (string: string, start: number, end: number) => {\n  let str = ''\n  for (let i = start; i < end; i++) {\n    const ch = string.charAt(i)\n    if (ch !== '\\\\') {\n      str += ch\n    }\n  }\n  return str\n}\n\nexport class Tokenizer {\n  public input: string\n  public state: {\n    context: Context[]\n    type: Token\n    pos: number\n    value?: any\n  }\n  public type_: Token\n  constructor(input: string) {\n    this.input = input\n    this.state = {\n      context: [],\n      type: null,\n      pos: 0,\n    }\n    this.type_ = null\n  }\n\n  curContext() {\n    return this.state.context[this.state.context.length - 1]\n  }\n\n  includesContext(context: Context) {\n    for (let len = this.state.context.length - 1; len >= 0; len--) {\n      if (this.state.context[len] === context) {\n        return true\n      }\n    }\n    return false\n  }\n\n  unexpect(type?: Token) {\n    type = type || this.state.type\n    return getError(\n      `Unexpect token \"${type.flag}\" in ${this.state.pos} char.`,\n      {\n        pos: this.state.pos,\n      }\n    )\n  }\n\n  expectNext(type?: Token, next?: Token) {\n    if (type && type.expectNext) {\n      if (next && !type.expectNext.call(this, next)) {\n        throw getError(\n          `Unexpect token \"${next.flag}\" token should not be behind \"${type.flag}\" token.(${this.state.pos}th char)`,\n          {\n            pos: this.state.pos,\n          }\n        )\n      }\n    }\n  }\n\n  expectPrev(type?: Token, prev?: Token) {\n    if (type && type.expectPrev) {\n      if (prev && !type.expectPrev.call(this, prev)) {\n        throw getError(\n          `Unexpect token \"${type.flag}\" should not be behind \"${prev.flag}\"(${this.state.pos}th char).`,\n          {\n            pos: this.state.pos,\n          }\n        )\n      }\n    }\n  }\n\n  match(type?: Token) {\n    return this.state.type === type\n  }\n\n  skipSpace() {\n    if (this.curContext() === bracketDContext) return\n    loop: while (this.state.pos < this.input.length) {\n      const ch = this.input.charCodeAt(this.state.pos)\n      switch (ch) {\n        case 32:\n        case 160:\n          ++this.state.pos\n          break\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos\n          break\n        default:\n          if (\n            (ch > 8 && ch < 14) ||\n            (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch)))\n          ) {\n            ++this.state.pos\n          } else {\n            break loop\n          }\n      }\n    }\n  }\n\n  next() {\n    this.type_ = this.state.type\n    if (this.input.length <= this.state.pos) {\n      return this.finishToken(eofTok)\n    }\n    this.skipSpace()\n    this.readToken(\n      this.getCode(),\n      this.state.pos > 0 ? this.getCode(this.state.pos - 1) : -Infinity\n    )\n  }\n\n  getCode(pos = this.state.pos) {\n    return fullCharCodeAtPos(this.input, pos)\n  }\n\n  eat(type) {\n    if (this.match(type)) {\n      this.next()\n      return true\n    } else {\n      return false\n    }\n  }\n\n  readKeyWord() {\n    let startPos = this.state.pos,\n      string = ''\n    while (true) {\n      const code = this.getCode()\n      const prevCode = this.getCode(this.state.pos - 1)\n      if (this.input.length === this.state.pos) {\n        string = slice(this.input, startPos, this.state.pos + 1)\n        break\n      }\n      if (!isRewordCode(code) || prevCode === 92) {\n        if (\n          code === 32 ||\n          code === 160 ||\n          code === 10 ||\n          code === 8232 ||\n          code === 8233\n        ) {\n          string = slice(this.input, startPos, this.state.pos)\n          break\n        }\n        if (code === 13 && this.input.charCodeAt(this.state.pos + 1) === 10) {\n          string = slice(this.input, startPos, this.state.pos)\n          break\n        }\n        if (\n          (code > 8 && code < 14) ||\n          (code >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(code)))\n        ) {\n          string = slice(this.input, startPos, this.state.pos)\n          break\n        }\n        this.state.pos++\n      } else {\n        string = slice(this.input, startPos, this.state.pos)\n        break\n      }\n    }\n\n    this.finishToken(nameTok, string)\n  }\n\n  readIngoreString() {\n    let startPos = this.state.pos,\n      prevCode,\n      string = ''\n    while (true) {\n      const code = this.getCode()\n      if (this.state.pos >= this.input.length) break\n      if ((code === 91 || code === 93) && prevCode === 92) {\n        this.state.pos++\n        prevCode = ''\n      } else if (code == 93 && prevCode === 93) {\n        string = this.input\n          .slice(startPos, this.state.pos - 1)\n          .replace(/\\\\([\\[\\]])/g, '$1')\n        this.state.pos++\n        break\n      } else {\n        this.state.pos++\n        prevCode = code\n      }\n    }\n\n    this.finishToken(ignoreTok, string)\n    this.finishToken(bracketDRTok)\n  }\n\n  finishToken(type: Token, value?: any) {\n    const preType = this.state.type\n    this.state.type = type\n    if (value !== undefined) this.state.value = value\n    this.expectNext(preType, type)\n    this.expectPrev(type, preType)\n    if (type.updateContext) {\n      type.updateContext.call(this, preType)\n    }\n  }\n\n  readToken(code: number, prevCode: number) {\n    if (prevCode === 92) {\n      return this.readKeyWord()\n    }\n    if (this.input.length <= this.state.pos) {\n      this.finishToken(eofTok)\n    } else if (this.curContext() === bracketDContext) {\n      this.readIngoreString()\n    } else if (code === 123) {\n      this.state.pos++\n      this.finishToken(braceLTok)\n    } else if (code === 125) {\n      this.state.pos++\n      this.finishToken(braceRTok)\n    } else if (code === 42) {\n      this.state.pos++\n      if (this.getCode() === 42) {\n        this.state.pos++\n        return this.finishToken(dbStarTok)\n      }\n      this.finishToken(starTok)\n    } else if (code === 33) {\n      this.state.pos++\n      this.finishToken(bangTok)\n    } else if (code === 46) {\n      this.state.pos++\n      this.finishToken(dotTok)\n    } else if (code === 91) {\n      this.state.pos++\n      if (this.getCode() === 91) {\n        this.state.pos++\n        return this.finishToken(bracketDLTok)\n      }\n      this.finishToken(bracketLTok)\n    } else if (code === 126) {\n      this.state.pos++\n      this.finishToken(expandTok)\n    } else if (code === 93) {\n      this.state.pos++\n      this.finishToken(bracketRTok)\n    } else if (code === 40) {\n      this.state.pos++\n      this.finishToken(parenLTok)\n    } else if (code === 41) {\n      this.state.pos++\n      this.finishToken(parenRTok)\n    } else if (code === 44) {\n      this.state.pos++\n      this.finishToken(commaTok)\n    } else if (code === 58) {\n      this.state.pos++\n      this.finishToken(colonTok)\n    } else {\n      this.readKeyWord()\n    }\n  }\n}\n","import { Path } from './index'\ninterface INode {\n  type?: string\n  after?: Node\n  depth?: number\n}\n\nexport type Node =\n  | IdentifierNode\n  | WildcardOperatorNode\n  | GroupExpressionNode\n  | RangeExpressionNode\n  | DestructorExpressionNode\n  | ObjectPatternNode\n  | ArrayPatternNode\n  | DotOperatorNode\n  | ExpandOperatorNode\n  | INode\n\nexport type IdentifierNode = {\n  type: 'Identifier'\n  value: string\n  arrayIndex?: boolean\n} & INode\n\nexport type IgnoreExpressionNode = {\n  type: 'IgnoreExpression'\n  value: string\n} & INode\n\nexport type DotOperatorNode = {\n  type: 'DotOperator'\n} & INode\n\nexport type WildcardOperatorNode = {\n  type: 'WildcardOperator'\n  filter?: GroupExpressionNode | RangeExpressionNode\n  optional?: boolean\n} & INode\n\nexport type ExpandOperatorNode = {\n  type: 'ExpandOperator'\n} & INode\n\nexport type GroupExpressionNode = {\n  type: 'GroupExpression'\n  value: Node[]\n  isExclude?: boolean\n} & INode\n\nexport type RangeExpressionNode = {\n  type: 'RangeExpression'\n  start?: IdentifierNode\n  end?: IdentifierNode\n} & INode\n\nexport type DestructorExpressionNode = {\n  type: 'DestructorExpression'\n  value?: ObjectPatternNode | ArrayPatternNode\n  source?: string\n} & INode\n\nexport type ObjectPatternNode = {\n  type: 'ObjectPattern'\n  properties: ObjectPatternPropertyNode[]\n} & INode\n\nexport type ObjectPatternPropertyNode = {\n  type: 'ObjectPatternProperty'\n  key: IdentifierNode\n  value?: ObjectPatternNode[] | ArrayPatternNode[] | IdentifierNode\n} & INode\n\nexport type ArrayPatternNode = {\n  type: 'ArrayPattern'\n  elements: ObjectPatternNode[] | ArrayPatternNode[] | IdentifierNode[]\n} & INode\n\nexport type DestructorRule = {\n  key?: string | number\n  path?: Array<number | string>\n}\n\nexport type MatcherFunction = ((path: Segments) => boolean) & {\n  path: Path\n}\n\nexport type Pattern =\n  | string\n  | number\n  | Path\n  | Segments\n  | MatcherFunction\n  | RegExp\n\nexport type DestructorRules = DestructorRule[]\n\nexport type Segments = Array<string | number>\n\nexport const isType =\n  <T>(type: string) =>\n  (obj: any): obj is T => {\n    return obj && obj.type === type\n  }\n\nexport const isIdentifier = isType<IdentifierNode>('Identifier')\n\nexport const isIgnoreExpression =\n  isType<IgnoreExpressionNode>('IgnoreExpression')\n\nexport const isDotOperator = isType<DotOperatorNode>('DotOperator')\n\nexport const isWildcardOperator =\n  isType<WildcardOperatorNode>('WildcardOperator')\n\nexport const isExpandOperator = isType<ExpandOperatorNode>('ExpandOperator')\n\nexport const isGroupExpression = isType<GroupExpressionNode>('GroupExpression')\n\nexport const isRangeExpression = isType<RangeExpressionNode>('RangeExpression')\n\nexport const isDestructorExpression = isType<DestructorExpressionNode>(\n  'DestructorExpression'\n)\n\nexport const isObjectPattern = isType<ObjectPatternNode>('ObjectPattern')\n\nexport const isObjectPatternProperty = isType<ObjectPatternPropertyNode>(\n  'ObjectPatternProperty'\n)\n\nexport const isArrayPattern = isType<ArrayPatternNode>('ArrayPattern')\n\nexport type KeyType = string | number | symbol\n\nexport type IAccessors = {\n  get?: (source: any, key: KeyType) => any\n  set?: (source: any, key: KeyType, value: any) => any\n  has?: (source: any, key: KeyType) => boolean\n  delete?: (source: any, key: KeyType) => any\n}\n\nexport type IRegistry = {\n  accessors?: IAccessors\n}\n","const toString = Object.prototype.toString\nconst isType =\n  <T>(type: string) =>\n  (obj: unknown): obj is T =>\n    toString.call(obj) === `[object ${type}]`\nexport const isFn = isType<(...args: any[]) => any>('Function')\nexport const isArr = Array.isArray || isType<unknown[]>('Array')\nexport const isPlainObj = isType<object>('Object')\nexport const isStr = isType<string>('String')\nexport const isBool = isType<boolean>('Boolean')\nexport const isNum = isType<number>('Number')\nexport const isObj = (val: unknown): val is object => typeof val === 'object'\nexport const isRegExp = isType<RegExp>('RegExp')\nexport const isNumberLike = (t: any) => {\n  return isNum(t) || /^(\\d+)(\\.\\d+)?$/.test(t)\n}\nconst isArray = isArr\nconst keyList = Object.keys\nconst hasProp = Object.prototype.hasOwnProperty\n\nexport const toArr = <T>(val: T | T[]): T[] =>\n  Array.isArray(val) ? val : val !== undefined ? [val] : []\nexport const isAssignable = (val: any) => {\n  return typeof val === 'object' || typeof val === 'function'\n}\nexport const isEqual = (a: any, b: any) => {\n  if (a === b) {\n    return true\n  }\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    const arrA = isArray(a)\n    const arrB = isArray(b)\n    let i\n    let length\n    let key\n\n    if (arrA && arrB) {\n      length = a.length\n      if (length !== b.length) {\n        return false\n      }\n      for (i = length; i-- !== 0; ) {\n        if (!isEqual(a[i], b[i])) {\n          return false\n        }\n      }\n      return true\n    }\n\n    if (arrA !== arrB) {\n      return false\n    }\n\n    const keys = keyList(a)\n    length = keys.length\n\n    if (length !== keyList(b).length) {\n      return false\n    }\n\n    for (i = length; i-- !== 0; ) {\n      if (!hasProp.call(b, keys[i])) {\n        return false\n      }\n    }\n    for (i = length; i-- !== 0; ) {\n      key = keys[i]\n      if (!isEqual(a[key], b[key])) {\n        return false\n      }\n    }\n\n    return true\n  }\n  return a !== a && b !== b\n}\nexport const isSegmentEqual = (a: any, b: any) => {\n  a = typeof a === 'symbol' ? a : `${a}`\n  b = typeof b === 'symbol' ? b : `${b}`\n  return a === b\n}\n","import {\n  Segments,\n  Node,\n  DestructorRules,\n  isArrayPattern,\n  isObjectPattern,\n  isIdentifier,\n  isDestructorExpression,\n} from './types'\nimport { isNum } from './shared'\n\ntype Mutators = {\n  getIn: (segments: Segments, source: any) => any\n  setIn: (segments: Segments, source: any, value: any) => void\n  deleteIn?: (segments: Segments, source: any) => any\n  existIn?: (segments: Segments, source: any, start: number) => boolean\n}\n\nconst DestructorCache = new Map()\n\nconst isValid = (val: any) => val !== undefined && val !== null\n\nexport const getDestructor = (source: string) => {\n  return DestructorCache.get(source)\n}\n\nexport const setDestructor = (source: string, rules: DestructorRules) => {\n  DestructorCache.set(source, rules)\n}\n\nexport const parseDestructorRules = (node: Node): DestructorRules => {\n  const rules = []\n  if (isObjectPattern(node)) {\n    let index = 0\n    node.properties.forEach((child) => {\n      rules[index] = {\n        path: [],\n      }\n      rules[index].key = child.key.value\n      rules[index].path.push(child.key.value)\n      if (isIdentifier(child.value)) {\n        rules[index].key = child.value.value\n      }\n      const basePath = rules[index].path\n      const childRules = parseDestructorRules(child.value as Node)\n      let k = index\n      childRules.forEach((rule) => {\n        if (rules[k]) {\n          rules[k].key = rule.key\n          rules[k].path = basePath.concat(rule.path)\n        } else {\n          rules[k] = {\n            key: rule.key,\n            path: basePath.concat(rule.path),\n          }\n        }\n        k++\n      })\n      if (k > index) {\n        index = k\n      } else {\n        index++\n      }\n    })\n    return rules\n  } else if (isArrayPattern(node)) {\n    let index = 0\n    node.elements.forEach((child, key) => {\n      rules[index] = {\n        path: [],\n      }\n      rules[index].key = key\n      rules[index].path.push(key)\n      if (isIdentifier(child)) {\n        rules[index].key = child.value\n      }\n      const basePath = rules[index].path\n      const childRules = parseDestructorRules(child as Node)\n      let k = index\n      childRules.forEach((rule) => {\n        if (rules[k]) {\n          rules[k].key = rule.key\n          rules[k].path = basePath.concat(rule.path)\n        } else {\n          rules[k] = {\n            key: rule.key,\n            path: basePath.concat(rule.path),\n          }\n        }\n        k++\n      })\n      if (k > index) {\n        index = k\n      } else {\n        index++\n      }\n    })\n    return rules\n  }\n  if (isDestructorExpression(node)) {\n    return parseDestructorRules(node.value)\n  }\n  return rules\n}\n\nexport const setInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  value: any,\n  mutators: Mutators\n) => {\n  rules.forEach(({ key, path }) => {\n    mutators.setIn([key], source, mutators.getIn(path, value))\n  })\n}\n\nexport const getInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  mutators: Mutators\n) => {\n  let response = {}\n  if (rules.length) {\n    if (isNum(rules[0].path[0])) {\n      response = []\n    }\n  }\n  source = isValid(source) ? source : {}\n  rules.forEach(({ key, path }) => {\n    mutators.setIn(path, response, source[key])\n  })\n  return response\n}\n\nexport const deleteInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  mutators: Mutators\n) => {\n  rules.forEach(({ key }) => {\n    mutators.deleteIn([key], source)\n  })\n}\n\nexport const existInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  start: number,\n  mutators: Mutators\n) => {\n  return rules.every(({ key }) => {\n    return mutators.existIn([key], source, start)\n  })\n}\n","import { Tokenizer } from './tokenizer'\nimport {\n  Token,\n  nameTok,\n  colonTok,\n  dotTok,\n  starTok,\n  bangTok,\n  bracketLTok,\n  bracketRTok,\n  braceLTok,\n  braceRTok,\n  bracketDLTok,\n  parenLTok,\n  parenRTok,\n  commaTok,\n  expandTok,\n  eofTok,\n  dbStarTok,\n} from './tokens'\nimport { bracketArrayContext, destructorContext } from './contexts'\nimport {\n  IdentifierNode,\n  ExpandOperatorNode,\n  WildcardOperatorNode,\n  RangeExpressionNode,\n  GroupExpressionNode,\n  DotOperatorNode,\n  IgnoreExpressionNode,\n  DestructorExpressionNode,\n  ObjectPatternNode,\n  ObjectPatternPropertyNode,\n  ArrayPatternNode,\n  Node,\n  Segments,\n} from './types'\nimport { parseDestructorRules, setDestructor } from './destructor'\nimport { isNumberLike } from './shared'\nimport { Path } from './index'\n\nconst createTreeBySegments = (segments: Segments = [], afterNode?: Node) => {\n  const segLen = segments.length\n  const build = (start = 0) => {\n    const after = start < segLen - 1 ? build(start + 1) : afterNode\n    const dot = after && {\n      type: 'DotOperator',\n      after,\n    }\n    return {\n      type: 'Identifier',\n      value: segments[start],\n      after: dot,\n    }\n  }\n  return build()\n}\n\nconst calculate = (\n  a: string | number,\n  b: string | number,\n  operator: string\n) => {\n  if (isNumberLike(a) && isNumberLike(b)) {\n    if (operator === '+') return String(Number(a) + Number(b))\n    if (operator === '-') return String(Number(a) - Number(b))\n    if (operator === '*') return String(Number(a) * Number(b))\n    if (operator === '/') return String(Number(a) / Number(b))\n  } else {\n    if (operator === '+') return String(a) + String(b)\n    if (operator === '-') return 'NaN'\n    if (operator === '*') return 'NaN'\n    if (operator === '/') return 'NaN'\n  }\n  return String(Number(b))\n}\n\nexport class Parser extends Tokenizer {\n  public isMatchPattern: boolean\n\n  public isWildMatchPattern: boolean\n\n  public haveExcludePattern: boolean\n\n  public base: Path\n\n  public relative: string | number\n\n  public data: {\n    segments: Segments\n    tree?: Node\n  }\n\n  constructor(input: string, base?: Path) {\n    super(input)\n    this.base = base\n  }\n\n  parse() {\n    let node: Node\n    this.data = {\n      segments: [],\n    }\n    if (!this.eat(eofTok)) {\n      this.next()\n      node = this.parseAtom(this.state.type)\n    }\n    this.data.tree = node\n\n    return node\n  }\n\n  append(parent: Node, node: Node) {\n    if (parent && node) {\n      parent.after = node\n    }\n  }\n\n  parseAtom(type: Token): Node {\n    switch (type) {\n      case braceLTok:\n      case bracketLTok:\n        if (this.includesContext(destructorContext)) {\n          if (type === braceLTok) {\n            return this.parseObjectPattern()\n          } else {\n            return this.parseArrayPattern()\n          }\n        }\n        return this.parseDestructorExpression()\n      case nameTok:\n        return this.parseIdentifier()\n      case expandTok:\n        return this.parseExpandOperator()\n      case dbStarTok:\n      case starTok:\n        return this.parseWildcardOperator()\n      case bracketDLTok:\n        return this.parseIgnoreExpression()\n      case dotTok:\n        return this.parseDotOperator()\n    }\n  }\n\n  pushSegments(key: string | number) {\n    this.data.segments.push(key)\n  }\n\n  parseIdentifier() {\n    const node: IdentifierNode = {\n      type: 'Identifier',\n      value: this.state.value,\n    }\n    const hasNotInDestructor =\n      !this.includesContext(destructorContext) &&\n      !this.isMatchPattern &&\n      !this.isWildMatchPattern\n\n    this.next()\n    if (this.includesContext(bracketArrayContext)) {\n      if (this.state.type !== bracketRTok) {\n        throw this.unexpect()\n      } else {\n        this.state.context.pop()\n        this.next()\n      }\n    } else if (hasNotInDestructor) {\n      this.pushSegments(node.value)\n    }\n    if (this.state.type === bracketLTok) {\n      this.next()\n      if (this.state.type !== nameTok) {\n        throw this.unexpect()\n      }\n      this.state.context.push(bracketArrayContext)\n      let isNumberKey = false\n      if (/^\\d+$/.test(this.state.value)) {\n        isNumberKey = true\n      }\n      const value = this.state.value\n      this.pushSegments(isNumberKey ? Number(value) : value)\n      const after = this.parseAtom(this.state.type) as IdentifierNode\n      if (isNumberKey) {\n        after.arrayIndex = true\n      }\n      this.append(node, after)\n    } else {\n      this.append(node, this.parseAtom(this.state.type))\n    }\n\n    return node\n  }\n\n  parseExpandOperator() {\n    const node: ExpandOperatorNode = {\n      type: 'ExpandOperator',\n    }\n\n    this.isMatchPattern = true\n    this.isWildMatchPattern = true\n    this.data.segments = []\n\n    this.next()\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseWildcardOperator(): WildcardOperatorNode {\n    const node: WildcardOperatorNode = {\n      type: 'WildcardOperator',\n    }\n\n    if (this.state.type === dbStarTok) {\n      node.optional = true\n    }\n\n    this.isMatchPattern = true\n    this.isWildMatchPattern = true\n    this.data.segments = []\n\n    this.next()\n\n    if (this.state.type === parenLTok) {\n      node.filter = this.parseGroupExpression(node)\n    } else if (this.state.type === bracketLTok) {\n      node.filter = this.parseRangeExpression(node)\n    }\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseDestructorExpression(): DestructorExpressionNode {\n    const node: DestructorExpressionNode = {\n      type: 'DestructorExpression',\n    }\n    this.state.context.push(destructorContext)\n    const startPos = this.state.pos - 1\n    node.value =\n      this.state.type === braceLTok\n        ? this.parseObjectPattern()\n        : this.parseArrayPattern()\n    const endPos = this.state.pos\n    this.state.context.pop()\n    node.source = this.input\n      .substring(startPos, endPos)\n      .replace(\n        /\\[\\s*([\\+\\-\\*\\/])?\\s*([^,\\]\\s]*)\\s*\\]/,\n        (match, operator, target) => {\n          if (this.relative !== undefined) {\n            if (operator) {\n              if (target) {\n                return calculate(this.relative, target, operator)\n              } else {\n                return calculate(this.relative, 1, operator)\n              }\n            } else {\n              if (target) {\n                return calculate(this.relative, target, '+')\n              } else {\n                return String(this.relative)\n              }\n            }\n          }\n          return match\n        }\n      )\n      .replace(/\\s*\\.\\s*/g, '')\n      .replace(/\\s*/g, '')\n    if (this.relative === undefined) {\n      setDestructor(node.source, parseDestructorRules(node))\n    }\n    this.relative = undefined\n    this.pushSegments(node.source)\n    this.next()\n    this.append(node, this.parseAtom(this.state.type))\n    return node\n  }\n\n  parseArrayPattern(): ArrayPatternNode {\n    const node: ArrayPatternNode = {\n      type: 'ArrayPattern',\n      elements: [],\n    }\n    this.next()\n    node.elements = this.parseArrayPatternElements()\n    return node\n  }\n\n  parseArrayPatternElements() {\n    const nodes = []\n    while (this.state.type !== bracketRTok && this.state.type !== eofTok) {\n      nodes.push(this.parseAtom(this.state.type))\n      if (this.state.type === bracketRTok) {\n        if (this.includesContext(destructorContext)) {\n          this.next()\n        }\n        return nodes\n      }\n      this.next()\n    }\n    return nodes\n  }\n\n  parseObjectPattern(): ObjectPatternNode {\n    const node: ObjectPatternNode = {\n      type: 'ObjectPattern',\n      properties: [],\n    }\n    this.next()\n    node.properties = this.parseObjectProperties()\n    return node\n  }\n\n  parseObjectProperties(): ObjectPatternPropertyNode[] {\n    const nodes = []\n    while (this.state.type !== braceRTok && this.state.type !== eofTok) {\n      const node: ObjectPatternPropertyNode = {\n        type: 'ObjectPatternProperty',\n        key: this.parseAtom(this.state.type) as IdentifierNode,\n      }\n      nodes.push(node)\n      if (this.state.type === colonTok) {\n        this.next()\n        node.value = this.parseAtom(this.state.type) as\n          | IdentifierNode\n          | ObjectPatternNode[]\n          | ArrayPatternNode[]\n      }\n      if (this.state.type === braceRTok) {\n        if (this.includesContext(destructorContext)) {\n          this.next()\n        }\n        return nodes\n      }\n      this.next()\n    }\n    return nodes\n  }\n\n  parseDotOperator(): Node {\n    const node: DotOperatorNode = {\n      type: 'DotOperator',\n    }\n\n    const prevToken = this.type_\n    if (!prevToken && this.base) {\n      if (this.base.isMatchPattern) {\n        throw new Error('Base path must be an absolute path.')\n      }\n      this.data.segments = this.base.toArr()\n      while (this.state.type === dotTok) {\n        this.relative = this.data.segments.pop()\n        this.next()\n      }\n      return createTreeBySegments(\n        this.data.segments.slice(),\n        this.parseAtom(this.state.type)\n      )\n    } else {\n      this.next()\n    }\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseIgnoreExpression() {\n    this.next()\n\n    const value = String(this.state.value).replace(/\\s*/g, '')\n\n    const node: IgnoreExpressionNode = {\n      type: 'IgnoreExpression',\n      value: value,\n    }\n\n    this.pushSegments(value)\n\n    this.next()\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    this.next()\n\n    return node\n  }\n\n  parseGroupExpression(parent: Node) {\n    const node: GroupExpressionNode = {\n      type: 'GroupExpression',\n      value: [],\n    }\n\n    this.isMatchPattern = true\n    this.data.segments = []\n\n    this.next()\n\n    loop: while (true) {\n      switch (this.state.type) {\n        case commaTok:\n          this.next()\n          break\n        case bangTok:\n          node.isExclude = true\n          this.haveExcludePattern = true\n          this.next()\n          break\n        case eofTok:\n          break loop\n        case parenRTok:\n          break loop\n        default:\n          node.value.push(this.parseAtom(this.state.type))\n      }\n    }\n\n    this.next()\n\n    this.append(parent, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseRangeExpression(parent: Node) {\n    const node: RangeExpressionNode = {\n      type: 'RangeExpression',\n    }\n\n    this.next()\n\n    this.isMatchPattern = true\n    this.data.segments = []\n\n    let start = false,\n      hasColon = false\n\n    loop: while (true) {\n      switch (this.state.type) {\n        case colonTok:\n          hasColon = true\n          start = true\n          this.next()\n          break\n        case bracketRTok:\n          if (!hasColon && !node.end) {\n            node.end = node.start\n          }\n          break loop\n        case commaTok:\n          throw this.unexpect()\n        case eofTok:\n          break loop\n        default:\n          if (!start) {\n            node.start = this.parseAtom(this.state.type) as IdentifierNode\n          } else {\n            node.end = this.parseAtom(this.state.type) as IdentifierNode\n          }\n      }\n    }\n\n    this.next()\n\n    this.append(parent, this.parseAtom(this.state.type))\n\n    return node\n  }\n}\n","import {\n  Segments,\n  Node,\n  isIdentifier,\n  isExpandOperator,\n  isWildcardOperator,\n  isGroupExpression,\n  isRangeExpression,\n  isIgnoreExpression,\n  isDotOperator,\n  isDestructorExpression,\n  IdentifierNode,\n  IgnoreExpressionNode,\n  DestructorExpressionNode,\n  ExpandOperatorNode,\n  WildcardOperatorNode,\n  GroupExpressionNode,\n  RangeExpressionNode,\n  DotOperatorNode,\n} from './types'\nimport { isEqual, toArr, isSegmentEqual } from './shared'\n\nconst isValid = (val) => val !== undefined && val !== null && val !== ''\n\nexport class Matcher {\n  private tree: Node\n\n  private pos: number\n\n  private tail: Node\n\n  private stack: any[]\n\n  private excluding: boolean\n\n  private record: any\n\n  constructor(tree: Node, record?: any) {\n    this.tree = tree\n    this.pos = 0\n    this.excluding = false\n    this.record = record\n    this.stack = []\n  }\n\n  currentElement(path: Segments) {\n    return String(path[this.pos] || '').replace(/\\s*/g, '')\n  }\n\n  matchNext = (node: any, path: any) => {\n    return node.after\n      ? this.matchAtom(path, node.after)\n      : isValid(path[this.pos])\n  }\n\n  recordMatch(match: () => boolean) {\n    return () => {\n      const result = match()\n      if (result) {\n        if (this.record && this.record.score !== undefined) {\n          this.record.score++\n        }\n      }\n      return result\n    }\n  }\n\n  matchIdentifier(path: Segments, node: IdentifierNode) {\n    this.tail = node\n    if (isValid(path[this.pos + 1]) && !node.after) {\n      if (this.stack.length) {\n        for (let i = this.stack.length - 1; i >= 0; i--) {\n          if (!this.stack[i].after || !this.stack[i].filter) {\n            return false\n          }\n        }\n      } else {\n        return false\n      }\n    }\n    let current: any\n    const next = () => {\n      return this.matchNext(node, path)\n    }\n\n    if (isExpandOperator(node.after)) {\n      current = this.recordMatch(\n        () =>\n          node.value === String(path[this.pos]).substring(0, node.value.length)\n      )\n    } else {\n      current = this.recordMatch(() =>\n        isEqual(String(node.value), String(path[this.pos]))\n      )\n    }\n\n    if (this.excluding) {\n      if (node.after) {\n        if (this.pos < path.length) {\n          return current() && next()\n        } else {\n          if (node.after && isWildcardOperator(node.after.after)) {\n            return true\n          }\n          return false\n        }\n      } else {\n        if (this.pos >= path.length) {\n          return true\n        }\n        return current()\n      }\n    }\n\n    return current() && next()\n  }\n\n  matchIgnoreExpression(path: Segments, node: IgnoreExpressionNode) {\n    return (\n      isEqual(node.value, this.currentElement(path)) &&\n      this.matchNext(node, path)\n    )\n  }\n\n  matchDestructorExpression(path: Segments, node: DestructorExpressionNode) {\n    return (\n      isEqual(node.source, this.currentElement(path)) &&\n      this.matchNext(node, path)\n    )\n  }\n\n  matchExpandOperator(path: Segments, node: ExpandOperatorNode) {\n    return this.matchAtom(path, node.after)\n  }\n\n  matchWildcardOperator(path: Segments, node: WildcardOperatorNode) {\n    this.tail = node\n    this.stack.push(node)\n    let matched = false\n    if (node.filter) {\n      if (node.after) {\n        matched =\n          this.matchAtom(path, node.filter) && this.matchAtom(path, node.after)\n      } else {\n        matched = this.matchAtom(path, node.filter)\n      }\n    } else if (node.optional) {\n      matched = true\n    } else {\n      matched = this.matchNext(node, path)\n    }\n    this.stack.pop()\n    return matched\n  }\n\n  matchGroupExpression(path: Segments, node: GroupExpressionNode) {\n    const current = this.pos\n    this.excluding = !!node.isExclude\n    const method = this.excluding ? 'every' : 'some'\n    const result = toArr(node.value)[method]((_node) => {\n      this.pos = current\n      return this.excluding\n        ? !this.matchAtom(path, _node)\n        : this.matchAtom(path, _node)\n    })\n    this.excluding = false\n    return result\n  }\n\n  matchRangeExpression(path: Segments, node: RangeExpressionNode) {\n    if (node.start) {\n      if (node.end) {\n        return (\n          path[this.pos] >= parseInt(node.start.value) &&\n          path[this.pos] <= parseInt(node.end.value)\n        )\n      } else {\n        return path[this.pos] >= parseInt(node.start.value)\n      }\n    } else {\n      if (node.end) {\n        return path[this.pos] <= parseInt(node.end.value)\n      } else {\n        return true\n      }\n    }\n  }\n\n  matchDotOperator(path: Segments, node: DotOperatorNode) {\n    this.pos++\n    return this.matchNext(node, path)\n  }\n\n  matchAtom(path: Segments, node: Node) {\n    if (!node) {\n      if (this.stack.length > 0) return true\n      if (isValid(path[this.pos + 1])) return false\n      if (this.pos == path.length - 1) return true\n    }\n    if (isIdentifier(node)) {\n      return this.matchIdentifier(path, node)\n    } else if (isIgnoreExpression(node)) {\n      return this.matchIgnoreExpression(path, node)\n    } else if (isDestructorExpression(node)) {\n      return this.matchDestructorExpression(path, node)\n    } else if (isExpandOperator(node)) {\n      return this.matchExpandOperator(path, node)\n    } else if (isWildcardOperator(node)) {\n      return this.matchWildcardOperator(path, node)\n    } else if (isGroupExpression(node)) {\n      return this.matchGroupExpression(path, node)\n    } else if (isRangeExpression(node)) {\n      return this.matchRangeExpression(path, node)\n    } else if (isDotOperator(node)) {\n      return this.matchDotOperator(path, node)\n    }\n\n    return true\n  }\n\n  match(path: Segments) {\n    const matched = this.matchAtom(path, this.tree)\n    if (!this.tail) return { matched: false }\n    if (this.tail == this.tree && isWildcardOperator(this.tail)) {\n      return { matched: true }\n    }\n\n    return { matched, record: this.record }\n  }\n\n  static matchSegments(source: Segments, target: Segments, record?: any) {\n    const pos = 0\n    if (source.length !== target.length) return false\n    const match = (pos: number) => {\n      const current = () => {\n        const res = isSegmentEqual(source[pos], target[pos])\n        if (record && record.score !== undefined) {\n          record.score++\n        }\n        return res\n      }\n      const next = () => (pos < source.length - 1 ? match(pos + 1) : true)\n      return current() && next()\n    }\n\n    return { matched: match(pos), record }\n  }\n}\n","import { Parser } from './parser'\nimport { isStr, isArr, isFn, isEqual, isObj, isNum, isRegExp } from './shared'\nimport {\n  getDestructor,\n  getInByDestructor,\n  setInByDestructor,\n  deleteInByDestructor,\n  existInByDestructor,\n} from './destructor'\nimport { Segments, Node, Pattern } from './types'\nimport { Matcher } from './matcher'\n\nconst pathCache = new Map()\n\nconst isMatcher = Symbol('PATH_MATCHER')\n\nconst isValid = (val: any) => val !== undefined && val !== null\n\nconst isAssignable = (val: any) =>\n  typeof val === 'object' || typeof val === 'function'\n\nconst isNumberIndex = (val: any) =>\n  isStr(val) ? /^\\d+$/.test(val) : isNum(val)\n\nconst getIn = (segments: Segments, source: any) => {\n  for (let i = 0; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (!isValid(source)) {\n        if (i !== segments.length - 1) {\n          return source\n        }\n        break\n      }\n      source = source[index]\n    } else {\n      source = getInByDestructor(source, rules, { setIn, getIn })\n      break\n    }\n  }\n  return source\n}\n\nconst setIn = (segments: Segments, source: any, value: any) => {\n  for (let i = 0; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (!isValid(source) || !isAssignable(source)) return\n      if (isArr(source) && !isNumberIndex(index)) {\n        return\n      }\n      if (!isValid(source[index])) {\n        if (value === undefined) {\n          return\n        }\n        if (i < segments.length - 1) {\n          source[index] = isNum(segments[i + 1]) ? [] : {}\n        }\n      }\n      if (i === segments.length - 1) {\n        source[index] = value\n      }\n      source = source[index]\n    } else {\n      setInByDestructor(source, rules, value, { setIn, getIn })\n      break\n    }\n  }\n}\n\nconst deleteIn = (segments: Segments, source: any) => {\n  for (let i = 0; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (i === segments.length - 1 && isValid(source)) {\n        delete source[index]\n        return\n      }\n\n      if (!isValid(source) || !isAssignable(source)) return\n      source = source[index]\n      if (!isObj(source)) {\n        return\n      }\n    } else {\n      deleteInByDestructor(source, rules, {\n        setIn,\n        getIn,\n        deleteIn,\n      })\n      break\n    }\n  }\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\nconst existIn = (segments: Segments, source: any, start: number | Path) => {\n  if (start instanceof Path) {\n    start = start.length\n  }\n  for (let i = start; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (i === segments.length - 1) {\n        return hasOwnProperty.call(source, index)\n      }\n\n      if (!isValid(source) || !isAssignable(source)) return false\n      source = source[index]\n\n      if (!isObj(source)) {\n        return false\n      }\n    } else {\n      return existInByDestructor(source, rules, start, {\n        setIn,\n        getIn,\n        deleteIn,\n        existIn,\n      })\n    }\n  }\n}\n\nconst parse = (pattern: Pattern, base?: Pattern) => {\n  if (pattern instanceof Path) {\n    return {\n      entire: pattern.entire,\n      segments: pattern.segments.slice(),\n      isRegExp: false,\n      isWildMatchPattern: pattern.isWildMatchPattern,\n      isMatchPattern: pattern.isMatchPattern,\n      haveExcludePattern: pattern.haveExcludePattern,\n      tree: pattern.tree,\n    }\n  } else if (isStr(pattern)) {\n    if (!pattern)\n      return {\n        entire: '',\n        segments: [],\n        isRegExp: false,\n        isWildMatchPattern: false,\n        haveExcludePattern: false,\n        isMatchPattern: false,\n      }\n    const parser = new Parser(pattern, Path.parse(base))\n    const tree = parser.parse()\n    if (!parser.isMatchPattern) {\n      const segments = parser.data.segments\n      return {\n        entire: segments.join('.'),\n        segments,\n        tree,\n        isRegExp: false,\n        isWildMatchPattern: false,\n        haveExcludePattern: false,\n        isMatchPattern: false,\n      }\n    } else {\n      return {\n        entire: pattern,\n        segments: [],\n        isRegExp: false,\n        isWildMatchPattern: parser.isWildMatchPattern,\n        haveExcludePattern: parser.haveExcludePattern,\n        isMatchPattern: true,\n        tree,\n      }\n    }\n  } else if (isFn(pattern) && pattern[isMatcher]) {\n    return parse(pattern['path'])\n  } else if (isArr(pattern)) {\n    return {\n      entire: pattern.join('.'),\n      segments: pattern.reduce((buf, key) => {\n        return buf.concat(parseString(key))\n      }, []),\n      isRegExp: false,\n      isWildMatchPattern: false,\n      haveExcludePattern: false,\n      isMatchPattern: false,\n    }\n  } else if (isRegExp(pattern)) {\n    return {\n      entire: pattern,\n      segments: [],\n      isRegExp: true,\n      isWildMatchPattern: false,\n      haveExcludePattern: false,\n      isMatchPattern: true,\n    }\n  } else {\n    return {\n      entire: '',\n      isRegExp: false,\n      segments: pattern !== undefined ? [pattern] : [],\n      isWildMatchPattern: false,\n      haveExcludePattern: false,\n      isMatchPattern: false,\n    }\n  }\n}\n\nconst parseString = (source: any) => {\n  if (isStr(source)) {\n    source = source.replace(/\\s*/g, '')\n    try {\n      const { segments, isMatchPattern } = parse(source)\n      return !isMatchPattern ? segments : source\n    } catch (e) {\n      return source\n    }\n  } else if (source instanceof Path) {\n    return source.segments\n  }\n  return source\n}\n\nexport class Path {\n  public entire: string | RegExp\n  public segments: Segments\n  public isMatchPattern: boolean\n  public isWildMatchPattern: boolean\n  public isRegExp: boolean\n  public haveExcludePattern: boolean\n  public matchScore: number\n  public tree: Node\n  private matchCache: any\n  private includesCache: any\n\n  constructor(input: Pattern, base?: Pattern) {\n    const {\n      tree,\n      segments,\n      entire,\n      isRegExp,\n      isMatchPattern,\n      isWildMatchPattern,\n      haveExcludePattern,\n    } = parse(input, base)\n    this.entire = entire\n    this.segments = segments\n    this.isMatchPattern = isMatchPattern\n    this.isWildMatchPattern = isWildMatchPattern\n    this.isRegExp = isRegExp\n    this.haveExcludePattern = haveExcludePattern\n    this.tree = tree as Node\n    this.matchCache = new Map()\n    this.includesCache = new Map()\n  }\n\n  toString() {\n    return this.entire?.toString()\n  }\n\n  toArr() {\n    return this.segments?.slice()\n  }\n\n  get length() {\n    return this.segments.length\n  }\n\n  concat = (...args: Pattern[]) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be concat`)\n    }\n    const path = new Path('')\n    path.segments = this.segments.concat(...args.map((s) => parseString(s)))\n    path.entire = path.segments.join('.')\n    return path\n  }\n\n  slice = (start?: number, end?: number) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be slice`)\n    }\n    const path = new Path('')\n    path.segments = this.segments.slice(start, end)\n    path.entire = path.segments.join('.')\n    return path\n  }\n\n  push = (...items: Pattern[]) => {\n    return this.concat(...items)\n  }\n\n  pop = () => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be pop`)\n    }\n    return new Path(this.segments.slice(0, this.segments.length - 1))\n  }\n\n  splice = (\n    start: number,\n    deleteCount?: number,\n    ...items: Array<string | number>\n  ) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be splice`)\n    }\n    items = items.reduce((buf, item) => buf.concat(parseString(item)), [])\n    const segments_ = this.segments.slice()\n    segments_.splice(start, deleteCount, ...items)\n    return new Path(segments_)\n  }\n\n  forEach = (callback: (key: string | number) => any) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be each`)\n    }\n    this.segments.forEach(callback)\n  }\n\n  map = (callback: (key: string | number) => any) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be map`)\n    }\n    return this.segments.map(callback)\n  }\n\n  reduce = <T>(\n    callback: (buf: T, item: string | number, index: number) => T,\n    initial: T\n  ): T => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be reduce`)\n    }\n    return this.segments.reduce(callback, initial)\n  }\n\n  parent = () => {\n    return this.slice(0, this.length - 1)\n  }\n\n  includes = (pattern: Pattern) => {\n    const { entire, segments, isMatchPattern } = Path.parse(pattern)\n    const cache = this.includesCache.get(entire)\n    if (cache !== undefined) return cache\n    const cacheWith = (value: boolean): boolean => {\n      this.includesCache.set(entire, value)\n      return value\n    }\n    if (this.isMatchPattern) {\n      if (!isMatchPattern) {\n        return cacheWith(this.match(segments))\n      } else {\n        throw new Error(`${this.entire} cannot be used to match ${entire}`)\n      }\n    }\n    if (isMatchPattern) {\n      throw new Error(`${this.entire} cannot be used to match ${entire}`)\n    }\n    if (segments.length > this.segments.length) return cacheWith(false)\n    for (let i = 0; i < segments.length; i++) {\n      if (!isEqual(String(segments[i]), String(this.segments[i]))) {\n        return cacheWith(false)\n      }\n    }\n    return cacheWith(true)\n  }\n\n  transform = <T>(\n    regexp: string | RegExp,\n    callback: (...args: string[]) => T\n  ): T | string => {\n    if (!isFn(callback)) return ''\n    if (this.isMatchPattern) {\n      throw new Error(`${this.entire} cannot be transformed`)\n    }\n    const args = this.segments.reduce((buf, key) => {\n      return new RegExp(regexp).test(key as string) ? buf.concat(key) : buf\n    }, [])\n    return callback(...args)\n  }\n\n  match = (pattern: Pattern): boolean => {\n    const path = Path.parse(pattern)\n    const cache = this.matchCache.get(path.entire)\n    if (cache !== undefined) {\n      if (cache.record && cache.record.score !== undefined) {\n        this.matchScore = cache.record.score\n      }\n      return cache.matched\n    }\n    const cacheWith = (value: any) => {\n      this.matchCache.set(path.entire, value)\n      return value\n    }\n    if (path.isMatchPattern) {\n      if (this.isMatchPattern) {\n        throw new Error(`${path.entire} cannot match ${this.entire}`)\n      } else {\n        this.matchScore = 0\n        return cacheWith(path.match(this.segments))\n      }\n    } else {\n      if (this.isMatchPattern) {\n        if (this.isRegExp) {\n          try {\n            return this['entire']?.['test']?.(path.entire)\n          } finally {\n            ;(this.entire as RegExp).lastIndex = 0\n          }\n        }\n        const record = {\n          score: 0,\n        }\n        const result = cacheWith(\n          new Matcher(this.tree, record).match(path.segments)\n        )\n        this.matchScore = record.score\n        return result.matched\n      } else {\n        const record = {\n          score: 0,\n        }\n        const result = cacheWith(\n          Matcher.matchSegments(this.segments, path.segments, record)\n        )\n        this.matchScore = record.score\n        return result.matched\n      }\n    }\n  }\n\n  //\n  matchAliasGroup = (name: Pattern, alias: Pattern) => {\n    const namePath = Path.parse(name)\n    const aliasPath = Path.parse(alias)\n    const nameMatched = this.match(namePath)\n    const nameMatchedScore = this.matchScore\n    const aliasMatched = this.match(aliasPath)\n    const aliasMatchedScore = this.matchScore\n    if (this.haveExcludePattern) {\n      if (nameMatchedScore >= aliasMatchedScore) {\n        return nameMatched\n      } else {\n        return aliasMatched\n      }\n    } else {\n      return nameMatched || aliasMatched\n    }\n  }\n\n  existIn = (source?: any, start: number | Path = 0) => {\n    return existIn(this.segments, source, start)\n  }\n\n  getIn = (source?: any) => {\n    return getIn(this.segments, source)\n  }\n\n  setIn = (source?: any, value?: any) => {\n    setIn(this.segments, source, value)\n    return source\n  }\n\n  deleteIn = (source?: any) => {\n    deleteIn(this.segments, source)\n    return source\n  }\n\n  ensureIn = (source?: any, defaults?: any) => {\n    const results = this.getIn(source)\n    if (results === undefined) {\n      this.setIn(source, defaults)\n      return this.getIn(source)\n    }\n    return results\n  }\n\n  static match(pattern: Pattern) {\n    const path = Path.parse(pattern)\n    const matcher = (target) => {\n      return path.match(target)\n    }\n    matcher[isMatcher] = true\n    matcher.path = path\n    return matcher\n  }\n\n  static isPathPattern(target: any): target is Pattern {\n    if (\n      isStr(target) ||\n      isArr(target) ||\n      isRegExp(target) ||\n      (isFn(target) && target[isMatcher])\n    ) {\n      return true\n    }\n    return false\n  }\n\n  static transform<T>(\n    pattern: Pattern,\n    regexp: string | RegExp,\n    callback: (...args: string[]) => T\n  ): any {\n    return Path.parse(pattern).transform(regexp, callback)\n  }\n\n  static parse(path: Pattern = '', base?: Pattern): Path {\n    if (path instanceof Path) {\n      const found = pathCache.get(path.entire)\n      if (found) {\n        return found\n      } else {\n        pathCache.set(path.entire, path)\n        return path\n      }\n    } else if (path && path[isMatcher]) {\n      return Path.parse(path['path'])\n    } else {\n      const key_ = base ? Path.parse(base) : ''\n      const key = `${path}:${key_}`\n      const found = pathCache.get(key)\n      if (found) {\n        return found\n      } else {\n        path = new Path(path, base)\n        pathCache.set(key, path)\n        return path\n      }\n    }\n  }\n\n  static getIn = (source: any, pattern: Pattern) => {\n    const path = Path.parse(pattern)\n    return path.getIn(source)\n  }\n\n  static setIn = (source: any, pattern: Pattern, value: any) => {\n    const path = Path.parse(pattern)\n    return path.setIn(source, value)\n  }\n\n  static deleteIn = (source: any, pattern: Pattern) => {\n    const path = Path.parse(pattern)\n    return path.deleteIn(source)\n  }\n\n  static existIn = (source: any, pattern: Pattern, start?: number | Path) => {\n    const path = Path.parse(pattern)\n    return path.existIn(source, start)\n  }\n\n  static ensureIn = (source: any, pattern: Pattern, defaultValue?: any) => {\n    const path = Path.parse(pattern)\n    return path.ensureIn(source, defaultValue)\n  }\n}\n\nexport { Pattern }\n"],"names":["isType","isValid"],"mappings":"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"}
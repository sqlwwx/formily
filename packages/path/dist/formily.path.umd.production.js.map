{"version":3,"file":"formily.path.umd.production.js","sources":["../src/contexts.ts","../src/tokens.ts","../src/tokenizer.ts","../src/types.ts","../src/shared.ts","../src/destructor.ts","../src/parser.ts","../src/matcher.ts","../src/index.ts"],"sourcesContent":["export type Context = {\n  flag: string\n  [key: string]: any\n}\n\nconst ContextType = (flag: string, props?: any): Context => {\n  return {\n    flag,\n    ...props,\n  }\n}\n\nexport const bracketContext = ContextType('[]')\n\nexport const bracketArrayContext = ContextType('[\\\\d]')\n\nexport const bracketDContext = ContextType('[[]]')\n\nexport const parenContext = ContextType('()')\n\nexport const braceContext = ContextType('{}')\n\nexport const destructorContext = ContextType('{x}')\n","import {\n  bracketContext,\n  parenContext,\n  bracketArrayContext,\n  bracketDContext,\n  braceContext,\n  destructorContext,\n} from './contexts'\n\ninterface ITokenProps {\n  expectNext?: (next?: Token) => boolean\n  expectPrev?: (prev?: Token) => boolean\n  updateContext?: (prev?: Token) => void\n}\n\nexport type Token = ITokenProps & {\n  flag: string\n}\n\nconst TokenType = (flag: string, props?: ITokenProps): Token => {\n  return {\n    flag,\n    ...props,\n  }\n}\n\nexport const nameTok = TokenType('name', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return (\n        next === nameTok ||\n        next === commaTok ||\n        next === bracketRTok ||\n        next === braceRTok ||\n        next === colonTok\n      )\n    }\n    return (\n      next === dotTok ||\n      next === commaTok ||\n      next === eofTok ||\n      next === bracketRTok ||\n      next === parenRTok ||\n      next === colonTok ||\n      next === expandTok ||\n      next === bracketLTok\n    )\n  },\n})\nexport const starTok = TokenType('*', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === parenLTok ||\n      next === bracketLTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok\n    )\n  },\n})\nexport const dbStarTok = TokenType('**', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === parenLTok ||\n      next === bracketLTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok\n    )\n  },\n})\nexport const dotTok = TokenType('.', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === nameTok ||\n      next === bracketDLTok ||\n      next === starTok ||\n      next === dbStarTok ||\n      next === bracketLTok ||\n      next === braceLTok ||\n      next === eofTok\n    )\n  },\n  expectPrev(prev) {\n    return (\n      prev === dotTok ||\n      prev === nameTok ||\n      prev === bracketDRTok ||\n      prev === starTok ||\n      prev === parenRTok ||\n      prev === bracketRTok ||\n      prev === expandTok ||\n      prev === braceRTok\n    )\n  },\n})\nexport const bangTok = TokenType('!', {\n  expectNext(next) {\n    return next === nameTok || next === bracketDLTok\n  },\n})\nexport const colonTok = TokenType(':', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return next === nameTok || next === braceLTok || next === bracketLTok\n    }\n    return next === nameTok || next === bracketDLTok || next === bracketRTok\n  },\n})\n\nexport const braceLTok = TokenType('{', {\n  expectNext(next) {\n    return next === nameTok\n  },\n  expectPrev(prev) {\n    if (this.includesContext(destructorContext)) {\n      return prev === colonTok || prev === commaTok || prev === bracketLTok\n    }\n    return prev === dotTok || prev === colonTok || prev === parenLTok\n  },\n  updateContext() {\n    this.state.context.push(braceContext)\n  },\n})\n\nexport const braceRTok = TokenType('}', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return (\n        next === commaTok ||\n        next === braceRTok ||\n        next === eofTok ||\n        next === bracketRTok\n      )\n    }\n    return next === dotTok || next === eofTok || next === commaTok\n  },\n  expectPrev(prev) {\n    return prev === nameTok || prev === braceRTok || prev === bracketRTok\n  },\n  updateContext() {\n    this.state.context.pop(braceContext)\n  },\n})\n\nexport const bracketLTok = TokenType('[', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return (\n        next === nameTok ||\n        next === bracketLTok ||\n        next === braceLTok ||\n        next === bracketRTok\n      )\n    }\n    return (\n      next === nameTok ||\n      next === bracketDLTok ||\n      next === colonTok ||\n      next === bracketLTok ||\n      next === ignoreTok ||\n      next === bracketRTok\n    )\n  },\n  expectPrev(prev) {\n    if (this.includesContext(destructorContext)) {\n      return prev === colonTok || prev === commaTok || prev === bracketLTok\n    }\n    return (\n      prev === starTok ||\n      prev === bracketLTok ||\n      prev === dotTok ||\n      prev === nameTok ||\n      prev === parenLTok ||\n      prev == commaTok\n    )\n  },\n  updateContext() {\n    this.state.context.push(bracketContext)\n  },\n})\n\nexport const bracketRTok = TokenType(']', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return (\n        next === commaTok ||\n        next === braceRTok ||\n        next === bracketRTok ||\n        next === eofTok\n      )\n    }\n    return (\n      next === dotTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok ||\n      next === bracketRTok\n    )\n  },\n  updateContext() {\n    if (this.includesContext(bracketArrayContext)) return\n    if (!this.includesContext(bracketContext)) throw this.unexpect()\n    this.state.context.pop()\n  },\n})\n\nexport const bracketDLTok = TokenType('[[', {\n  updateContext() {\n    this.state.context.push(bracketDContext)\n  },\n})\n\nexport const bracketDRTok = TokenType(']]', {\n  updateContext() {\n    if (this.curContext() !== bracketDContext) throw this.unexpect()\n    this.state.context.pop()\n  },\n})\n\nexport const parenLTok = TokenType('(', {\n  expectNext(next) {\n    return (\n      next === nameTok ||\n      next === bracketDLTok ||\n      next === braceLTok ||\n      next === bangTok ||\n      next === bracketLTok\n    )\n  },\n  expectPrev(prev) {\n    return prev === starTok\n  },\n  updateContext() {\n    this.state.context.push(parenContext)\n  },\n})\nexport const parenRTok = TokenType(')', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok\n    )\n  },\n  updateContext() {\n    if (this.curContext() !== parenContext) throw this.unexpect()\n    this.state.context.pop()\n  },\n})\n\nexport const commaTok = TokenType(',', {\n  expectNext(next) {\n    return (\n      next === nameTok ||\n      next === bracketDLTok ||\n      next === bracketLTok ||\n      next === braceLTok\n    )\n  },\n})\nexport const ignoreTok = TokenType('ignore', {\n  expectNext(next) {\n    return next === bracketDRTok\n  },\n  expectPrev(prev) {\n    return prev == bracketDLTok\n  },\n})\n\nexport const expandTok = TokenType('expandTok', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok\n    )\n  },\n})\n\nexport const eofTok = TokenType('eof')\n","import {\n  Token,\n  nameTok,\n  colonTok,\n  dotTok,\n  starTok,\n  dbStarTok,\n  bangTok,\n  bracketLTok,\n  bracketRTok,\n  bracketDRTok,\n  expandTok,\n  parenLTok,\n  parenRTok,\n  commaTok,\n  eofTok,\n  ignoreTok,\n  braceLTok,\n  braceRTok,\n  bracketDLTok,\n} from './tokens'\nimport { bracketDContext, Context } from './contexts'\n\nconst nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/\n\nconst fullCharCodeAtPos = (input: string, pos: number) => {\n  if (String.fromCharCode) return input.codePointAt(pos)\n  const code = input.charCodeAt(pos)\n  if (code <= 0xd7ff || code >= 0xe000) return code\n\n  const next = input.charCodeAt(pos + 1)\n  return (code << 10) + next - 0x35fdc00\n}\n\nconst isRewordCode = (code: number) =>\n  code === 42 ||\n  code === 46 ||\n  code === 33 ||\n  code === 91 ||\n  code === 93 ||\n  code === 40 ||\n  code === 41 ||\n  code === 44 ||\n  code === 58 ||\n  code === 126 ||\n  code === 123 ||\n  code === 125\n\nconst getError = (message?: string, props?: any) => {\n  const err = new Error(message)\n  Object.assign(err, props)\n  return err\n}\n\nconst slice = (string: string, start: number, end: number) => {\n  let str = ''\n  for (let i = start; i < end; i++) {\n    const ch = string.charAt(i)\n    if (ch !== '\\\\') {\n      str += ch\n    }\n  }\n  return str\n}\n\nexport class Tokenizer {\n  public input: string\n  public state: {\n    context: Context[]\n    type: Token\n    pos: number\n    value?: any\n  }\n  public type_: Token\n  constructor(input: string) {\n    this.input = input\n    this.state = {\n      context: [],\n      type: null,\n      pos: 0,\n    }\n    this.type_ = null\n  }\n\n  curContext() {\n    return this.state.context[this.state.context.length - 1]\n  }\n\n  includesContext(context: Context) {\n    for (let len = this.state.context.length - 1; len >= 0; len--) {\n      if (this.state.context[len] === context) {\n        return true\n      }\n    }\n    return false\n  }\n\n  unexpect(type?: Token) {\n    type = type || this.state.type\n    return getError(\n      `Unexpect token \"${type.flag}\" in ${this.state.pos} char.`,\n      {\n        pos: this.state.pos,\n      }\n    )\n  }\n\n  expectNext(type?: Token, next?: Token) {\n    if (type && type.expectNext) {\n      if (next && !type.expectNext.call(this, next)) {\n        throw getError(\n          `Unexpect token \"${next.flag}\" token should not be behind \"${type.flag}\" token.(${this.state.pos}th char)`,\n          {\n            pos: this.state.pos,\n          }\n        )\n      }\n    }\n  }\n\n  expectPrev(type?: Token, prev?: Token) {\n    if (type && type.expectPrev) {\n      if (prev && !type.expectPrev.call(this, prev)) {\n        throw getError(\n          `Unexpect token \"${type.flag}\" should not be behind \"${prev.flag}\"(${this.state.pos}th char).`,\n          {\n            pos: this.state.pos,\n          }\n        )\n      }\n    }\n  }\n\n  match(type?: Token) {\n    return this.state.type === type\n  }\n\n  skipSpace() {\n    if (this.curContext() === bracketDContext) return\n    loop: while (this.state.pos < this.input.length) {\n      const ch = this.input.charCodeAt(this.state.pos)\n      switch (ch) {\n        case 32:\n        case 160:\n          ++this.state.pos\n          break\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos\n          break\n        default:\n          if (\n            (ch > 8 && ch < 14) ||\n            (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch)))\n          ) {\n            ++this.state.pos\n          } else {\n            break loop\n          }\n      }\n    }\n  }\n\n  next() {\n    this.type_ = this.state.type\n    if (this.input.length <= this.state.pos) {\n      return this.finishToken(eofTok)\n    }\n    this.skipSpace()\n    this.readToken(\n      this.getCode(),\n      this.state.pos > 0 ? this.getCode(this.state.pos - 1) : -Infinity\n    )\n  }\n\n  getCode(pos = this.state.pos) {\n    return fullCharCodeAtPos(this.input, pos)\n  }\n\n  eat(type) {\n    if (this.match(type)) {\n      this.next()\n      return true\n    } else {\n      return false\n    }\n  }\n\n  readKeyWord() {\n    let startPos = this.state.pos,\n      string = ''\n    while (true) {\n      const code = this.getCode()\n      const prevCode = this.getCode(this.state.pos - 1)\n      if (this.input.length === this.state.pos) {\n        string = slice(this.input, startPos, this.state.pos + 1)\n        break\n      }\n      if (!isRewordCode(code) || prevCode === 92) {\n        if (\n          code === 32 ||\n          code === 160 ||\n          code === 10 ||\n          code === 8232 ||\n          code === 8233\n        ) {\n          string = slice(this.input, startPos, this.state.pos)\n          break\n        }\n        if (code === 13 && this.input.charCodeAt(this.state.pos + 1) === 10) {\n          string = slice(this.input, startPos, this.state.pos)\n          break\n        }\n        if (\n          (code > 8 && code < 14) ||\n          (code >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(code)))\n        ) {\n          string = slice(this.input, startPos, this.state.pos)\n          break\n        }\n        this.state.pos++\n      } else {\n        string = slice(this.input, startPos, this.state.pos)\n        break\n      }\n    }\n\n    this.finishToken(nameTok, string)\n  }\n\n  readIngoreString() {\n    let startPos = this.state.pos,\n      prevCode,\n      string = ''\n    while (true) {\n      const code = this.getCode()\n      if (this.state.pos >= this.input.length) break\n      if ((code === 91 || code === 93) && prevCode === 92) {\n        this.state.pos++\n        prevCode = ''\n      } else if (code == 93 && prevCode === 93) {\n        string = this.input\n          .slice(startPos, this.state.pos - 1)\n          .replace(/\\\\([\\[\\]])/g, '$1')\n        this.state.pos++\n        break\n      } else {\n        this.state.pos++\n        prevCode = code\n      }\n    }\n\n    this.finishToken(ignoreTok, string)\n    this.finishToken(bracketDRTok)\n  }\n\n  finishToken(type: Token, value?: any) {\n    const preType = this.state.type\n    this.state.type = type\n    if (value !== undefined) this.state.value = value\n    this.expectNext(preType, type)\n    this.expectPrev(type, preType)\n    if (type.updateContext) {\n      type.updateContext.call(this, preType)\n    }\n  }\n\n  readToken(code: number, prevCode: number) {\n    if (prevCode === 92) {\n      return this.readKeyWord()\n    }\n    if (this.input.length <= this.state.pos) {\n      this.finishToken(eofTok)\n    } else if (this.curContext() === bracketDContext) {\n      this.readIngoreString()\n    } else if (code === 123) {\n      this.state.pos++\n      this.finishToken(braceLTok)\n    } else if (code === 125) {\n      this.state.pos++\n      this.finishToken(braceRTok)\n    } else if (code === 42) {\n      this.state.pos++\n      if (this.getCode() === 42) {\n        this.state.pos++\n        return this.finishToken(dbStarTok)\n      }\n      this.finishToken(starTok)\n    } else if (code === 33) {\n      this.state.pos++\n      this.finishToken(bangTok)\n    } else if (code === 46) {\n      this.state.pos++\n      this.finishToken(dotTok)\n    } else if (code === 91) {\n      this.state.pos++\n      if (this.getCode() === 91) {\n        this.state.pos++\n        return this.finishToken(bracketDLTok)\n      }\n      this.finishToken(bracketLTok)\n    } else if (code === 126) {\n      this.state.pos++\n      this.finishToken(expandTok)\n    } else if (code === 93) {\n      this.state.pos++\n      this.finishToken(bracketRTok)\n    } else if (code === 40) {\n      this.state.pos++\n      this.finishToken(parenLTok)\n    } else if (code === 41) {\n      this.state.pos++\n      this.finishToken(parenRTok)\n    } else if (code === 44) {\n      this.state.pos++\n      this.finishToken(commaTok)\n    } else if (code === 58) {\n      this.state.pos++\n      this.finishToken(colonTok)\n    } else {\n      this.readKeyWord()\n    }\n  }\n}\n","import { Path } from './index'\ninterface INode {\n  type?: string\n  after?: Node\n  depth?: number\n}\n\nexport type Node =\n  | IdentifierNode\n  | WildcardOperatorNode\n  | GroupExpressionNode\n  | RangeExpressionNode\n  | DestructorExpressionNode\n  | ObjectPatternNode\n  | ArrayPatternNode\n  | DotOperatorNode\n  | ExpandOperatorNode\n  | INode\n\nexport type IdentifierNode = {\n  type: 'Identifier'\n  value: string\n  arrayIndex?: boolean\n} & INode\n\nexport type IgnoreExpressionNode = {\n  type: 'IgnoreExpression'\n  value: string\n} & INode\n\nexport type DotOperatorNode = {\n  type: 'DotOperator'\n} & INode\n\nexport type WildcardOperatorNode = {\n  type: 'WildcardOperator'\n  filter?: GroupExpressionNode | RangeExpressionNode\n  optional?: boolean\n} & INode\n\nexport type ExpandOperatorNode = {\n  type: 'ExpandOperator'\n} & INode\n\nexport type GroupExpressionNode = {\n  type: 'GroupExpression'\n  value: Node[]\n  isExclude?: boolean\n} & INode\n\nexport type RangeExpressionNode = {\n  type: 'RangeExpression'\n  start?: IdentifierNode\n  end?: IdentifierNode\n} & INode\n\nexport type DestructorExpressionNode = {\n  type: 'DestructorExpression'\n  value?: ObjectPatternNode | ArrayPatternNode\n  source?: string\n} & INode\n\nexport type ObjectPatternNode = {\n  type: 'ObjectPattern'\n  properties: ObjectPatternPropertyNode[]\n} & INode\n\nexport type ObjectPatternPropertyNode = {\n  type: 'ObjectPatternProperty'\n  key: IdentifierNode\n  value?: ObjectPatternNode[] | ArrayPatternNode[] | IdentifierNode\n} & INode\n\nexport type ArrayPatternNode = {\n  type: 'ArrayPattern'\n  elements: ObjectPatternNode[] | ArrayPatternNode[] | IdentifierNode[]\n} & INode\n\nexport type DestructorRule = {\n  key?: string | number\n  path?: Array<number | string>\n}\n\nexport type MatcherFunction = ((path: Segments) => boolean) & {\n  path: Path\n}\n\nexport type Pattern =\n  | string\n  | number\n  | Path\n  | Segments\n  | MatcherFunction\n  | RegExp\n\nexport type DestructorRules = DestructorRule[]\n\nexport type Segments = Array<string | number>\n\nexport const isType =\n  <T>(type: string) =>\n  (obj: any): obj is T => {\n    return obj && obj.type === type\n  }\n\nexport const isIdentifier = isType<IdentifierNode>('Identifier')\n\nexport const isIgnoreExpression =\n  isType<IgnoreExpressionNode>('IgnoreExpression')\n\nexport const isDotOperator = isType<DotOperatorNode>('DotOperator')\n\nexport const isWildcardOperator =\n  isType<WildcardOperatorNode>('WildcardOperator')\n\nexport const isExpandOperator = isType<ExpandOperatorNode>('ExpandOperator')\n\nexport const isGroupExpression = isType<GroupExpressionNode>('GroupExpression')\n\nexport const isRangeExpression = isType<RangeExpressionNode>('RangeExpression')\n\nexport const isDestructorExpression = isType<DestructorExpressionNode>(\n  'DestructorExpression'\n)\n\nexport const isObjectPattern = isType<ObjectPatternNode>('ObjectPattern')\n\nexport const isObjectPatternProperty = isType<ObjectPatternPropertyNode>(\n  'ObjectPatternProperty'\n)\n\nexport const isArrayPattern = isType<ArrayPatternNode>('ArrayPattern')\n\nexport type KeyType = string | number | symbol\n\nexport type IAccessors = {\n  get?: (source: any, key: KeyType) => any\n  set?: (source: any, key: KeyType, value: any) => any\n  has?: (source: any, key: KeyType) => boolean\n  delete?: (source: any, key: KeyType) => any\n}\n\nexport type IRegistry = {\n  accessors?: IAccessors\n}\n","const toString = Object.prototype.toString\nconst isType =\n  <T>(type: string) =>\n  (obj: unknown): obj is T =>\n    toString.call(obj) === `[object ${type}]`\nexport const isFn = isType<(...args: any[]) => any>('Function')\nexport const isArr = Array.isArray || isType<unknown[]>('Array')\nexport const isPlainObj = isType<object>('Object')\nexport const isStr = isType<string>('String')\nexport const isBool = isType<boolean>('Boolean')\nexport const isNum = isType<number>('Number')\nexport const isObj = (val: unknown): val is object => typeof val === 'object'\nexport const isRegExp = isType<RegExp>('RegExp')\nexport const isNumberLike = (t: any) => {\n  return isNum(t) || /^(\\d+)(\\.\\d+)?$/.test(t)\n}\nconst isArray = isArr\nconst keyList = Object.keys\nconst hasProp = Object.prototype.hasOwnProperty\n\nexport const toArr = <T>(val: T | T[]): T[] =>\n  Array.isArray(val) ? val : val !== undefined ? [val] : []\nexport const isAssignable = (val: any) => {\n  return typeof val === 'object' || typeof val === 'function'\n}\nexport const isEqual = (a: any, b: any) => {\n  if (a === b) {\n    return true\n  }\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    const arrA = isArray(a)\n    const arrB = isArray(b)\n    let i\n    let length\n    let key\n\n    if (arrA && arrB) {\n      length = a.length\n      if (length !== b.length) {\n        return false\n      }\n      for (i = length; i-- !== 0; ) {\n        if (!isEqual(a[i], b[i])) {\n          return false\n        }\n      }\n      return true\n    }\n\n    if (arrA !== arrB) {\n      return false\n    }\n\n    const keys = keyList(a)\n    length = keys.length\n\n    if (length !== keyList(b).length) {\n      return false\n    }\n\n    for (i = length; i-- !== 0; ) {\n      if (!hasProp.call(b, keys[i])) {\n        return false\n      }\n    }\n    for (i = length; i-- !== 0; ) {\n      key = keys[i]\n      if (!isEqual(a[key], b[key])) {\n        return false\n      }\n    }\n\n    return true\n  }\n  return a !== a && b !== b\n}\nexport const isSegmentEqual = (a: any, b: any) => {\n  a = typeof a === 'symbol' ? a : `${a}`\n  b = typeof b === 'symbol' ? b : `${b}`\n  return a === b\n}\n","import {\n  Segments,\n  Node,\n  DestructorRules,\n  isArrayPattern,\n  isObjectPattern,\n  isIdentifier,\n  isDestructorExpression,\n} from './types'\nimport { isNum } from './shared'\n\ntype Mutators = {\n  getIn: (segments: Segments, source: any) => any\n  setIn: (segments: Segments, source: any, value: any) => void\n  deleteIn?: (segments: Segments, source: any) => any\n  existIn?: (segments: Segments, source: any, start: number) => boolean\n}\n\nconst DestructorCache = new Map()\n\nconst isValid = (val: any) => val !== undefined && val !== null\n\nexport const getDestructor = (source: string) => {\n  return DestructorCache.get(source)\n}\n\nexport const setDestructor = (source: string, rules: DestructorRules) => {\n  DestructorCache.set(source, rules)\n}\n\nexport const parseDestructorRules = (node: Node): DestructorRules => {\n  const rules = []\n  if (isObjectPattern(node)) {\n    let index = 0\n    node.properties.forEach((child) => {\n      rules[index] = {\n        path: [],\n      }\n      rules[index].key = child.key.value\n      rules[index].path.push(child.key.value)\n      if (isIdentifier(child.value)) {\n        rules[index].key = child.value.value\n      }\n      const basePath = rules[index].path\n      const childRules = parseDestructorRules(child.value as Node)\n      let k = index\n      childRules.forEach((rule) => {\n        if (rules[k]) {\n          rules[k].key = rule.key\n          rules[k].path = basePath.concat(rule.path)\n        } else {\n          rules[k] = {\n            key: rule.key,\n            path: basePath.concat(rule.path),\n          }\n        }\n        k++\n      })\n      if (k > index) {\n        index = k\n      } else {\n        index++\n      }\n    })\n    return rules\n  } else if (isArrayPattern(node)) {\n    let index = 0\n    node.elements.forEach((child, key) => {\n      rules[index] = {\n        path: [],\n      }\n      rules[index].key = key\n      rules[index].path.push(key)\n      if (isIdentifier(child)) {\n        rules[index].key = child.value\n      }\n      const basePath = rules[index].path\n      const childRules = parseDestructorRules(child as Node)\n      let k = index\n      childRules.forEach((rule) => {\n        if (rules[k]) {\n          rules[k].key = rule.key\n          rules[k].path = basePath.concat(rule.path)\n        } else {\n          rules[k] = {\n            key: rule.key,\n            path: basePath.concat(rule.path),\n          }\n        }\n        k++\n      })\n      if (k > index) {\n        index = k\n      } else {\n        index++\n      }\n    })\n    return rules\n  }\n  if (isDestructorExpression(node)) {\n    return parseDestructorRules(node.value)\n  }\n  return rules\n}\n\nexport const setInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  value: any,\n  mutators: Mutators\n) => {\n  rules.forEach(({ key, path }) => {\n    mutators.setIn([key], source, mutators.getIn(path, value))\n  })\n}\n\nexport const getInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  mutators: Mutators\n) => {\n  let response = {}\n  if (rules.length) {\n    if (isNum(rules[0].path[0])) {\n      response = []\n    }\n  }\n  source = isValid(source) ? source : {}\n  rules.forEach(({ key, path }) => {\n    mutators.setIn(path, response, source[key])\n  })\n  return response\n}\n\nexport const deleteInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  mutators: Mutators\n) => {\n  rules.forEach(({ key }) => {\n    mutators.deleteIn([key], source)\n  })\n}\n\nexport const existInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  start: number,\n  mutators: Mutators\n) => {\n  return rules.every(({ key }) => {\n    return mutators.existIn([key], source, start)\n  })\n}\n","import { Tokenizer } from './tokenizer'\nimport {\n  Token,\n  nameTok,\n  colonTok,\n  dotTok,\n  starTok,\n  bangTok,\n  bracketLTok,\n  bracketRTok,\n  braceLTok,\n  braceRTok,\n  bracketDLTok,\n  parenLTok,\n  parenRTok,\n  commaTok,\n  expandTok,\n  eofTok,\n  dbStarTok,\n} from './tokens'\nimport { bracketArrayContext, destructorContext } from './contexts'\nimport {\n  IdentifierNode,\n  ExpandOperatorNode,\n  WildcardOperatorNode,\n  RangeExpressionNode,\n  GroupExpressionNode,\n  DotOperatorNode,\n  IgnoreExpressionNode,\n  DestructorExpressionNode,\n  ObjectPatternNode,\n  ObjectPatternPropertyNode,\n  ArrayPatternNode,\n  Node,\n  Segments,\n} from './types'\nimport { parseDestructorRules, setDestructor } from './destructor'\nimport { isNumberLike } from './shared'\nimport { Path } from './index'\n\nconst createTreeBySegments = (segments: Segments = [], afterNode?: Node) => {\n  const segLen = segments.length\n  const build = (start = 0) => {\n    const after = start < segLen - 1 ? build(start + 1) : afterNode\n    const dot = after && {\n      type: 'DotOperator',\n      after,\n    }\n    return {\n      type: 'Identifier',\n      value: segments[start],\n      after: dot,\n    }\n  }\n  return build()\n}\n\nconst calculate = (\n  a: string | number,\n  b: string | number,\n  operator: string\n) => {\n  if (isNumberLike(a) && isNumberLike(b)) {\n    if (operator === '+') return String(Number(a) + Number(b))\n    if (operator === '-') return String(Number(a) - Number(b))\n    if (operator === '*') return String(Number(a) * Number(b))\n    if (operator === '/') return String(Number(a) / Number(b))\n  } else {\n    if (operator === '+') return String(a) + String(b)\n    if (operator === '-') return 'NaN'\n    if (operator === '*') return 'NaN'\n    if (operator === '/') return 'NaN'\n  }\n  return String(Number(b))\n}\n\nexport class Parser extends Tokenizer {\n  public isMatchPattern: boolean\n\n  public isWildMatchPattern: boolean\n\n  public haveExcludePattern: boolean\n\n  public base: Path\n\n  public relative: string | number\n\n  public data: {\n    segments: Segments\n    tree?: Node\n  }\n\n  constructor(input: string, base?: Path) {\n    super(input)\n    this.base = base\n  }\n\n  parse() {\n    let node: Node\n    this.data = {\n      segments: [],\n    }\n    if (!this.eat(eofTok)) {\n      this.next()\n      node = this.parseAtom(this.state.type)\n    }\n    this.data.tree = node\n\n    return node\n  }\n\n  append(parent: Node, node: Node) {\n    if (parent && node) {\n      parent.after = node\n    }\n  }\n\n  parseAtom(type: Token): Node {\n    switch (type) {\n      case braceLTok:\n      case bracketLTok:\n        if (this.includesContext(destructorContext)) {\n          if (type === braceLTok) {\n            return this.parseObjectPattern()\n          } else {\n            return this.parseArrayPattern()\n          }\n        }\n        return this.parseDestructorExpression()\n      case nameTok:\n        return this.parseIdentifier()\n      case expandTok:\n        return this.parseExpandOperator()\n      case dbStarTok:\n      case starTok:\n        return this.parseWildcardOperator()\n      case bracketDLTok:\n        return this.parseIgnoreExpression()\n      case dotTok:\n        return this.parseDotOperator()\n    }\n  }\n\n  pushSegments(key: string | number) {\n    this.data.segments.push(key)\n  }\n\n  parseIdentifier() {\n    const node: IdentifierNode = {\n      type: 'Identifier',\n      value: this.state.value,\n    }\n    const hasNotInDestructor =\n      !this.includesContext(destructorContext) &&\n      !this.isMatchPattern &&\n      !this.isWildMatchPattern\n\n    this.next()\n    if (this.includesContext(bracketArrayContext)) {\n      if (this.state.type !== bracketRTok) {\n        throw this.unexpect()\n      } else {\n        this.state.context.pop()\n        this.next()\n      }\n    } else if (hasNotInDestructor) {\n      this.pushSegments(node.value)\n    }\n    if (this.state.type === bracketLTok) {\n      this.next()\n      if (this.state.type !== nameTok) {\n        throw this.unexpect()\n      }\n      this.state.context.push(bracketArrayContext)\n      let isNumberKey = false\n      if (/^\\d+$/.test(this.state.value)) {\n        isNumberKey = true\n      }\n      const value = this.state.value\n      this.pushSegments(isNumberKey ? Number(value) : value)\n      const after = this.parseAtom(this.state.type) as IdentifierNode\n      if (isNumberKey) {\n        after.arrayIndex = true\n      }\n      this.append(node, after)\n    } else {\n      this.append(node, this.parseAtom(this.state.type))\n    }\n\n    return node\n  }\n\n  parseExpandOperator() {\n    const node: ExpandOperatorNode = {\n      type: 'ExpandOperator',\n    }\n\n    this.isMatchPattern = true\n    this.isWildMatchPattern = true\n    this.data.segments = []\n\n    this.next()\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseWildcardOperator(): WildcardOperatorNode {\n    const node: WildcardOperatorNode = {\n      type: 'WildcardOperator',\n    }\n\n    if (this.state.type === dbStarTok) {\n      node.optional = true\n    }\n\n    this.isMatchPattern = true\n    this.isWildMatchPattern = true\n    this.data.segments = []\n\n    this.next()\n\n    if (this.state.type === parenLTok) {\n      node.filter = this.parseGroupExpression(node)\n    } else if (this.state.type === bracketLTok) {\n      node.filter = this.parseRangeExpression(node)\n    }\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseDestructorExpression(): DestructorExpressionNode {\n    const node: DestructorExpressionNode = {\n      type: 'DestructorExpression',\n    }\n    this.state.context.push(destructorContext)\n    const startPos = this.state.pos - 1\n    node.value =\n      this.state.type === braceLTok\n        ? this.parseObjectPattern()\n        : this.parseArrayPattern()\n    const endPos = this.state.pos\n    this.state.context.pop()\n    node.source = this.input\n      .substring(startPos, endPos)\n      .replace(\n        /\\[\\s*([\\+\\-\\*\\/])?\\s*([^,\\]\\s]*)\\s*\\]/,\n        (match, operator, target) => {\n          if (this.relative !== undefined) {\n            if (operator) {\n              if (target) {\n                return calculate(this.relative, target, operator)\n              } else {\n                return calculate(this.relative, 1, operator)\n              }\n            } else {\n              if (target) {\n                return calculate(this.relative, target, '+')\n              } else {\n                return String(this.relative)\n              }\n            }\n          }\n          return match\n        }\n      )\n      .replace(/\\s*\\.\\s*/g, '')\n      .replace(/\\s*/g, '')\n    if (this.relative === undefined) {\n      setDestructor(node.source, parseDestructorRules(node))\n    }\n    this.relative = undefined\n    this.pushSegments(node.source)\n    this.next()\n    this.append(node, this.parseAtom(this.state.type))\n    return node\n  }\n\n  parseArrayPattern(): ArrayPatternNode {\n    const node: ArrayPatternNode = {\n      type: 'ArrayPattern',\n      elements: [],\n    }\n    this.next()\n    node.elements = this.parseArrayPatternElements()\n    return node\n  }\n\n  parseArrayPatternElements() {\n    const nodes = []\n    while (this.state.type !== bracketRTok && this.state.type !== eofTok) {\n      nodes.push(this.parseAtom(this.state.type))\n      if (this.state.type === bracketRTok) {\n        if (this.includesContext(destructorContext)) {\n          this.next()\n        }\n        return nodes\n      }\n      this.next()\n    }\n    return nodes\n  }\n\n  parseObjectPattern(): ObjectPatternNode {\n    const node: ObjectPatternNode = {\n      type: 'ObjectPattern',\n      properties: [],\n    }\n    this.next()\n    node.properties = this.parseObjectProperties()\n    return node\n  }\n\n  parseObjectProperties(): ObjectPatternPropertyNode[] {\n    const nodes = []\n    while (this.state.type !== braceRTok && this.state.type !== eofTok) {\n      const node: ObjectPatternPropertyNode = {\n        type: 'ObjectPatternProperty',\n        key: this.parseAtom(this.state.type) as IdentifierNode,\n      }\n      nodes.push(node)\n      if (this.state.type === colonTok) {\n        this.next()\n        node.value = this.parseAtom(this.state.type) as\n          | IdentifierNode\n          | ObjectPatternNode[]\n          | ArrayPatternNode[]\n      }\n      if (this.state.type === braceRTok) {\n        if (this.includesContext(destructorContext)) {\n          this.next()\n        }\n        return nodes\n      }\n      this.next()\n    }\n    return nodes\n  }\n\n  parseDotOperator(): Node {\n    const node: DotOperatorNode = {\n      type: 'DotOperator',\n    }\n\n    const prevToken = this.type_\n    if (!prevToken && this.base) {\n      if (this.base.isMatchPattern) {\n        throw new Error('Base path must be an absolute path.')\n      }\n      this.data.segments = this.base.toArr()\n      while (this.state.type === dotTok) {\n        this.relative = this.data.segments.pop()\n        this.next()\n      }\n      return createTreeBySegments(\n        this.data.segments.slice(),\n        this.parseAtom(this.state.type)\n      )\n    } else {\n      this.next()\n    }\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseIgnoreExpression() {\n    this.next()\n\n    const value = String(this.state.value).replace(/\\s*/g, '')\n\n    const node: IgnoreExpressionNode = {\n      type: 'IgnoreExpression',\n      value: value,\n    }\n\n    this.pushSegments(value)\n\n    this.next()\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    this.next()\n\n    return node\n  }\n\n  parseGroupExpression(parent: Node) {\n    const node: GroupExpressionNode = {\n      type: 'GroupExpression',\n      value: [],\n    }\n\n    this.isMatchPattern = true\n    this.data.segments = []\n\n    this.next()\n\n    loop: while (true) {\n      switch (this.state.type) {\n        case commaTok:\n          this.next()\n          break\n        case bangTok:\n          node.isExclude = true\n          this.haveExcludePattern = true\n          this.next()\n          break\n        case eofTok:\n          break loop\n        case parenRTok:\n          break loop\n        default:\n          node.value.push(this.parseAtom(this.state.type))\n      }\n    }\n\n    this.next()\n\n    this.append(parent, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseRangeExpression(parent: Node) {\n    const node: RangeExpressionNode = {\n      type: 'RangeExpression',\n    }\n\n    this.next()\n\n    this.isMatchPattern = true\n    this.data.segments = []\n\n    let start = false,\n      hasColon = false\n\n    loop: while (true) {\n      switch (this.state.type) {\n        case colonTok:\n          hasColon = true\n          start = true\n          this.next()\n          break\n        case bracketRTok:\n          if (!hasColon && !node.end) {\n            node.end = node.start\n          }\n          break loop\n        case commaTok:\n          throw this.unexpect()\n        case eofTok:\n          break loop\n        default:\n          if (!start) {\n            node.start = this.parseAtom(this.state.type) as IdentifierNode\n          } else {\n            node.end = this.parseAtom(this.state.type) as IdentifierNode\n          }\n      }\n    }\n\n    this.next()\n\n    this.append(parent, this.parseAtom(this.state.type))\n\n    return node\n  }\n}\n","import {\n  Segments,\n  Node,\n  isIdentifier,\n  isExpandOperator,\n  isWildcardOperator,\n  isGroupExpression,\n  isRangeExpression,\n  isIgnoreExpression,\n  isDotOperator,\n  isDestructorExpression,\n  IdentifierNode,\n  IgnoreExpressionNode,\n  DestructorExpressionNode,\n  ExpandOperatorNode,\n  WildcardOperatorNode,\n  GroupExpressionNode,\n  RangeExpressionNode,\n  DotOperatorNode,\n} from './types'\nimport { isEqual, toArr, isSegmentEqual } from './shared'\n\nconst isValid = (val) => val !== undefined && val !== null && val !== ''\n\nexport class Matcher {\n  private tree: Node\n\n  private pos: number\n\n  private tail: Node\n\n  private stack: any[]\n\n  private excluding: boolean\n\n  private record: any\n\n  constructor(tree: Node, record?: any) {\n    this.tree = tree\n    this.pos = 0\n    this.excluding = false\n    this.record = record\n    this.stack = []\n  }\n\n  currentElement(path: Segments) {\n    return String(path[this.pos] || '').replace(/\\s*/g, '')\n  }\n\n  matchNext = (node: any, path: any) => {\n    return node.after\n      ? this.matchAtom(path, node.after)\n      : isValid(path[this.pos])\n  }\n\n  recordMatch(match: () => boolean) {\n    return () => {\n      const result = match()\n      if (result) {\n        if (this.record && this.record.score !== undefined) {\n          this.record.score++\n        }\n      }\n      return result\n    }\n  }\n\n  matchIdentifier(path: Segments, node: IdentifierNode) {\n    this.tail = node\n    if (isValid(path[this.pos + 1]) && !node.after) {\n      if (this.stack.length) {\n        for (let i = this.stack.length - 1; i >= 0; i--) {\n          if (!this.stack[i].after || !this.stack[i].filter) {\n            return false\n          }\n        }\n      } else {\n        return false\n      }\n    }\n    let current: any\n    const next = () => {\n      return this.matchNext(node, path)\n    }\n\n    if (isExpandOperator(node.after)) {\n      current = this.recordMatch(\n        () =>\n          node.value === String(path[this.pos]).substring(0, node.value.length)\n      )\n    } else {\n      current = this.recordMatch(() =>\n        isEqual(String(node.value), String(path[this.pos]))\n      )\n    }\n\n    if (this.excluding) {\n      if (node.after) {\n        if (this.pos < path.length) {\n          return current() && next()\n        } else {\n          if (node.after && isWildcardOperator(node.after.after)) {\n            return true\n          }\n          return false\n        }\n      } else {\n        if (this.pos >= path.length) {\n          return true\n        }\n        return current()\n      }\n    }\n\n    return current() && next()\n  }\n\n  matchIgnoreExpression(path: Segments, node: IgnoreExpressionNode) {\n    return (\n      isEqual(node.value, this.currentElement(path)) &&\n      this.matchNext(node, path)\n    )\n  }\n\n  matchDestructorExpression(path: Segments, node: DestructorExpressionNode) {\n    return (\n      isEqual(node.source, this.currentElement(path)) &&\n      this.matchNext(node, path)\n    )\n  }\n\n  matchExpandOperator(path: Segments, node: ExpandOperatorNode) {\n    return this.matchAtom(path, node.after)\n  }\n\n  matchWildcardOperator(path: Segments, node: WildcardOperatorNode) {\n    this.tail = node\n    this.stack.push(node)\n    let matched = false\n    if (node.filter) {\n      if (node.after) {\n        matched =\n          this.matchAtom(path, node.filter) && this.matchAtom(path, node.after)\n      } else {\n        matched = this.matchAtom(path, node.filter)\n      }\n    } else if (node.optional) {\n      matched = true\n    } else {\n      matched = this.matchNext(node, path)\n    }\n    this.stack.pop()\n    return matched\n  }\n\n  matchGroupExpression(path: Segments, node: GroupExpressionNode) {\n    const current = this.pos\n    this.excluding = !!node.isExclude\n    const method = this.excluding ? 'every' : 'some'\n    const result = toArr(node.value)[method]((_node) => {\n      this.pos = current\n      return this.excluding\n        ? !this.matchAtom(path, _node)\n        : this.matchAtom(path, _node)\n    })\n    this.excluding = false\n    return result\n  }\n\n  matchRangeExpression(path: Segments, node: RangeExpressionNode) {\n    if (node.start) {\n      if (node.end) {\n        return (\n          path[this.pos] >= parseInt(node.start.value) &&\n          path[this.pos] <= parseInt(node.end.value)\n        )\n      } else {\n        return path[this.pos] >= parseInt(node.start.value)\n      }\n    } else {\n      if (node.end) {\n        return path[this.pos] <= parseInt(node.end.value)\n      } else {\n        return true\n      }\n    }\n  }\n\n  matchDotOperator(path: Segments, node: DotOperatorNode) {\n    this.pos++\n    return this.matchNext(node, path)\n  }\n\n  matchAtom(path: Segments, node: Node) {\n    if (!node) {\n      if (this.stack.length > 0) return true\n      if (isValid(path[this.pos + 1])) return false\n      if (this.pos == path.length - 1) return true\n    }\n    if (isIdentifier(node)) {\n      return this.matchIdentifier(path, node)\n    } else if (isIgnoreExpression(node)) {\n      return this.matchIgnoreExpression(path, node)\n    } else if (isDestructorExpression(node)) {\n      return this.matchDestructorExpression(path, node)\n    } else if (isExpandOperator(node)) {\n      return this.matchExpandOperator(path, node)\n    } else if (isWildcardOperator(node)) {\n      return this.matchWildcardOperator(path, node)\n    } else if (isGroupExpression(node)) {\n      return this.matchGroupExpression(path, node)\n    } else if (isRangeExpression(node)) {\n      return this.matchRangeExpression(path, node)\n    } else if (isDotOperator(node)) {\n      return this.matchDotOperator(path, node)\n    }\n\n    return true\n  }\n\n  match(path: Segments) {\n    const matched = this.matchAtom(path, this.tree)\n    if (!this.tail) return { matched: false }\n    if (this.tail == this.tree && isWildcardOperator(this.tail)) {\n      return { matched: true }\n    }\n\n    return { matched, record: this.record }\n  }\n\n  static matchSegments(source: Segments, target: Segments, record?: any) {\n    const pos = 0\n    if (source.length !== target.length) return false\n    const match = (pos: number) => {\n      const current = () => {\n        const res = isSegmentEqual(source[pos], target[pos])\n        if (record && record.score !== undefined) {\n          record.score++\n        }\n        return res\n      }\n      const next = () => (pos < source.length - 1 ? match(pos + 1) : true)\n      return current() && next()\n    }\n\n    return { matched: match(pos), record }\n  }\n}\n","import { Parser } from './parser'\nimport { isStr, isArr, isFn, isEqual, isObj, isNum, isRegExp } from './shared'\nimport {\n  getDestructor,\n  getInByDestructor,\n  setInByDestructor,\n  deleteInByDestructor,\n  existInByDestructor,\n} from './destructor'\nimport { Segments, Node, Pattern } from './types'\nimport { Matcher } from './matcher'\n\nconst pathCache = new Map()\n\nconst isMatcher = Symbol('PATH_MATCHER')\n\nconst isValid = (val: any) => val !== undefined && val !== null\n\nconst isAssignable = (val: any) =>\n  typeof val === 'object' || typeof val === 'function'\n\nconst isNumberIndex = (val: any) =>\n  isStr(val) ? /^\\d+$/.test(val) : isNum(val)\n\nconst getIn = (segments: Segments, source: any) => {\n  for (let i = 0; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (!isValid(source)) {\n        if (i !== segments.length - 1) {\n          return source\n        }\n        break\n      }\n      source = source[index]\n    } else {\n      source = getInByDestructor(source, rules, { setIn, getIn })\n      break\n    }\n  }\n  return source\n}\n\nconst setIn = (segments: Segments, source: any, value: any) => {\n  for (let i = 0; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (!isValid(source) || !isAssignable(source)) return\n      if (isArr(source) && !isNumberIndex(index)) {\n        return\n      }\n      if (!isValid(source[index])) {\n        if (value === undefined) {\n          return\n        }\n        if (i < segments.length - 1) {\n          source[index] = isNum(segments[i + 1]) ? [] : {}\n        }\n      }\n      if (i === segments.length - 1) {\n        source[index] = value\n      }\n      source = source[index]\n    } else {\n      setInByDestructor(source, rules, value, { setIn, getIn })\n      break\n    }\n  }\n}\n\nconst deleteIn = (segments: Segments, source: any) => {\n  for (let i = 0; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (i === segments.length - 1 && isValid(source)) {\n        delete source[index]\n        return\n      }\n\n      if (!isValid(source) || !isAssignable(source)) return\n      source = source[index]\n      if (!isObj(source)) {\n        return\n      }\n    } else {\n      deleteInByDestructor(source, rules, {\n        setIn,\n        getIn,\n        deleteIn,\n      })\n      break\n    }\n  }\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\nconst existIn = (segments: Segments, source: any, start: number | Path) => {\n  if (start instanceof Path) {\n    start = start.length\n  }\n  for (let i = start; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (i === segments.length - 1) {\n        return hasOwnProperty.call(source, index)\n      }\n\n      if (!isValid(source) || !isAssignable(source)) return false\n      source = source[index]\n\n      if (!isObj(source)) {\n        return false\n      }\n    } else {\n      return existInByDestructor(source, rules, start, {\n        setIn,\n        getIn,\n        deleteIn,\n        existIn,\n      })\n    }\n  }\n}\n\nconst parse = (pattern: Pattern, base?: Pattern) => {\n  if (pattern instanceof Path) {\n    return {\n      entire: pattern.entire,\n      segments: pattern.segments.slice(),\n      isRegExp: false,\n      isWildMatchPattern: pattern.isWildMatchPattern,\n      isMatchPattern: pattern.isMatchPattern,\n      haveExcludePattern: pattern.haveExcludePattern,\n      tree: pattern.tree,\n    }\n  } else if (isStr(pattern)) {\n    if (!pattern)\n      return {\n        entire: '',\n        segments: [],\n        isRegExp: false,\n        isWildMatchPattern: false,\n        haveExcludePattern: false,\n        isMatchPattern: false,\n      }\n    const parser = new Parser(pattern, Path.parse(base))\n    const tree = parser.parse()\n    if (!parser.isMatchPattern) {\n      const segments = parser.data.segments\n      return {\n        entire: segments.join('.'),\n        segments,\n        tree,\n        isRegExp: false,\n        isWildMatchPattern: false,\n        haveExcludePattern: false,\n        isMatchPattern: false,\n      }\n    } else {\n      return {\n        entire: pattern,\n        segments: [],\n        isRegExp: false,\n        isWildMatchPattern: parser.isWildMatchPattern,\n        haveExcludePattern: parser.haveExcludePattern,\n        isMatchPattern: true,\n        tree,\n      }\n    }\n  } else if (isFn(pattern) && pattern[isMatcher]) {\n    return parse(pattern['path'])\n  } else if (isArr(pattern)) {\n    return {\n      entire: pattern.join('.'),\n      segments: pattern.reduce((buf, key) => {\n        return buf.concat(parseString(key))\n      }, []),\n      isRegExp: false,\n      isWildMatchPattern: false,\n      haveExcludePattern: false,\n      isMatchPattern: false,\n    }\n  } else if (isRegExp(pattern)) {\n    return {\n      entire: pattern,\n      segments: [],\n      isRegExp: true,\n      isWildMatchPattern: false,\n      haveExcludePattern: false,\n      isMatchPattern: true,\n    }\n  } else {\n    return {\n      entire: '',\n      isRegExp: false,\n      segments: pattern !== undefined ? [pattern] : [],\n      isWildMatchPattern: false,\n      haveExcludePattern: false,\n      isMatchPattern: false,\n    }\n  }\n}\n\nconst parseString = (source: any) => {\n  if (isStr(source)) {\n    source = source.replace(/\\s*/g, '')\n    try {\n      const { segments, isMatchPattern } = parse(source)\n      return !isMatchPattern ? segments : source\n    } catch (e) {\n      return source\n    }\n  } else if (source instanceof Path) {\n    return source.segments\n  }\n  return source\n}\n\nexport class Path {\n  public entire: string | RegExp\n  public segments: Segments\n  public isMatchPattern: boolean\n  public isWildMatchPattern: boolean\n  public isRegExp: boolean\n  public haveExcludePattern: boolean\n  public matchScore: number\n  public tree: Node\n  private matchCache: any\n  private includesCache: any\n\n  constructor(input: Pattern, base?: Pattern) {\n    const {\n      tree,\n      segments,\n      entire,\n      isRegExp,\n      isMatchPattern,\n      isWildMatchPattern,\n      haveExcludePattern,\n    } = parse(input, base)\n    this.entire = entire\n    this.segments = segments\n    this.isMatchPattern = isMatchPattern\n    this.isWildMatchPattern = isWildMatchPattern\n    this.isRegExp = isRegExp\n    this.haveExcludePattern = haveExcludePattern\n    this.tree = tree as Node\n    this.matchCache = new Map()\n    this.includesCache = new Map()\n  }\n\n  toString() {\n    return this.entire?.toString()\n  }\n\n  toArr() {\n    return this.segments?.slice()\n  }\n\n  get length() {\n    return this.segments.length\n  }\n\n  concat = (...args: Pattern[]) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be concat`)\n    }\n    const path = new Path('')\n    path.segments = this.segments.concat(...args.map((s) => parseString(s)))\n    path.entire = path.segments.join('.')\n    return path\n  }\n\n  slice = (start?: number, end?: number) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be slice`)\n    }\n    const path = new Path('')\n    path.segments = this.segments.slice(start, end)\n    path.entire = path.segments.join('.')\n    return path\n  }\n\n  push = (...items: Pattern[]) => {\n    return this.concat(...items)\n  }\n\n  pop = () => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be pop`)\n    }\n    return new Path(this.segments.slice(0, this.segments.length - 1))\n  }\n\n  splice = (\n    start: number,\n    deleteCount?: number,\n    ...items: Array<string | number>\n  ) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be splice`)\n    }\n    items = items.reduce((buf, item) => buf.concat(parseString(item)), [])\n    const segments_ = this.segments.slice()\n    segments_.splice(start, deleteCount, ...items)\n    return new Path(segments_)\n  }\n\n  forEach = (callback: (key: string | number) => any) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be each`)\n    }\n    this.segments.forEach(callback)\n  }\n\n  map = (callback: (key: string | number) => any) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be map`)\n    }\n    return this.segments.map(callback)\n  }\n\n  reduce = <T>(\n    callback: (buf: T, item: string | number, index: number) => T,\n    initial: T\n  ): T => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be reduce`)\n    }\n    return this.segments.reduce(callback, initial)\n  }\n\n  parent = () => {\n    return this.slice(0, this.length - 1)\n  }\n\n  includes = (pattern: Pattern) => {\n    const { entire, segments, isMatchPattern } = Path.parse(pattern)\n    const cache = this.includesCache.get(entire)\n    if (cache !== undefined) return cache\n    const cacheWith = (value: boolean): boolean => {\n      this.includesCache.set(entire, value)\n      return value\n    }\n    if (this.isMatchPattern) {\n      if (!isMatchPattern) {\n        return cacheWith(this.match(segments))\n      } else {\n        throw new Error(`${this.entire} cannot be used to match ${entire}`)\n      }\n    }\n    if (isMatchPattern) {\n      throw new Error(`${this.entire} cannot be used to match ${entire}`)\n    }\n    if (segments.length > this.segments.length) return cacheWith(false)\n    for (let i = 0; i < segments.length; i++) {\n      if (!isEqual(String(segments[i]), String(this.segments[i]))) {\n        return cacheWith(false)\n      }\n    }\n    return cacheWith(true)\n  }\n\n  transform = <T>(\n    regexp: string | RegExp,\n    callback: (...args: string[]) => T\n  ): T | string => {\n    if (!isFn(callback)) return ''\n    if (this.isMatchPattern) {\n      throw new Error(`${this.entire} cannot be transformed`)\n    }\n    const args = this.segments.reduce((buf, key) => {\n      return new RegExp(regexp).test(key as string) ? buf.concat(key) : buf\n    }, [])\n    return callback(...args)\n  }\n\n  match = (pattern: Pattern): boolean => {\n    const path = Path.parse(pattern)\n    const cache = this.matchCache.get(path.entire)\n    if (cache !== undefined) {\n      if (cache.record && cache.record.score !== undefined) {\n        this.matchScore = cache.record.score\n      }\n      return cache.matched\n    }\n    const cacheWith = (value: any) => {\n      this.matchCache.set(path.entire, value)\n      return value\n    }\n    if (path.isMatchPattern) {\n      if (this.isMatchPattern) {\n        throw new Error(`${path.entire} cannot match ${this.entire}`)\n      } else {\n        this.matchScore = 0\n        return cacheWith(path.match(this.segments))\n      }\n    } else {\n      if (this.isMatchPattern) {\n        if (this.isRegExp) {\n          try {\n            return this['entire']?.['test']?.(path.entire)\n          } finally {\n            ;(this.entire as RegExp).lastIndex = 0\n          }\n        }\n        const record = {\n          score: 0,\n        }\n        const result = cacheWith(\n          new Matcher(this.tree, record).match(path.segments)\n        )\n        this.matchScore = record.score\n        return result.matched\n      } else {\n        const record = {\n          score: 0,\n        }\n        const result = cacheWith(\n          Matcher.matchSegments(this.segments, path.segments, record)\n        )\n        this.matchScore = record.score\n        return result.matched\n      }\n    }\n  }\n\n  //\n  matchAliasGroup = (name: Pattern, alias: Pattern) => {\n    const namePath = Path.parse(name)\n    const aliasPath = Path.parse(alias)\n    const nameMatched = this.match(namePath)\n    const nameMatchedScore = this.matchScore\n    const aliasMatched = this.match(aliasPath)\n    const aliasMatchedScore = this.matchScore\n    if (this.haveExcludePattern) {\n      if (nameMatchedScore >= aliasMatchedScore) {\n        return nameMatched\n      } else {\n        return aliasMatched\n      }\n    } else {\n      return nameMatched || aliasMatched\n    }\n  }\n\n  existIn = (source?: any, start: number | Path = 0) => {\n    return existIn(this.segments, source, start)\n  }\n\n  getIn = (source?: any) => {\n    return getIn(this.segments, source)\n  }\n\n  setIn = (source?: any, value?: any) => {\n    setIn(this.segments, source, value)\n    return source\n  }\n\n  deleteIn = (source?: any) => {\n    deleteIn(this.segments, source)\n    return source\n  }\n\n  ensureIn = (source?: any, defaults?: any) => {\n    const results = this.getIn(source)\n    if (results === undefined) {\n      this.setIn(source, defaults)\n      return this.getIn(source)\n    }\n    return results\n  }\n\n  static match(pattern: Pattern) {\n    const path = Path.parse(pattern)\n    const matcher = (target) => {\n      return path.match(target)\n    }\n    matcher[isMatcher] = true\n    matcher.path = path\n    return matcher\n  }\n\n  static isPathPattern(target: any): target is Pattern {\n    if (\n      isStr(target) ||\n      isArr(target) ||\n      isRegExp(target) ||\n      (isFn(target) && target[isMatcher])\n    ) {\n      return true\n    }\n    return false\n  }\n\n  static transform<T>(\n    pattern: Pattern,\n    regexp: string | RegExp,\n    callback: (...args: string[]) => T\n  ): any {\n    return Path.parse(pattern).transform(regexp, callback)\n  }\n\n  static parse(path: Pattern = '', base?: Pattern): Path {\n    if (path instanceof Path) {\n      const found = pathCache.get(path.entire)\n      if (found) {\n        return found\n      } else {\n        pathCache.set(path.entire, path)\n        return path\n      }\n    } else if (path && path[isMatcher]) {\n      return Path.parse(path['path'])\n    } else {\n      const key_ = base ? Path.parse(base) : ''\n      const key = `${path}:${key_}`\n      const found = pathCache.get(key)\n      if (found) {\n        return found\n      } else {\n        path = new Path(path, base)\n        pathCache.set(key, path)\n        return path\n      }\n    }\n  }\n\n  static getIn = (source: any, pattern: Pattern) => {\n    const path = Path.parse(pattern)\n    return path.getIn(source)\n  }\n\n  static setIn = (source: any, pattern: Pattern, value: any) => {\n    const path = Path.parse(pattern)\n    return path.setIn(source, value)\n  }\n\n  static deleteIn = (source: any, pattern: Pattern) => {\n    const path = Path.parse(pattern)\n    return path.deleteIn(source)\n  }\n\n  static existIn = (source: any, pattern: Pattern, start?: number | Path) => {\n    const path = Path.parse(pattern)\n    return path.existIn(source, start)\n  }\n\n  static ensureIn = (source: any, pattern: Pattern, defaultValue?: any) => {\n    const path = Path.parse(pattern)\n    return path.ensureIn(source, defaultValue)\n  }\n}\n\nexport { Pattern }\n"],"names":["ContextType","flag","props","bracketContext","bracketArrayContext","bracketDContext","parenContext","braceContext","destructorContext","TokenType","nameTok","expectNext","next","this","includesContext","commaTok","bracketRTok","braceRTok","colonTok","dotTok","eofTok","parenRTok","expandTok","bracketLTok","starTok","parenLTok","dbStarTok","bracketDLTok","braceLTok","expectPrev","prev","bracketDRTok","bangTok","updateContext","state","context","push","pop","ignoreTok","unexpect","curContext","nonASCIIwhitespace","isRewordCode","code","getError","message","err","Error","Object","assign","slice","string","start","end","str","i","ch","charAt","input","type","pos","type_","Tokenizer","length","len","call","loop","charCodeAt","test","String","fromCharCode","finishToken","skipSpace","readToken","getCode","Infinity","codePointAt","fullCharCodeAtPos","match","startPos","prevCode","replace","value","preType","undefined","readKeyWord","readIngoreString","isType","obj","isIdentifier","isIgnoreExpression","isDotOperator","isWildcardOperator","isExpandOperator","isGroupExpression","isRangeExpression","isDestructorExpression","isObjectPattern","isArrayPattern","toString","prototype","isFn","isArr","Array","isArray","isStr","isNum","isObj","val","isRegExp","isNumberLike","t","keyList","keys","hasProp","hasOwnProperty","isEqual","a","b","arrA","arrB","key","DestructorCache","Map","getDestructor","source","get","parseDestructorRules","node","rules","index_1","properties","forEach","child","path","basePath","childRules","k","rule","concat","index_2","elements","setInByDestructor","mutators","_a","setIn","getIn","getInByDestructor","response","deleteInByDestructor","deleteIn","existInByDestructor","every","existIn","calculate","operator","Number","base","_super","_this","__extends","Parser","data","segments","eat","parseAtom","tree","parent","after","parseObjectPattern","parseArrayPattern","parseDestructorExpression","parseIdentifier","parseExpandOperator","parseWildcardOperator","parseIgnoreExpression","parseDotOperator","hasNotInDestructor","isMatchPattern","isWildMatchPattern","pushSegments","isNumberKey","arrayIndex","append","optional","filter","parseGroupExpression","parseRangeExpression","endPos","substring","target","relative","set","parseArrayPatternElements","nodes","parseObjectProperties","toArr","afterNode","segLen","build","dot","createTreeBySegments","isExclude","haveExcludePattern","hasColon","isValid","record","matchAtom","excluding","stack","Matcher","result","score","current","tail","matchNext","recordMatch","currentElement","matched","method","_node","parseInt","matchIdentifier","matchIgnoreExpression","matchDestructorExpression","matchExpandOperator","matchWildcardOperator","matchGroupExpression","matchRangeExpression","matchDotOperator","res","pathCache","isMatcher","Symbol","isAssignable","index","Path","parse","pattern","entire","parser","join","reduce","buf","parseString","e","_i","args","map","s","items","deleteCount","item","segments_","splice","callback","initial","cache","includesCache","cacheWith","regexp","RegExp","matchCache","matchScore","lastIndex","matchSegments","name","alias","namePath","aliasPath","nameMatched","nameMatchedScore","aliasMatched","aliasMatchedScore","defaults","results","matcher","transform","key_","defaultValue","ensureIn"],"mappings":";;;;;;;;;;;;;;;6wBAKA,IAAMA,EAAc,SAACC,EAAcC,GACjC,UACED,QACGC,IAIMC,EAAiBH,EAAY,MAE7BI,EAAsBJ,EAAY,SAElCK,EAAkBL,EAAY,QAE9BM,EAAeN,EAAY,MAE3BO,EAAeP,EAAY,MAE3BQ,EAAoBR,EAAY,OCHvCS,EAAY,SAACR,EAAcC,GAC/B,UACED,QACGC,IAIMQ,EAAUD,EAAU,OAAQ,CACvCE,oBAAWC,GACT,OAAIC,KAAKC,gBAAgBN,GAErBI,IAASF,GACTE,IAASG,GACTH,IAASI,GACTJ,IAASK,GACTL,IAASM,EAIXN,IAASO,GACTP,IAASG,GACTH,IAASQ,GACTR,IAASI,GACTJ,IAASS,GACTT,IAASM,GACTN,IAASU,GACTV,IAASW,KAIFC,EAAUf,EAAU,IAAK,CACpCE,oBAAWC,GACT,OACEA,IAASO,GACTP,IAASa,GACTb,IAASW,GACTX,IAASQ,GACTR,IAASG,GACTH,IAASS,KAIFK,EAAYjB,EAAU,KAAM,CACvCE,oBAAWC,GACT,OACEA,IAASO,GACTP,IAASa,GACTb,IAASW,GACTX,IAASQ,GACTR,IAASG,GACTH,IAASS,KAIFF,EAASV,EAAU,IAAK,CACnCE,oBAAWC,GACT,OACEA,IAASO,GACTP,IAASF,GACTE,IAASe,GACTf,IAASY,GACTZ,IAASc,GACTd,IAASW,GACTX,IAASgB,GACThB,IAASQ,GAGbS,oBAAWC,GACT,OACEA,IAASX,GACTW,IAASpB,GACToB,IAASC,GACTD,IAASN,GACTM,IAAST,GACTS,IAASd,GACTc,IAASR,GACTQ,IAASb,KAIFe,EAAUvB,EAAU,IAAK,CACpCE,oBAAWC,GACT,OAAOA,IAASF,GAAWE,IAASe,KAG3BT,EAAWT,EAAU,IAAK,CACrCE,oBAAWC,GACT,OAAIC,KAAKC,gBAAgBN,GAChBI,IAASF,GAAWE,IAASgB,GAAahB,IAASW,EAErDX,IAASF,GAAWE,IAASe,GAAgBf,IAASI,KAIpDY,EAAYnB,EAAU,IAAK,CACtCE,oBAAWC,GACT,OAAOA,IAASF,GAElBmB,oBAAWC,GACT,OAAI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"}
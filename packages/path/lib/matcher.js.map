{"version":3,"file":"matcher.js","sourceRoot":"","sources":["../src/matcher.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Segments,\n  Node,\n  isIdentifier,\n  isExpandOperator,\n  isWildcardOperator,\n  isGroupExpression,\n  isRangeExpression,\n  isIgnoreExpression,\n  isDotOperator,\n  isDestructorExpression,\n  IdentifierNode,\n  IgnoreExpressionNode,\n  DestructorExpressionNode,\n  ExpandOperatorNode,\n  WildcardOperatorNode,\n  GroupExpressionNode,\n  RangeExpressionNode,\n  DotOperatorNode,\n} from './types'\nimport { isEqual, toArr, isSegmentEqual } from './shared'\n\nconst isValid = (val) => val !== undefined && val !== null && val !== ''\n\nexport class Matcher {\n  private tree: Node\n\n  private pos: number\n\n  private tail: Node\n\n  private stack: any[]\n\n  private excluding: boolean\n\n  private record: any\n\n  constructor(tree: Node, record?: any) {\n    this.tree = tree\n    this.pos = 0\n    this.excluding = false\n    this.record = record\n    this.stack = []\n  }\n\n  currentElement(path: Segments) {\n    return String(path[this.pos] || '').replace(/\\s*/g, '')\n  }\n\n  matchNext = (node: any, path: any) => {\n    return node.after\n      ? this.matchAtom(path, node.after)\n      : isValid(path[this.pos])\n  }\n\n  recordMatch(match: () => boolean) {\n    return () => {\n      const result = match()\n      if (result) {\n        if (this.record && this.record.score !== undefined) {\n          this.record.score++\n        }\n      }\n      return result\n    }\n  }\n\n  matchIdentifier(path: Segments, node: IdentifierNode) {\n    this.tail = node\n    if (isValid(path[this.pos + 1]) && !node.after) {\n      if (this.stack.length) {\n        for (let i = this.stack.length - 1; i >= 0; i--) {\n          if (!this.stack[i].after || !this.stack[i].filter) {\n            return false\n          }\n        }\n      } else {\n        return false\n      }\n    }\n    let current: any\n    const next = () => {\n      return this.matchNext(node, path)\n    }\n\n    if (isExpandOperator(node.after)) {\n      current = this.recordMatch(\n        () =>\n          node.value === String(path[this.pos]).substring(0, node.value.length)\n      )\n    } else {\n      current = this.recordMatch(() =>\n        isEqual(String(node.value), String(path[this.pos]))\n      )\n    }\n\n    if (this.excluding) {\n      if (node.after) {\n        if (this.pos < path.length) {\n          return current() && next()\n        } else {\n          if (node.after && isWildcardOperator(node.after.after)) {\n            return true\n          }\n          return false\n        }\n      } else {\n        if (this.pos >= path.length) {\n          return true\n        }\n        return current()\n      }\n    }\n\n    return current() && next()\n  }\n\n  matchIgnoreExpression(path: Segments, node: IgnoreExpressionNode) {\n    return (\n      isEqual(node.value, this.currentElement(path)) &&\n      this.matchNext(node, path)\n    )\n  }\n\n  matchDestructorExpression(path: Segments, node: DestructorExpressionNode) {\n    return (\n      isEqual(node.source, this.currentElement(path)) &&\n      this.matchNext(node, path)\n    )\n  }\n\n  matchExpandOperator(path: Segments, node: ExpandOperatorNode) {\n    return this.matchAtom(path, node.after)\n  }\n\n  matchWildcardOperator(path: Segments, node: WildcardOperatorNode) {\n    this.tail = node\n    this.stack.push(node)\n    let matched = false\n    if (node.filter) {\n      if (node.after) {\n        matched =\n          this.matchAtom(path, node.filter) && this.matchAtom(path, node.after)\n      } else {\n        matched = this.matchAtom(path, node.filter)\n      }\n    } else if (node.optional) {\n      matched = true\n    } else {\n      matched = this.matchNext(node, path)\n    }\n    this.stack.pop()\n    return matched\n  }\n\n  matchGroupExpression(path: Segments, node: GroupExpressionNode) {\n    const current = this.pos\n    this.excluding = !!node.isExclude\n    const method = this.excluding ? 'every' : 'some'\n    const result = toArr(node.value)[method]((_node) => {\n      this.pos = current\n      return this.excluding\n        ? !this.matchAtom(path, _node)\n        : this.matchAtom(path, _node)\n    })\n    this.excluding = false\n    return result\n  }\n\n  matchRangeExpression(path: Segments, node: RangeExpressionNode) {\n    if (node.start) {\n      if (node.end) {\n        return (\n          path[this.pos] >= parseInt(node.start.value) &&\n          path[this.pos] <= parseInt(node.end.value)\n        )\n      } else {\n        return path[this.pos] >= parseInt(node.start.value)\n      }\n    } else {\n      if (node.end) {\n        return path[this.pos] <= parseInt(node.end.value)\n      } else {\n        return true\n      }\n    }\n  }\n\n  matchDotOperator(path: Segments, node: DotOperatorNode) {\n    this.pos++\n    return this.matchNext(node, path)\n  }\n\n  matchAtom(path: Segments, node: Node) {\n    if (!node) {\n      if (this.stack.length > 0) return true\n      if (isValid(path[this.pos + 1])) return false\n      if (this.pos == path.length - 1) return true\n    }\n    if (isIdentifier(node)) {\n      return this.matchIdentifier(path, node)\n    } else if (isIgnoreExpression(node)) {\n      return this.matchIgnoreExpression(path, node)\n    } else if (isDestructorExpression(node)) {\n      return this.matchDestructorExpression(path, node)\n    } else if (isExpandOperator(node)) {\n      return this.matchExpandOperator(path, node)\n    } else if (isWildcardOperator(node)) {\n      return this.matchWildcardOperator(path, node)\n    } else if (isGroupExpression(node)) {\n      return this.matchGroupExpression(path, node)\n    } else if (isRangeExpression(node)) {\n      return this.matchRangeExpression(path, node)\n    } else if (isDotOperator(node)) {\n      return this.matchDotOperator(path, node)\n    }\n\n    return true\n  }\n\n  match(path: Segments) {\n    const matched = this.matchAtom(path, this.tree)\n    if (!this.tail) return { matched: false }\n    if (this.tail == this.tree && isWildcardOperator(this.tail)) {\n      return { matched: true }\n    }\n\n    return { matched, record: this.record }\n  }\n\n  static matchSegments(source: Segments, target: Segments, record?: any) {\n    const pos = 0\n    if (source.length !== target.length) return false\n    const match = (pos: number) => {\n      const current = () => {\n        const res = isSegmentEqual(source[pos], target[pos])\n        if (record && record.score !== undefined) {\n          record.score++\n        }\n        return res\n      }\n      const next = () => (pos < source.length - 1 ? match(pos + 1) : true)\n      return current() && next()\n    }\n\n    return { matched: match(pos), record }\n  }\n}\n"]}
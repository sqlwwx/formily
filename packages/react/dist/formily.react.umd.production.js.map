{"version":3,"file":"formily.react.umd.production.js","sources":["../../json-schema/esm/shared.js","../../json-schema/esm/compiler.js","../../json-schema/esm/transformer.js","../../json-schema/esm/patches.js","../../json-schema/esm/polyfills/SPECIFICATION_1_0.js","../../json-schema/esm/schema.js","../src/hooks/useAttach.ts","../src/shared/context.ts","../src/hooks/useForm.ts","../src/hooks/useField.ts","../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js","../src/components/FormProvider.tsx","../src/components/FormConsumer.tsx","../src/components/ReactiveField.tsx","../src/components/ArrayField.tsx","../src/components/ObjectField.tsx","../src/components/VoidField.tsx","../src/components/Field.tsx","../src/components/RecursionField.tsx","../src/components/SchemaField.tsx","../src/shared/render.ts","../src/shared/connect.ts","../src/hooks/useFieldSchema.ts","../src/hooks/useFormEffects.ts","../src/hooks/useParentForm.ts"],"sourcesContent":["import { isFn, each, isPlainObj, isArr, toArr, FormPath } from '@formily/shared';\nimport { isObservable, untracked } from '@formily/reactive';\nimport { Schema } from './schema';\nvar REVA_ACTIONS_KEY = Symbol.for('__REVA_ACTIONS');\nexport var SchemaNestedMap = {\n    parent: true,\n    root: true,\n    properties: true,\n    patternProperties: true,\n    additionalProperties: true,\n    items: true,\n    additionalItems: true,\n    'x-linkages': true,\n    'x-reactions': true,\n};\nexport var SchemaStateMap = {\n    title: 'title',\n    description: 'description',\n    default: 'initialValue',\n    enum: 'dataSource',\n    readOnly: 'readOnly',\n    writeOnly: 'editable',\n    'x-content': 'content',\n    'x-data': 'data',\n    'x-value': 'value',\n    'x-editable': 'editable',\n    'x-disabled': 'disabled',\n    'x-read-pretty': 'readPretty',\n    'x-read-only': 'readOnly',\n    'x-visible': 'visible',\n    'x-hidden': 'hidden',\n    'x-display': 'display',\n    'x-pattern': 'pattern',\n    'x-validator': 'validator',\n    'x-decorator': 'decoratorType',\n    'x-component': 'componentType',\n    'x-decorator-props': 'decoratorProps',\n    'x-component-props': 'componentProps',\n};\nexport var SchemaValidatorMap = {\n    required: true,\n    format: true,\n    maxItems: true,\n    minItems: true,\n    maxLength: true,\n    minLength: true,\n    maximum: true,\n    minimum: true,\n    exclusiveMaximum: true,\n    exclusiveMinimum: true,\n    pattern: true,\n    const: true,\n    multipleOf: true,\n    maxProperties: true,\n    minProperties: true,\n    uniqueItems: true,\n};\nexport var SchemaNormalKeys = Object.keys(SchemaStateMap);\nexport var SchemaValidatorKeys = Object.keys(SchemaValidatorMap);\nexport var hasOwnProperty = Object.prototype.hasOwnProperty;\nexport var traverse = function (target, visitor) {\n    var seenObjects = [];\n    var root = target;\n    var traverse = function (target, path) {\n        if (path === void 0) { path = []; }\n        if (isPlainObj(target)) {\n            var seenIndex = seenObjects.indexOf(target);\n            if (seenIndex > -1) {\n                return;\n            }\n            var addIndex = seenObjects.length;\n            seenObjects.push(target);\n            if (isNoNeedCompileObject(target) && root !== target) {\n                visitor(target, path);\n                return;\n            }\n            each(target, function (value, key) {\n                traverse(value, path.concat(key));\n            });\n            seenObjects.splice(addIndex, 1);\n        }\n        else {\n            visitor(target, path);\n        }\n    };\n    traverse(target);\n};\nexport var traverseSchema = function (schema, visitor) {\n    if (schema['x-validator'] !== undefined) {\n        visitor(schema['x-validator'], ['x-validator']);\n    }\n    var seenObjects = [];\n    var root = schema;\n    var traverse = function (target, path) {\n        if (path === void 0) { path = []; }\n        if (path[0] === 'x-validator' ||\n            path[0] === 'version' ||\n            path[0] === '_isJSONSchemaObject')\n            return;\n        if (String(path[0]).indexOf('x-') == -1 && isFn(target))\n            return;\n        if (SchemaNestedMap[path[0]])\n            return;\n        if (isPlainObj(target)) {\n            if (path[0] === 'default' || path[0] === 'x-value') {\n                visitor(target, path);\n                return;\n            }\n            var seenIndex = seenObjects.indexOf(target);\n            if (seenIndex > -1) {\n                return;\n            }\n            var addIndex = seenObjects.length;\n            seenObjects.push(target);\n            if (isNoNeedCompileObject(target) && root !== target) {\n                visitor(target, path);\n                return;\n            }\n            each(target, function (value, key) {\n                traverse(value, path.concat(key));\n            });\n            seenObjects.splice(addIndex, 1);\n        }\n        else {\n            visitor(target, path);\n        }\n    };\n    traverse(schema);\n};\nexport var isNoNeedCompileObject = function (source) {\n    if ('$$typeof' in source && '_owner' in source) {\n        return true;\n    }\n    if (source['_isAMomentObject']) {\n        return true;\n    }\n    if (Schema.isSchemaInstance(source)) {\n        return true;\n    }\n    if (source[REVA_ACTIONS_KEY]) {\n        return true;\n    }\n    if (isFn(source['toJS'])) {\n        return true;\n    }\n    if (isFn(source['toJSON'])) {\n        return true;\n    }\n    if (isObservable(source)) {\n        return true;\n    }\n    return false;\n};\nexport var createDataSource = function (source) {\n    return toArr(source).map(function (item) {\n        if (typeof item === 'object') {\n            return item;\n        }\n        else {\n            return {\n                label: item,\n                value: item,\n            };\n        }\n    });\n};\nexport var patchStateFormSchema = function (targetState, pattern, compiled) {\n    untracked(function () {\n        var _a;\n        var path = FormPath.parse(pattern);\n        var segments = path.segments;\n        var key = segments[0];\n        var isEnum = key === 'enum' && isArr(compiled);\n        var schemaMapKey = SchemaStateMap[key];\n        if (schemaMapKey) {\n            FormPath.setIn(targetState, [schemaMapKey].concat(segments.slice(1)), isEnum ? createDataSource(compiled) : compiled);\n        }\n        else {\n            var isValidatorKey = SchemaValidatorMap[key];\n            if (isValidatorKey) {\n                (_a = targetState['setValidatorRule']) === null || _a === void 0 ? void 0 : _a.call(targetState, key, compiled);\n            }\n        }\n    });\n};\n//# sourceMappingURL=shared.js.map","import { isArr, isFn, isPlainObj, isStr, reduce, FormPath, } from '@formily/shared';\nimport { untracked, hasCollected } from '@formily/reactive';\nimport { traverse, traverseSchema, isNoNeedCompileObject, hasOwnProperty, patchStateFormSchema, } from './shared';\nvar ExpRE = /^\\s*\\{\\{([\\s\\S]*)\\}\\}\\s*$/;\nvar Registry = {\n    silent: false,\n    compile: function (expression, scope) {\n        if (scope === void 0) { scope = {}; }\n        if (Registry.silent) {\n            try {\n                return new Function('$root', \"with($root) { return (\".concat(expression, \"); }\"))(scope);\n            }\n            catch (_a) { }\n        }\n        else {\n            return new Function('$root', \"with($root) { return (\".concat(expression, \"); }\"))(scope);\n        }\n    },\n};\nexport var silent = function (value) {\n    if (value === void 0) { value = true; }\n    Registry.silent = !!value;\n};\nexport var registerCompiler = function (compiler) {\n    if (isFn(compiler)) {\n        Registry.compile = compiler;\n    }\n};\nexport var shallowCompile = function (source, scope) {\n    if (isStr(source)) {\n        var matched = source.match(ExpRE);\n        if (!matched)\n            return source;\n        return Registry.compile(matched[1], scope);\n    }\n    return source;\n};\nexport var compile = function (source, scope) {\n    var seenObjects = [];\n    var compile = function (source) {\n        if (isStr(source)) {\n            return shallowCompile(source, scope);\n        }\n        else if (isArr(source)) {\n            return source.map(function (value) { return compile(value); });\n        }\n        else if (isPlainObj(source)) {\n            if (isNoNeedCompileObject(source))\n                return source;\n            var seenIndex = seenObjects.indexOf(source);\n            if (seenIndex > -1) {\n                return source;\n            }\n            var addIndex = seenObjects.length;\n            seenObjects.push(source);\n            var results = reduce(source, function (buf, value, key) {\n                buf[key] = compile(value);\n                return buf;\n            }, {});\n            seenObjects.splice(addIndex, 1);\n            return results;\n        }\n        return source;\n    };\n    return compile(source);\n};\nexport var patchCompile = function (targetState, sourceState, scope) {\n    traverse(sourceState, function (value, pattern) {\n        var path = FormPath.parse(pattern);\n        var compiled = compile(value, scope);\n        var key = path.segments[0];\n        if (compiled === undefined)\n            return;\n        if (hasOwnProperty.call(targetState, key)) {\n            untracked(function () { return FormPath.setIn(targetState, path, compiled); });\n        }\n    });\n};\nexport var patchSchemaCompile = function (targetState, sourceSchema, scope, demand) {\n    if (demand === void 0) { demand = false; }\n    traverseSchema(sourceSchema, function (value, path) {\n        var compiled = value;\n        var collected = hasCollected(function () {\n            compiled = compile(value, scope);\n        });\n        if (compiled === undefined)\n            return;\n        if (demand) {\n            if (collected || !targetState.initialized) {\n                patchStateFormSchema(targetState, path, compiled);\n            }\n        }\n        else {\n            patchStateFormSchema(targetState, path, compiled);\n        }\n    });\n};\n//# sourceMappingURL=compiler.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n/* istanbul ignore file */\nimport { untracked, autorun, observable } from '@formily/reactive';\nimport { isArr, isStr, toArr, each, isFn, isPlainObj, reduce, } from '@formily/shared';\nimport { onFieldInit, onFieldMount, onFieldUnmount, onFieldValueChange, onFieldInputValueChange, onFieldInitialValueChange, onFieldValidateStart, onFieldValidateEnd, onFieldValidateFailed, onFieldValidateSuccess, } from '@formily/core';\nimport { patchCompile, patchSchemaCompile, shallowCompile } from './compiler';\nvar FieldEffects = {\n    onFieldInit: onFieldInit,\n    onFieldMount: onFieldMount,\n    onFieldUnmount: onFieldUnmount,\n    onFieldValueChange: onFieldValueChange,\n    onFieldInputValueChange: onFieldInputValueChange,\n    onFieldInitialValueChange: onFieldInitialValueChange,\n    onFieldValidateStart: onFieldValidateStart,\n    onFieldValidateEnd: onFieldValidateEnd,\n    onFieldValidateFailed: onFieldValidateFailed,\n    onFieldValidateSuccess: onFieldValidateSuccess,\n};\nvar DefaultFieldEffects = ['onFieldInit', 'onFieldValueChange'];\nvar getDependencyValue = function (field, pattern, property) {\n    var _a = __read(String(pattern).split(/\\s*#\\s*/), 2), target = _a[0], path = _a[1];\n    return field.query(target).getIn(path || property || 'value');\n};\nvar getDependencies = function (field, dependencies) {\n    if (isArr(dependencies)) {\n        var results_1 = [];\n        dependencies.forEach(function (pattern) {\n            if (isStr(pattern)) {\n                results_1.push(getDependencyValue(field, pattern));\n            }\n            else if (isPlainObj(pattern)) {\n                if (pattern.name && pattern.source) {\n                    results_1[pattern.name] = getDependencyValue(field, pattern.source, pattern.property);\n                }\n            }\n        });\n        return results_1;\n    }\n    else if (isPlainObj(dependencies)) {\n        return reduce(dependencies, function (buf, pattern, key) {\n            buf[key] = getDependencyValue(field, pattern);\n            return buf;\n        }, {});\n    }\n    return [];\n};\nvar setSchemaFieldState = function (options, demand) {\n    if (demand === void 0) { demand = false; }\n    var _a = options || {}, request = _a.request, target = _a.target, runner = _a.runner, field = _a.field, scope = _a.scope;\n    if (!request)\n        return;\n    if (target) {\n        if (request.state) {\n            field.form.setFieldState(target, function (state) {\n                return patchCompile(state, request.state, __assign(__assign({}, scope), { $target: state }));\n            });\n        }\n        if (request.schema) {\n            field.form.setFieldState(target, function (state) {\n                return patchSchemaCompile(state, request.schema, __assign(__assign({}, scope), { $target: state }), demand);\n            });\n        }\n        if (isStr(runner) && runner) {\n            field.form.setFieldState(target, function (state) {\n                shallowCompile(\"{{function(){\".concat(runner, \"}}}\"), __assign(__assign({}, scope), { $target: state }))();\n            });\n        }\n    }\n    else {\n        if (request.state) {\n            field.setState(function (state) { return patchCompile(state, request.state, scope); });\n        }\n        if (request.schema) {\n            field.setState(function (state) {\n                return patchSchemaCompile(state, request.schema, scope, demand);\n            });\n        }\n        if (isStr(runner) && runner) {\n            shallowCompile(\"{{function(){\".concat(runner, \"}}}\"), scope)();\n        }\n    }\n};\nvar getBaseScope = function (field, options) {\n    if (options === void 0) { options = {}; }\n    var $observable = function (target, deps) {\n        return autorun.memo(function () { return observable(target); }, deps);\n    };\n    var $props = function (props) { return field.setComponentProps(props); };\n    var $effect = autorun.effect;\n    var $memo = autorun.memo;\n    var $self = field;\n    var $form = field.form;\n    var $values = field.form.values;\n    return __assign(__assign({}, options.scope), { $form: $form, $self: $self, $observable: $observable, $effect: $effect, $memo: $memo, $props: $props, $values: $values });\n};\nvar getBaseReactions = function (schema, options) { return function (field) {\n    setSchemaFieldState({\n        field: field,\n        request: { schema: schema },\n        scope: getBaseScope(field, options),\n    }, true);\n}; };\nvar getUserReactions = function (schema, options) { return function (field) {\n    var reactions = toArr(schema['x-reactions']);\n    var baseScope = getBaseScope(field, options);\n    reactions.forEach(function (unCompiled) {\n        var reaction = shallowCompile(unCompiled, baseScope);\n        if (!reaction)\n            return;\n        if (isFn(reaction)) {\n            return reaction(field);\n        }\n        var when = reaction.when, fulfill = reaction.fulfill, otherwise = reaction.otherwise, target = reaction.target, effects = reaction.effects;\n        var run = function () {\n            var $deps = getDependencies(field, reaction.dependencies);\n            var $dependencies = $deps;\n            var scope = __assign(__assign({}, baseScope), { $target: null, $deps: $deps, $dependencies: $dependencies });\n            var compiledWhen = shallowCompile(when, scope);\n            var condition = when ? compiledWhen : true;\n            var request = condition ? fulfill : otherwise;\n            var runner = condition ? fulfill === null || fulfill === void 0 ? void 0 : fulfill.run : otherwise === null || otherwise === void 0 ? void 0 : otherwise.run;\n            setSchemaFieldState({\n                field: field,\n                target: target,\n                request: request,\n                runner: runner,\n                scope: scope,\n            });\n        };\n        if (target) {\n            reaction.effects = (effects === null || effects === void 0 ? void 0 : effects.length) ? effects : DefaultFieldEffects;\n        }\n        if (reaction.effects) {\n            autorun.memo(function () {\n                untracked(function () {\n                    each(reaction.effects, function (type) {\n                        if (FieldEffects[type]) {\n                            FieldEffects[type](field.address, run);\n                        }\n                    });\n                });\n            }, []);\n        }\n        else {\n            run();\n        }\n    });\n}; };\nexport var transformFieldProps = function (schema, options) {\n    return {\n        name: schema.name,\n        reactions: [\n            getBaseReactions(schema, options),\n            getUserReactions(schema, options),\n        ],\n    };\n};\n//# sourceMappingURL=transformer.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { isFn, isArr } from '@formily/shared';\nvar patches = [];\nvar polyfills = {};\nexport var reducePatches = function (schema) {\n    return patches.reduce(function (buf, patch) {\n        return patch(buf);\n    }, __assign({}, schema));\n};\nexport var registerPatches = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    args.forEach(function (patch) {\n        if (isFn(patch)) {\n            patches.push(patch);\n        }\n    });\n};\nexport var registerPolyfills = function (version, patch) {\n    if (version && isFn(patch)) {\n        polyfills[version] = polyfills[version] || [];\n        polyfills[version].push(patch);\n    }\n};\nexport var enablePolyfills = function (versions) {\n    if (isArr(versions)) {\n        versions.forEach(function (version) {\n            if (isArr(polyfills[version])) {\n                polyfills[version].forEach(function (patch) {\n                    registerPatches(patch);\n                });\n            }\n        });\n    }\n};\n//# sourceMappingURL=patches.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { registerPolyfills } from '../patches';\nimport { toArr, isArr, isStr, lowerCase, isValid } from '@formily/shared';\nvar VOID_COMPONENTS = [\n    'card',\n    'block',\n    'grid-col',\n    'grid-row',\n    'grid',\n    'layout',\n    'step',\n    'tab',\n    'text-box',\n];\nvar TYPE_DEFAULT_COMPONENTS = {};\nvar transformCondition = function (condition) {\n    if (isStr(condition)) {\n        return condition.replace(/\\$value/, '$self.value');\n    }\n};\nvar transformXLinkage = function (linkages) {\n    if (isArr(linkages)) {\n        return linkages.reduce(function (buf, item) {\n            if (!item)\n                return buf;\n            if (item.type === 'value:visible') {\n                return buf.concat({\n                    target: item.target,\n                    when: transformCondition(item.condition),\n                    fulfill: {\n                        state: {\n                            visible: true,\n                        },\n                    },\n                    otherwise: {\n                        state: {\n                            visible: false,\n                        },\n                    },\n                });\n            }\n            else if (item.type === 'value:schema') {\n                return buf.concat({\n                    target: item.target,\n                    when: transformCondition(item.condition),\n                    fulfill: {\n                        schema: SpecificationV1Polyfill(__assign({ version: '1.0' }, item.schema)),\n                    },\n                    otherwise: {\n                        schema: SpecificationV1Polyfill(__assign({ version: '1.0' }, item.otherwise)),\n                    },\n                });\n            }\n            else if (item.type === 'value:state') {\n                return buf.concat({\n                    target: item.target,\n                    when: transformCondition(item.condition),\n                    fulfill: {\n                        state: item.state,\n                    },\n                    otherwise: {\n                        state: item.otherwise,\n                    },\n                });\n            }\n        }, []);\n    }\n    return [];\n};\nvar SpecificationV1Polyfill = function (schema) {\n    if (isValid(schema['editable'])) {\n        schema['x-editable'] = schema['x-editable'] || schema['editable'];\n        delete schema['editable'];\n    }\n    if (isValid(schema['visible'])) {\n        schema['x-visible'] = schema['x-visible'] || schema['visible'];\n        delete schema['visible'];\n    }\n    if (isValid(schema['display'])) {\n        schema['x-display'] =\n            schema['x-display'] || (schema['display'] ? 'visible' : 'hidden');\n        delete schema['display'];\n    }\n    if (isValid(schema['x-props'])) {\n        schema['x-decorator-props'] =\n            schema['x-decorator-props'] || schema['x-props'];\n        delete schema['display'];\n    }\n    if (schema['x-linkages']) {\n        schema['x-reactions'] = toArr(schema['x-reactions']).concat(transformXLinkage(schema['x-linkages']));\n        delete schema['x-linkages'];\n    }\n    if (schema['x-component']) {\n        if (VOID_COMPONENTS.some(function (component) { return lowerCase(component) === lowerCase(schema['x-component']); })) {\n            schema['type'] = 'void';\n        }\n    }\n    else {\n        if (TYPE_DEFAULT_COMPONENTS[schema['type']]) {\n            schema['x-component'] = TYPE_DEFAULT_COMPONENTS[schema['type']];\n        }\n    }\n    if (!schema['x-decorator'] &&\n        schema['type'] !== 'void' &&\n        schema['type'] !== 'object') {\n        schema['x-decorator'] = schema['x-decorator'] || 'FormItem';\n    }\n    if (schema['x-rules']) {\n        schema['x-validator'] = []\n            .concat(schema['x-validator'] || [])\n            .concat(schema['x-rules']);\n    }\n    return schema;\n};\nregisterPolyfills('1.0', SpecificationV1Polyfill);\nexport var registerVoidComponents = function (components) {\n    VOID_COMPONENTS.push.apply(VOID_COMPONENTS, __spreadArray([], __read(components), false));\n};\nexport var registerTypeDefaultComponents = function (maps) {\n    Object.assign(TYPE_DEFAULT_COMPONENTS, maps);\n};\n//# sourceMappingURL=SPECIFICATION_1_0.js.map","import { map, each, isFn, instOf, FormPath, isStr } from '@formily/shared';\nimport { compile, silent, shallowCompile, registerCompiler } from './compiler';\nimport { transformFieldProps } from './transformer';\nimport { reducePatches, registerPatches, registerPolyfills, enablePolyfills, } from './patches';\nimport { registerVoidComponents, registerTypeDefaultComponents, } from './polyfills';\nimport { SchemaNestedMap } from './shared';\nvar Schema = /** @class */ (function () {\n    function Schema(json, parent) {\n        var _this = this;\n        this._isJSONSchemaObject = true;\n        this.version = '2.0';\n        this.addProperty = function (key, schema) {\n            _this.properties = _this.properties || {};\n            _this.properties[key] = new Schema(schema, _this);\n            _this.properties[key].name = key;\n            return _this.properties[key];\n        };\n        this.removeProperty = function (key) {\n            var schema = _this.properties[key];\n            delete _this.properties[key];\n            return schema;\n        };\n        this.setProperties = function (properties) {\n            for (var key in properties) {\n                _this.addProperty(key, properties[key]);\n            }\n            return _this;\n        };\n        this.addPatternProperty = function (key, schema) {\n            if (!schema)\n                return;\n            _this.patternProperties = _this.patternProperties || {};\n            _this.patternProperties[key] = new Schema(schema, _this);\n            _this.patternProperties[key].name = key;\n            return _this.patternProperties[key];\n        };\n        this.removePatternProperty = function (key) {\n            var schema = _this.patternProperties[key];\n            delete _this.patternProperties[key];\n            return schema;\n        };\n        this.setPatternProperties = function (properties) {\n            if (!properties)\n                return _this;\n            for (var key in properties) {\n                _this.addPatternProperty(key, properties[key]);\n            }\n            return _this;\n        };\n        this.setAdditionalProperties = function (properties) {\n            if (!properties)\n                return;\n            _this.additionalProperties = new Schema(properties);\n            return _this.additionalProperties;\n        };\n        this.setItems = function (schema) {\n            if (!schema)\n                return;\n            if (Array.isArray(schema)) {\n                _this.items = schema.map(function (item) { return new Schema(item, _this); });\n            }\n            else {\n                _this.items = new Schema(schema, _this);\n            }\n            return _this.items;\n        };\n        this.setAdditionalItems = function (items) {\n            if (!items)\n                return;\n            _this.additionalItems = new Schema(items, _this);\n            return _this.additionalItems;\n        };\n        this.findDefinitions = function (ref) {\n            if (!ref || !_this.root || !isStr(ref))\n                return;\n            if (ref.indexOf('#/') !== 0)\n                return;\n            return FormPath.getIn(_this.root, ref.substring(2).split('/'));\n        };\n        this.mapProperties = function (callback) {\n            return Schema.getOrderProperties(_this).map(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                return callback(schema, key, index);\n            });\n        };\n        this.mapPatternProperties = function (callback) {\n            return Schema.getOrderProperties(_this, 'patternProperties').map(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                return callback(schema, key, index);\n            });\n        };\n        this.reduceProperties = function (callback, predicate) {\n            var results = predicate;\n            Schema.getOrderProperties(_this, 'properties').forEach(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                results = callback(results, schema, key, index);\n            });\n            return results;\n        };\n        this.reducePatternProperties = function (callback, predicate) {\n            var results = predicate;\n            Schema.getOrderProperties(_this, 'patternProperties').forEach(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                results = callback(results, schema, key, index);\n            });\n            return results;\n        };\n        this.compile = function (scope) {\n            var schema = new Schema({}, _this.parent);\n            each(_this, function (value, key) {\n                if (isFn(value) && !key.includes('x-'))\n                    return;\n                if (key === 'parent' || key === 'root')\n                    return;\n                if (!SchemaNestedMap[key]) {\n                    schema[key] = value ? compile(value, scope) : value;\n                }\n                else {\n                    schema[key] = value ? shallowCompile(value, scope) : value;\n                }\n            });\n            return schema;\n        };\n        this.fromJSON = function (json) {\n            if (!json)\n                return _this;\n            if (Schema.isSchemaInstance(json))\n                return json;\n            each(reducePatches(json), function (value, key) {\n                if (isFn(value) && !key.includes('x-'))\n                    return;\n                if (key === 'properties') {\n                    _this.setProperties(value);\n                }\n                else if (key === 'patternProperties') {\n                    _this.setPatternProperties(value);\n                }\n                else if (key === 'additionalProperties') {\n                    _this.setAdditionalProperties(value);\n                }\n                else if (key === 'items') {\n                    _this.setItems(value);\n                }\n                else if (key === 'additionalItems') {\n                    _this.setAdditionalItems(value);\n                }\n                else if (key === '$ref') {\n                    _this.fromJSON(_this.findDefinitions(value));\n                }\n                else {\n                    _this[key] = value;\n                }\n            });\n            return _this;\n        };\n        this.toJSON = function (recursion) {\n            if (recursion === void 0) { recursion = true; }\n            var results = {};\n            each(_this, function (value, key) {\n                var _a, _b;\n                if ((isFn(value) && !key.includes('x-')) ||\n                    key === 'parent' ||\n                    key === 'root')\n                    return;\n                if (key === 'properties' || key === 'patternProperties') {\n                    if (!recursion)\n                        return;\n                    results[key] = map(value, function (item) { var _a; return (_a = item === null || item === void 0 ? void 0 : item.toJSON) === null || _a === void 0 ? void 0 : _a.call(item); });\n                }\n                else if (key === 'additionalProperties' || key === 'additionalItems') {\n                    if (!recursion)\n                        return;\n                    results[key] = (_a = value === null || value === void 0 ? void 0 : value.toJSON) === null || _a === void 0 ? void 0 : _a.call(value);\n                }\n                else if (key === 'items') {\n                    if (!recursion)\n                        return;\n                    if (Array.isArray(value)) {\n                        results[key] = value.map(function (item) { var _a; return (_a = item === null || item === void 0 ? void 0 : item.toJSON) === null || _a === void 0 ? void 0 : _a.call(item); });\n                    }\n                    else {\n                        results[key] = (_b = value === null || value === void 0 ? void 0 : value.toJSON) === null || _b === void 0 ? void 0 : _b.call(value);\n                    }\n                }\n                else {\n                    results[key] = value;\n                }\n            });\n            return results;\n        };\n        this.toFieldProps = function (options) {\n            return transformFieldProps(_this, options);\n        };\n        if (parent) {\n            this.parent = parent;\n            this.root = parent.root;\n        }\n        else {\n            this.root = this;\n        }\n        return this.fromJSON(json);\n    }\n    Schema.getOrderProperties = function (schema, propertiesName) {\n        if (schema === void 0) { schema = {}; }\n        if (propertiesName === void 0) { propertiesName = 'properties'; }\n        var orderProperties = [];\n        var unorderProperties = [];\n        for (var key in schema[propertiesName]) {\n            var item = schema[propertiesName][key];\n            var index = item['x-index'];\n            if (!isNaN(index)) {\n                orderProperties[index] = { schema: item, key: key };\n            }\n            else {\n                unorderProperties.push({ schema: item, key: key });\n            }\n        }\n        return orderProperties.concat(unorderProperties).filter(function (item) { return !!item; });\n    };\n    Schema.compile = function (expression, scope) {\n        return compile(expression, scope);\n    };\n    Schema.shallowCompile = function (expression, scope) {\n        return shallowCompile(expression, scope);\n    };\n    Schema.isSchemaInstance = function (value) {\n        return instOf(value, Schema);\n    };\n    Schema.registerCompiler = registerCompiler;\n    Schema.registerPatches = registerPatches;\n    Schema.registerVoidComponents = registerVoidComponents;\n    Schema.registerTypeDefaultComponents = registerTypeDefaultComponents;\n    Schema.registerPolyfills = registerPolyfills;\n    Schema.enablePolyfills = enablePolyfills;\n    Schema.silent = silent;\n    return Schema;\n}());\nexport { Schema };\n//# sourceMappingURL=schema.js.map","import { useRef, useEffect } from 'react'\n\ninterface IRecycleTarget {\n  onMount: () => void\n  onUnmount: () => void\n}\n\nexport const useAttach = <T extends IRecycleTarget>(target: T): T => {\n  const oldTargetRef = useRef<IRecycleTarget>(null)\n  useEffect(() => {\n    if (oldTargetRef.current && target !== oldTargetRef.current) {\n      oldTargetRef.current.onUnmount()\n    }\n    oldTargetRef.current = target\n    target.onMount()\n    return () => {\n      target.onUnmount()\n    }\n  }, [target])\n  return target\n}\n","import React, { createContext } from 'react'\nimport { Form, GeneralField } from '@formily/core'\nimport { Schema } from '@formily/json-schema'\nimport { ISchemaFieldReactFactoryOptions } from '../types'\n\nconst createContextCleaner = <T>(...contexts: React.Context<T>[]) => {\n  return ({ children }) => {\n    return contexts.reduce((buf, ctx) => {\n      return React.createElement(ctx.Provider, { value: undefined }, buf)\n    }, children)\n  }\n}\n\nexport const FormContext = createContext<Form>(null)\nexport const FieldContext = createContext<GeneralField>(null)\nexport const SchemaMarkupContext = createContext<Schema>(null)\nexport const SchemaContext = createContext<Schema>(null)\nexport const SchemaExpressionScopeContext = createContext<any>(null)\nexport const SchemaOptionsContext =\n  createContext<ISchemaFieldReactFactoryOptions>(null)\n\nexport const ContextCleaner = createContextCleaner(\n  FieldContext,\n  SchemaMarkupContext,\n  SchemaContext,\n  SchemaExpressionScopeContext,\n  SchemaOptionsContext\n)\n","import { useContext } from 'react'\nimport { Form } from '@formily/core'\nimport { FormContext } from '../shared'\n\nexport const useForm = <T extends object = any>(): Form<T> => {\n  return useContext(FormContext)\n}\n","import { useContext } from 'react'\nimport { GeneralField } from '@formily/core'\nimport { FieldContext } from '../shared'\n\nexport const useField = <T = GeneralField>(): T => {\n  return useContext(FieldContext) as any\n}\n","'use strict';\n\nvar reactIs = require('react-is');\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  '$$typeof': true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  '$$typeof': true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\n\nfunction getStatics(component) {\n  // React v16.11 and below\n  if (reactIs.isMemo(component)) {\n    return MEMO_STATICS;\n  } // React v16.12 and above\n\n\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;\n}\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    var keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return targetComponent;\n}\n\nmodule.exports = hoistNonReactStatics;\n","import React from 'react'\nimport { useAttach } from '../hooks/useAttach'\nimport { FormContext, ContextCleaner } from '../shared'\nimport { IProviderProps } from '../types'\n\nexport const FormProvider: React.FC<IProviderProps> = (props) => {\n  const form = useAttach(props.form)\n  return (\n    <ContextCleaner>\n      <FormContext.Provider value={form}>{props.children}</FormContext.Provider>\n    </ContextCleaner>\n  )\n}\n\nFormProvider.displayName = 'FormProvider'\n","import React, { Fragment } from 'react'\nimport { isFn } from '@formily/shared'\nimport { observer } from '@formily/reactive-react'\nimport { useForm } from '../hooks'\nimport { IFormSpyProps } from '../types'\n\nexport const FormConsumer: React.FC<IFormSpyProps> = observer((props) => {\n  const children = isFn(props.children) ? props.children(useForm()) : null\n  return <Fragment>{children}</Fragment>\n})\n\nFormConsumer.displayName = 'FormConsumer'\n","import React, { Fragment, useContext } from 'react'\nimport { toJS } from '@formily/reactive'\nimport { observer } from '@formily/reactive-react'\nimport { isFn, FormPath } from '@formily/shared'\nimport { isVoidField, GeneralField, Form } from '@formily/core'\nimport { SchemaOptionsContext } from '../shared'\ninterface IReactiveFieldProps {\n  field: GeneralField\n  children?:\n    | ((field: GeneralField, form: Form) => React.ReactChild)\n    | React.ReactNode\n}\n\nconst mergeChildren = (children: React.ReactNode, content: React.ReactNode) => {\n  if (!children && !content) return\n  return (\n    <Fragment>\n      {children}\n      {content}\n    </Fragment>\n  )\n}\n\nconst renderChildren = (children: React.ReactNode, ...args: any[]) =>\n  isFn(children) ? children(...args) : children\n\nconst ReactiveInternal: React.FC<IReactiveFieldProps> = (props) => {\n  const options = useContext(SchemaOptionsContext)\n  if (!props.field) {\n    return <Fragment>{renderChildren(props.children)}</Fragment>\n  }\n  const field = props.field\n  const content = mergeChildren(\n    renderChildren(props.children, field, field.form),\n    field.content ?? field.component[1].children\n  )\n  if (field.display !== 'visible') return null\n\n  const renderDecorator = (children: React.ReactNode) => {\n    if (!field.decorator[0]) {\n      return <Fragment>{children}</Fragment>\n    }\n    const finalComponent =\n      FormPath.getIn(options?.components, field.decorator[0]) ??\n      field.decorator[0]\n\n    return React.createElement(\n      finalComponent,\n      toJS(field.decorator[1]),\n      children\n    )\n  }\n\n  const renderComponent = () => {\n    if (!field.component[0]) return content\n    const value = !isVoidField(field) ? field.value : undefined\n    const onChange = !isVoidField(field)\n      ? (...args: any[]) => {\n          field.onInput(...args)\n          field.component[1]?.onChange?.(...args)\n        }\n      : field.component[1]?.onChange\n    const onFocus = !isVoidField(field)\n      ? (...args: any[]) => {\n          field.onFocus(...args)\n          field.component[1]?.onFocus?.(...args)\n        }\n      : field.component[1]?.onFocus\n    const onBlur = !isVoidField(field)\n      ? (...args: any[]) => {\n          field.onBlur(...args)\n          field.component[1]?.onBlur?.(...args)\n        }\n      : field.component[1]?.onBlur\n    const disabled = !isVoidField(field)\n      ? field.pattern === 'disabled' || field.pattern === 'readPretty'\n      : undefined\n    const readOnly = !isVoidField(field)\n      ? field.pattern === 'readOnly'\n      : undefined\n    const finalComponent =\n      FormPath.getIn(options?.components, field.component[0]) ??\n      field.component[0]\n    return React.createElement(\n      finalComponent,\n      {\n        disabled,\n        readOnly,\n        ...toJS(field.component[1]),\n        value,\n        onChange,\n        onFocus,\n        onBlur,\n      },\n      content\n    )\n  }\n\n  return renderDecorator(renderComponent())\n}\n\nReactiveInternal.displayName = 'ReactiveField'\n\nexport const ReactiveField = observer(ReactiveInternal, {\n  forwardRef: true,\n})\n","import React from 'react'\nimport { ArrayField as ArrayFieldType } from '@formily/core'\nimport { useForm, useField } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport { FieldContext } from '../shared'\nimport { JSXComponent, IFieldProps } from '../types'\nimport { ReactiveField } from './ReactiveField'\n\nexport const ArrayField = <D extends JSXComponent, C extends JSXComponent>(\n  props: IFieldProps<D, C, ArrayFieldType>\n) => {\n  const form = useForm()\n  const parent = useField()\n  const field = useAttach(\n    form.createArrayField({\n      basePath: parent?.address,\n      ...props,\n    })\n  )\n  return (\n    <FieldContext.Provider value={field}>\n      <ReactiveField field={field}>{props.children}</ReactiveField>\n    </FieldContext.Provider>\n  )\n}\n\nArrayField.displayName = 'ArrayField'\n","import React from 'react'\nimport { ObjectField as ObjectFieldType } from '@formily/core'\nimport { useForm, useField } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport { ReactiveField } from './ReactiveField'\nimport { FieldContext } from '../shared'\nimport { JSXComponent, IFieldProps } from '../types'\n\nexport const ObjectField = <D extends JSXComponent, C extends JSXComponent>(\n  props: IFieldProps<D, C, ObjectFieldType>\n) => {\n  const form = useForm()\n  const parent = useField()\n  const field = useAttach(\n    form.createObjectField({ basePath: parent?.address, ...props })\n  )\n  return (\n    <FieldContext.Provider value={field}>\n      <ReactiveField field={field}>{props.children}</ReactiveField>\n    </FieldContext.Provider>\n  )\n}\n\nObjectField.displayName = 'ObjectField'\n","import React from 'react'\nimport { useForm, useField } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport { ReactiveField } from './ReactiveField'\nimport { FieldContext } from '../shared'\nimport { JSXComponent, IVoidFieldProps } from '../types'\n\nexport const VoidField = <D extends JSXComponent, C extends JSXComponent>(\n  props: IVoidFieldProps<D, C>\n) => {\n  const form = useForm()\n  const parent = useField()\n  const field = useAttach(\n    form.createVoidField({ basePath: parent?.address, ...props })\n  )\n  return (\n    <FieldContext.Provider value={field}>\n      <ReactiveField field={field}>{props.children}</ReactiveField>\n    </FieldContext.Provider>\n  )\n}\n\nVoidField.displayName = 'VoidField'\n","import React from 'react'\nimport { useField, useForm } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport { ReactiveField } from './ReactiveField'\nimport { FieldContext } from '../shared'\nimport { JSXComponent, IFieldProps } from '../types'\n\nexport const Field = <D extends JSXComponent, C extends JSXComponent>(\n  props: IFieldProps<D, C>\n) => {\n  const form = useForm()\n  const parent = useField()\n  const field = useAttach(\n    form.createField({ basePath: parent?.address, ...props })\n  )\n  return (\n    <FieldContext.Provider value={field}>\n      <ReactiveField field={field}>{props.children}</ReactiveField>\n    </FieldContext.Provider>\n  )\n}\n\nField.displayName = 'Field'\n","import React, { Fragment, useContext, useRef, useMemo } from 'react'\nimport { isFn, isValid } from '@formily/shared'\nimport { GeneralField } from '@formily/core'\nimport { Schema } from '@formily/json-schema'\nimport {\n  SchemaContext,\n  SchemaOptionsContext,\n  SchemaExpressionScopeContext,\n} from '../shared'\nimport { IRecursionFieldProps } from '../types'\nimport { useField } from '../hooks'\nimport { ObjectField } from './ObjectField'\nimport { ArrayField } from './ArrayField'\nimport { Field } from './Field'\nimport { VoidField } from './VoidField'\n\nconst useFieldProps = (schema: Schema) => {\n  const options = useContext(SchemaOptionsContext)\n  const scope = useContext(SchemaExpressionScopeContext)\n  const scopeRef = useRef<any>()\n  scopeRef.current = scope\n  return schema.toFieldProps({\n    ...options,\n    get scope() {\n      return {\n        ...options.scope,\n        ...scopeRef.current,\n      }\n    },\n  }) as any\n}\n\nconst useBasePath = (props: IRecursionFieldProps) => {\n  const parent = useField()\n  if (props.onlyRenderProperties) {\n    return props.basePath || parent?.address.concat(props.name)\n  }\n  return props.basePath || parent?.address\n}\n\nexport const RecursionField: React.FC<IRecursionFieldProps> = (props) => {\n  const basePath = useBasePath(props)\n  const fieldSchema = useMemo(() => new Schema(props.schema), [props.schema])\n  const fieldProps = useFieldProps(fieldSchema)\n  const renderProperties = (field?: GeneralField) => {\n    if (props.onlyRenderSelf) return\n    const properties = Schema.getOrderProperties(fieldSchema)\n    if (!properties.length) return\n    return (\n      <Fragment>\n        {properties.map(({ schema: item, key: name }, index) => {\n          const base = field?.address || basePath\n          let schema: Schema = item\n          if (isFn(props.mapProperties)) {\n            const mapped = props.mapProperties(item, name)\n            if (mapped) {\n              schema = mapped\n            }\n          }\n          if (isFn(props.filterProperties)) {\n            if (props.filterProperties(schema, name) === false) {\n              return null\n            }\n          }\n          return (\n            <RecursionField\n              schema={schema}\n              key={`${index}-${name}`}\n              name={name}\n              basePath={base}\n            />\n          )\n        })}\n      </Fragment>\n    )\n  }\n\n  const render = () => {\n    if (!isValid(props.name)) return renderProperties()\n    if (fieldSchema.type === 'object') {\n      if (props.onlyRenderProperties) return renderProperties()\n      return (\n        <ObjectField {...fieldProps} name={props.name} basePath={basePath}>\n          {renderProperties}\n        </ObjectField>\n      )\n    } else if (fieldSchema.type === 'array') {\n      return (\n        <ArrayField {...fieldProps} name={props.name} basePath={basePath} />\n      )\n    } else if (fieldSchema.type === 'void') {\n      if (props.onlyRenderProperties) return renderProperties()\n      return (\n        <VoidField {...fieldProps} name={props.name} basePath={basePath}>\n          {renderProperties}\n        </VoidField>\n      )\n    }\n    return <Field {...fieldProps} name={props.name} basePath={basePath} />\n  }\n\n  if (!fieldSchema) return <Fragment />\n\n  return (\n    <SchemaContext.Provider value={fieldSchema}>\n      {render()}\n    </SchemaContext.Provider>\n  )\n}\n","import React, { useContext, Fragment } from 'react'\nimport { ISchema, Schema } from '@formily/json-schema'\nimport { RecursionField } from '.'\nimport { render } from '../shared/render'\nimport {\n  SchemaMarkupContext,\n  SchemaExpressionScopeContext,\n  SchemaOptionsContext,\n} from '../shared'\nimport {\n  ReactComponentPath,\n  JSXComponent,\n  ISchemaFieldReactFactoryOptions,\n  SchemaReactComponents,\n  ISchemaFieldProps,\n  ISchemaMarkupFieldProps,\n  ISchemaTypeFieldProps,\n} from '../types'\nconst env = {\n  nonameId: 0,\n}\n\nconst getRandomName = () => {\n  return `NO_NAME_FIELD_$${env.nonameId++}`\n}\n\nexport function createSchemaField<Components extends SchemaReactComponents>(\n  options: ISchemaFieldReactFactoryOptions<Components> = {}\n) {\n  function SchemaField<\n    Decorator extends JSXComponent,\n    Component extends JSXComponent\n  >(props: ISchemaFieldProps<Decorator, Component>) {\n    const schema = Schema.isSchemaInstance(props.schema)\n      ? props.schema\n      : new Schema({\n          type: 'object',\n          ...props.schema,\n        })\n    const renderMarkup = () => {\n      env.nonameId = 0\n      if (props.schema) return null\n      return render(\n        <SchemaMarkupContext.Provider value={schema}>\n          {props.children}\n        </SchemaMarkupContext.Provider>\n      )\n    }\n\n    const renderChildren = () => {\n      return <RecursionField {...props} schema={schema} />\n    }\n\n    return (\n      <SchemaOptionsContext.Provider\n        value={{\n          ...options,\n          components: {\n            ...options.components,\n            ...props.components,\n          },\n        }}\n      >\n        <SchemaExpressionScopeContext.Provider\n          value={{\n            ...options.scope,\n            ...props.scope,\n          }}\n        >\n          {renderMarkup()}\n          {renderChildren()}\n        </SchemaExpressionScopeContext.Provider>\n      </SchemaOptionsContext.Provider>\n    )\n  }\n\n  SchemaField.displayName = 'SchemaField'\n\n  function MarkupField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaMarkupFieldProps<Components, Component, Decorator>) {\n    const parent = useContext(SchemaMarkupContext)\n    if (!parent) return <Fragment />\n    const renderChildren = () => {\n      return <React.Fragment>{props.children}</React.Fragment>\n    }\n    const appendArraySchema = (schema: ISchema) => {\n      if (parent.items) {\n        return parent.addProperty(name, schema)\n      } else {\n        return parent.setItems(props)\n      }\n    }\n    const name = props.name || getRandomName()\n    if (parent.type === 'object' || parent.type === 'void') {\n      const schema = parent.addProperty(name, props)\n      return (\n        <SchemaMarkupContext.Provider value={schema}>\n          {renderChildren()}\n        </SchemaMarkupContext.Provider>\n      )\n    } else if (parent.type === 'array') {\n      const schema = appendArraySchema(props)\n      return (\n        <SchemaMarkupContext.Provider\n          value={Array.isArray(schema) ? schema[0] : schema}\n        >\n          {props.children}\n        </SchemaMarkupContext.Provider>\n      )\n    } else {\n      return renderChildren()\n    }\n  }\n\n  MarkupField.displayName = 'MarkupField'\n\n  function StringField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"string\" />\n  }\n\n  StringField.displayName = 'StringField'\n\n  function ObjectField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"object\" />\n  }\n\n  ObjectField.displayName = 'ObjectField'\n\n  function ArrayField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"array\" />\n  }\n\n  ArrayField.displayName = 'ArrayField'\n  function BooleanField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"boolean\" />\n  }\n\n  BooleanField.displayName = 'BooleanField'\n\n  function NumberField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"number\" />\n  }\n\n  NumberField.displayName = 'NumberField'\n\n  function DateField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"date\" />\n  }\n\n  DateField.displayName = 'DateField'\n\n  function DateTimeField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"datetime\" />\n  }\n\n  DateTimeField.displayName = 'DateTimeField'\n\n  function VoidField<\n    Decorator extends ReactComponentPath<Components>,\n    Component extends ReactComponentPath<Components>\n  >(props: ISchemaTypeFieldProps<Components, Component, Decorator>) {\n    return <MarkupField {...props} type=\"void\" />\n  }\n\n  VoidField.displayName = 'VoidField'\n\n  SchemaField.Markup = MarkupField\n  SchemaField.String = StringField\n  SchemaField.Object = ObjectField\n  SchemaField.Array = ArrayField\n  SchemaField.Boolean = BooleanField\n  SchemaField.Date = DateField\n  SchemaField.DateTime = DateTimeField\n  SchemaField.Void = VoidField\n  SchemaField.Number = NumberField\n\n  return SchemaField\n}\n","import React from 'react'\nimport { createPortal } from 'react-dom'\nimport { globalThisPolyfill } from '@formily/shared'\n\nconst env = {\n  portalDOM: null,\n}\n\nexport const render = (element: React.ReactElement) => {\n  if (globalThisPolyfill['document']) {\n    env.portalDOM =\n      env.portalDOM || globalThisPolyfill['document'].createElement('div')\n    return createPortal(element, env.portalDOM)\n  } else {\n    return React.createElement('template', {}, element)\n  }\n}\n","import React from 'react'\nimport { isFn, isStr, FormPath, each, isValid } from '@formily/shared'\nimport { isVoidField } from '@formily/core'\nimport { observer, Observer } from '@formily/reactive-react'\nimport { JSXComponent, IComponentMapper, IStateMapper } from '../types'\nimport { useField } from '../hooks'\nimport hoistNonReactStatics from 'hoist-non-react-statics'\n\nexport function mapProps<T extends JSXComponent>(\n  ...args: IStateMapper<React.ComponentProps<T>>[]\n) {\n  return (target: T) => {\n    return observer(\n      (props: any) => {\n        const field = useField()\n        const results = args.reduce(\n          (props, mapper) => {\n            if (isFn(mapper)) {\n              props = Object.assign(props, mapper(props, field))\n            } else {\n              each(mapper, (to, extract) => {\n                const extractValue = FormPath.getIn(field, extract)\n                const targetValue = isStr(to) ? to : (extract as any)\n                const originalValue = FormPath.getIn(props, targetValue)\n                if (extract === 'value') {\n                  if (to !== extract) {\n                    delete props.value\n                  }\n                }\n                if (isValid(originalValue) && !isValid(extractValue)) return\n                FormPath.setIn(props, targetValue, extractValue)\n              })\n            }\n            return props\n          },\n          { ...props }\n        )\n        return React.createElement(target, results)\n      },\n      {\n        forwardRef: true,\n      }\n    )\n  }\n}\n\nexport function mapReadPretty<T extends JSXComponent, C extends JSXComponent>(\n  component: C,\n  readPrettyProps?: React.ComponentProps<C>\n) {\n  return (target: T) => {\n    return observer(\n      (props) => {\n        const field = useField()\n        if (!isVoidField(field) && field?.pattern === 'readPretty') {\n          return React.createElement(component, {\n            ...readPrettyProps,\n            ...props,\n          })\n        }\n        return React.createElement(target, props)\n      },\n      {\n        forwardRef: true,\n      }\n    )\n  }\n}\n\nexport function connect<T extends JSXComponent>(\n  target: T,\n  ...args: IComponentMapper<T>[]\n) {\n  const Target = args.reduce((target, mapper) => {\n    return mapper(target)\n  }, target)\n\n  const Destination = React.forwardRef(\n    (props: Partial<React.ComponentProps<T>>, ref) => {\n      return React.createElement(Target, { ...props, ref })\n    }\n  )\n\n  if (target) hoistNonReactStatics(Destination, target as any)\n\n  return Destination\n}\n\nexport { observer, Observer }\n","import { useContext } from 'react'\nimport { SchemaContext } from '../shared'\nimport { Schema } from '@formily/json-schema'\n\nexport const useFieldSchema = (): Schema => {\n  return useContext(SchemaContext)\n}\n","import { useLayoutEffect, useMemo } from 'react'\nimport { Form } from '@formily/core'\nimport { uid } from '@formily/shared'\nimport { useForm } from './useForm'\n\nexport const useFormEffects = (effects?: (form: Form) => void) => {\n  const form = useForm()\n  const ref = useMemo(() => {\n    const id = uid()\n    form.addEffects(id, effects)\n    const request = setTimeout(() => {\n      form.removeEffects(id)\n    }, 100)\n    return { id, request }\n  }, [])\n  useLayoutEffect(() => {\n    clearTimeout(ref.request)\n    return () => {\n      form.removeEffects(ref.id)\n    }\n  }, [])\n}\n","import { isObjectField, GeneralField, Form, ObjectField } from '@formily/core'\nimport { useField } from './useField'\nimport { useForm } from './useForm'\n\nexport const useParentForm = (): Form | ObjectField => {\n  const field = useField()\n  const form = useForm()\n  const findObjectParent = (field: GeneralField) => {\n    if (!field) return form\n    if (isObjectField(field)) return field\n    return findObjectParent(field?.parent)\n  }\n  return findObjectParent(field)\n}\n"],"names":["Formily","registerPolyfills","React","REACT_STATICS","childContextTypes","contextType","contextTypes","defaultProps","displayName","getDefaultProps","getDerivedStateFromError","getDerivedStateFromProps","mixins","propTypes","type","KNOWN_STATICS","name","length","prototype","caller","callee","arguments","arity","MEMO_STATICS","$$typeof","compare","TYPE_STATICS","getStatics","component","reactIs","isMemo","ForwardRef","render","Memo","defineProperty","Object","getOwnPropertyNames","getOwnPropertySymbols","getOwnPropertyDescriptor","getPrototypeOf","objectPrototype","hoistNonReactStatics","targetComponent","sourceComponent","blacklist","inheritedComponent","keys","concat","targetStatics","sourceStatics","i","key","descriptor","e","FormProvider","FormConsumer","ReactiveInternal","ArrayField","ObjectField","VoidField","Field","ReactDOM"],"mappings":"ofAGA,ijCA2IQA,gCAGAA,iCAGAA,yDAmBJA,iDAEeA,+DAGoBA,iCAG3BA,8DArBDA,qeClIHA,0DAKAA,2HAWIA,yCAGKA,oEAGAA,0GASSA,oMDUdA,mHAWAA,iHCROA,mFAMPA,8CAA+BA,2TDyBQA,oCAIvCA,4KAeAA,qHCpCYA,gmBCjDPA,sCACCA,yCACEA,+CACIA,wDACKA,+DACEA,4DACLA,qDACFA,sDACGA,0DACCA,geA8ChBA,yPAeAA,+GAWMA,kCACFA,oIAJDA,iDAAkCA,oPAkB7BA,6FAMRA,qIArFJA,gEAGQA,uCAGKA,iGAQRA,6BACEA,kUA8FHA,0CACIA,uCACIA,iZCxIRA,yDAMOA,oEAMXA,gDAEQA,q1BCYRA,8FAsDAA,oGAIAA,+FAIAA,oHAKAA,wJAMwBA,iEApExBA,gkBAwEuDA,8BAAyBA,sSAqBxFC,ovCC5EwCD,oDAIrBA,6sBAgCPA,qCACQA,yKAkBRA,wFACQA,gYA6BRA,kDAESA,oIAOcA,4hCA2DpBA,gNC1NQE,0BACrBA,iJCIyBA,4BACCA,4BACOA,4BACNA,4BACeA,4BAE1CA,g0BCdOA,yCCAAA,sCCGT,IAAIC,GAAgB,CAClBC,mBAAmB,EACnBC,aAAa,EACbC,cAAc,EACdC,cAAc,EACdC,aAAa,EACbC,iBAAiB,EACjBC,0BAA0B,EAC1BC,0BAA0B,EAC1BC,QAAQ,EACRC,WAAW,EACXC,MAAM,GAEJC,GAAgB,CAClBC,MAAM,EACNC,QAAQ,EACRC,WAAW,EACXC,QAAQ,EACRC,QAAQ,EACRC,WAAW,EACXC,OAAO,GASLC,GAAe,CACjBC,UAAY,EACZC,SAAS,EACTlB,cAAc,EACdC,aAAa,EACbK,WAAW,EACXC,MAAM,GAEJY,GAAe,GAInB,SAASC,GAAWC,GAElB,OAAIC,GAAQC,OAAOF,GACVL,GAIFG,GAAaE,EAAoB,WAAMzB,GAVhDuB,GAAaG,GAAQE,YAhBK,CACxBP,UAAY,EACZQ,QAAQ,EACRzB,cAAc,EACdC,aAAa,EACbK,WAAW,GAYba,GAAaG,GAAQI,MAAQV,GAY7B,IAAIW,GAAiBC,OAAOD,eACxBE,GAAsBD,OAAOC,oBAC7BC,GAAwBF,OAAOE,sBAC/BC,GAA2BH,OAAOG,yBAClCC,GAAiBJ,OAAOI,eACxBC,GAAkBL,OAAOjB,UAsC7B,OArCA,SAASuB,EAAqBC,EAAiBC,EAAiBC,GAC9D,GAA+B,iBAApBD,EAA8B,CAEvC,GAAIH,GAAiB,CACnB,IAAIK,EAAqBN,GAAeI,GAEpCE,GAAsBA,IAAuBL,IAC/CC,EAAqBC,EAAiBG,EAAoBD,GAI9D,IAAIE,EAAOV,GAAoBO,GAE3BN,KACFS,EAAOA,EAAKC,OAAOV,GAAsBM,KAM3C,IAHA,IAAIK,EAAgBrB,GAAWe,GAC3BO,EAAgBtB,GAAWgB,GAEtBO,EAAI,EAAGA,EAAIJ,EAAK7B,SAAUiC,EAAG,CACpC,IAAIC,EAAML,EAAKI,GAEf,KAAKnC,GAAcoC,IAAUP,GAAaA,EAAUO,IAAWF,GAAiBA,EAAcE,IAAWH,GAAiBA,EAAcG,IAAO,CAC7I,IAAIC,EAAad,GAAyBK,EAAiBQ,GAE3D,IAEEjB,GAAeQ,EAAiBS,EAAKC,GACrC,MAAOC,OAKf,OAAOX,yMCrFTY,qCCRqDtD,kDAClCA,gFACTE,0BAGVqD,8BCEA,sFAWEvD,4EAGgBE,2DAENA,qGAbPA,0NAwBSA,uCAGRF,qIAKAA,mGAOaA,6CACGA,0SAMDA,wSAMDA,qSAMEA,sFAGAA,sEAIhBA,iKAOKA,wFAaXwD,sCAE6BxD,mPC7E7ByD,iOCHAC,gOCDAC,0NCAAC,uBCNA,wLA0BsB1D,qCAAkBF,2DAzBtBE,sBACFA,uBACGA,iJA2BIF,uFAGhBE,uGAIOF,iFAMAA,uNAmBLA,yYAuBmBE,goBCpETF,kEAEPA,qTC1BNA,uEAEiBA,gEACZ6D,+IDsEQ3D,qDACMA,y9CEvEdF,uFAKKA,iDAGFA,2CACuBA,qCACDA,8BACEA,sEAMlBA,4BAA2BA,2BAC/BA,kKAqBLA,6DAGEA,uNCjDJE,0ECEKA,gCACCF,2HAObE,4KCNMF"}
{"version":3,"file":"formily.reactive-react.umd.production.js","sources":["../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js","../src/shared/global.ts","../src/shared/gc.ts","../src/hooks/useDidUpdate.ts","../src/shared/immediate.ts","../src/hooks/useObserver.ts","../src/hooks/useForceUpdate.ts","../src/observer.ts"],"sourcesContent":["'use strict';\n\nvar reactIs = require('react-is');\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  '$$typeof': true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  '$$typeof': true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\n\nfunction getStatics(component) {\n  // React v16.11 and below\n  if (reactIs.isMemo(component)) {\n    return MEMO_STATICS;\n  } // React v16.12 and above\n\n\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;\n}\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    var keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return targetComponent;\n}\n\nmodule.exports = hoistNonReactStatics;\n","/* istanbul ignore next */\nfunction globalSelf() {\n  try {\n    if (typeof self !== 'undefined') {\n      return self\n    }\n  } catch (e) {}\n  try {\n    if (typeof window !== 'undefined') {\n      return window\n    }\n  } catch (e) {}\n  try {\n    if (typeof global !== 'undefined') {\n      return global\n    }\n  } catch (e) {}\n  return Function('return this')()\n}\n\nexport const globalThisPolyfill: Window = globalSelf()\n","import { globalThisPolyfill } from './global'\n\nconst registry: FinalizationRegistry<any> =\n  globalThisPolyfill['FinalizationRegistry'] &&\n  new globalThisPolyfill['FinalizationRegistry']((token: any) =>\n    token?.clean?.()\n  )\n\ntype Token = { clean: () => void }\nexport class GarbageCollector<T extends object = any> {\n  private expireTime: number\n  private request?: ReturnType<typeof setTimeout>;\n  private token: Token\n  constructor(clean?: () => void, expireTime = 10_000) {\n    this.token = {\n      clean,\n    }\n    this.expireTime = expireTime\n  }\n\n  open(target: T) {\n    if (registry) {\n      registry.register(target, this.token, this.token)\n    } else {\n      this.request = setTimeout(() => {\n        this.token?.clean?.()\n      }, this.expireTime)\n    }\n  }\n\n  close() {\n    if (registry) {\n      registry.unregister(this.token)\n    } else {\n      clearTimeout(this.request)\n    }\n  }\n}\n","import { useLayoutEffect, useRef } from 'react'\nimport { immediate } from '../shared'\n\nexport const useDidUpdate = (callback?: () => void) => {\n  const request = useRef(null)\n  request.current = immediate(callback)\n  useLayoutEffect(() => {\n    request.current()\n    callback()\n  })\n}\n","export const immediate = (callback?: () => void) => {\n  let disposed = false\n  Promise.resolve(0).then(() => {\n    if (disposed) {\n      disposed = false\n      return\n    }\n    callback()\n  })\n  return () => {\n    disposed = true\n  }\n}\n","import React from 'react'\nimport { Tracker } from '@formily/reactive'\nimport { GarbageCollector } from '../shared'\nimport { IObserverOptions } from '../types'\nimport { useForceUpdate } from './useForceUpdate'\n\nclass ObjectToBeRetainedByReact {}\n\nfunction objectToBeRetainedByReactFactory() {\n  return new ObjectToBeRetainedByReact()\n}\n\nexport const useObserver = <T extends () => any>(\n  view: T,\n  options?: IObserverOptions\n): ReturnType<T> => {\n  const forceUpdate = useForceUpdate()\n  const unMountRef = React.useRef(false)\n  const trackerRef = React.useRef<Tracker>(null)\n  const gcRef = React.useRef<GarbageCollector>()\n  const [objectRetainedByReact] = React.useState(\n    objectToBeRetainedByReactFactory\n  )\n  if (!trackerRef.current) {\n    trackerRef.current = new Tracker(() => {\n      if (typeof options?.scheduler === 'function') {\n        options.scheduler(forceUpdate)\n      } else {\n        forceUpdate()\n      }\n    }, options?.displayName)\n  }\n\n  //StrictMode/ConcurrentMode会导致组件无法正确触发UnMount，所以只能自己做垃圾回收\n  if (!gcRef.current) {\n    gcRef.current = new GarbageCollector(() => {\n      if (trackerRef.current) {\n        trackerRef.current.dispose()\n      }\n    })\n    gcRef.current.open(objectRetainedByReact)\n  }\n\n  React.useEffect(() => {\n    unMountRef.current = false\n    gcRef.current.close()\n    return () => {\n      unMountRef.current = true\n      if (trackerRef.current) {\n        trackerRef.current.dispose()\n        trackerRef.current = null\n      }\n    }\n  }, [])\n\n  return trackerRef.current.track(view)\n}\n","import { useCallback, useEffect, useRef, useState } from 'react'\nimport { useDidUpdate } from './useDidUpdate'\n\nconst EMPTY_ARRAY: any[] = []\nconst RENDER_COUNT = { value: 0 }\nconst RENDER_QUEUE = new Set<() => void>()\n\nexport function useForceUpdate() {\n  const [, setState] = useState([])\n  const unMountRef = useRef(false)\n\n  useEffect(() => {\n    unMountRef.current = false\n    return () => {\n      unMountRef.current = true\n    }\n  }, EMPTY_ARRAY)\n\n  const update = useCallback(() => {\n    if (unMountRef.current) return\n    setState([])\n  }, EMPTY_ARRAY)\n\n  const scheduler = useCallback(() => {\n    if (RENDER_COUNT.value === 0) {\n      update()\n    } else {\n      RENDER_QUEUE.add(update)\n    }\n  }, EMPTY_ARRAY)\n\n  RENDER_COUNT.value++\n\n  useDidUpdate(() => {\n    if (RENDER_COUNT.value > 0) {\n      RENDER_COUNT.value--\n    }\n    if (RENDER_COUNT.value === 0) {\n      RENDER_QUEUE.forEach((update) => {\n        RENDER_QUEUE.delete(update)\n        update()\n      })\n    }\n  })\n\n  return scheduler\n}\n","import React, { forwardRef, memo, Fragment } from 'react'\nimport hoistNonReactStatics from 'hoist-non-react-statics'\nimport { useObserver } from './hooks'\nimport { IObserverOptions, IObserverProps } from './types'\n\nexport function observer<\n  P,\n  Options extends IObserverOptions = IObserverOptions\n>(\n  component: React.FunctionComponent<P>,\n  options?: Options\n): React.MemoExoticComponent<\n  React.FunctionComponent<\n    Options extends { forwardRef: true }\n      ? P & {\n          ref?: 'ref' extends keyof P ? P['ref'] : React.RefAttributes<any>\n        }\n      : React.PropsWithoutRef<P>\n  >\n> {\n  const realOptions = {\n    forwardRef: false,\n    ...options,\n  }\n\n  const wrappedComponent = realOptions.forwardRef\n    ? forwardRef((props: any, ref: any) => {\n        return useObserver(() => component({ ...props, ref }), realOptions)\n      })\n    : (props: any) => {\n        return useObserver(() => component(props), realOptions)\n      }\n\n  const memoComponent = memo(wrappedComponent)\n\n  hoistNonReactStatics(memoComponent, component)\n\n  if (realOptions.displayName) {\n    memoComponent.displayName = realOptions.displayName\n  }\n\n  return memoComponent\n}\n\nexport const Observer = observer((props: IObserverProps) => {\n  const children =\n    typeof props.children === 'function' ? props.children() : props.children\n  return React.createElement(Fragment, {}, children)\n})\n"],"names":["REACT_STATICS","childContextTypes","contextType","contextTypes","defaultProps","displayName","getDefaultProps","getDerivedStateFromError","getDerivedStateFromProps","mixins","propTypes","type","KNOWN_STATICS","name","length","prototype","caller","callee","arguments","arity","MEMO_STATICS","$$typeof","compare","TYPE_STATICS","getStatics","component","reactIs","isMemo","ForwardRef","render","Memo","defineProperty","Object","getOwnPropertyNames","getOwnPropertySymbols","getOwnPropertyDescriptor","getPrototypeOf","objectPrototype","hoistNonReactStatics","targetComponent","sourceComponent","blacklist","inheritedComponent","keys","concat","targetStatics","sourceStatics","i","key","descriptor","e","globalThisPolyfill","self","window","global","Function","globalSelf","registry","token","clean","expireTime","this","GarbageCollector","target","register","request","setTimeout","_this","unregister","clearTimeout","React","callback","disposed","Promise","resolve","then","Formily"],"mappings":";;;;;;;;;;;;;;;6fAQA,IAAIA,EAAgB,CAClBC,mBAAmB,EACnBC,aAAa,EACbC,cAAc,EACdC,cAAc,EACdC,aAAa,EACbC,iBAAiB,EACjBC,0BAA0B,EAC1BC,0BAA0B,EAC1BC,QAAQ,EACRC,WAAW,EACXC,MAAM,GAEJC,EAAgB,CAClBC,MAAM,EACNC,QAAQ,EACRC,WAAW,EACXC,QAAQ,EACRC,QAAQ,EACRC,WAAW,EACXC,OAAO,GASLC,EAAe,CACjBC,UAAY,EACZC,SAAS,EACTlB,cAAc,EACdC,aAAa,EACbK,WAAW,EACXC,MAAM,GAEJY,EAAe,GAInB,SAASC,EAAWC,GAElB,OAAIC,EAAQC,OAAOF,GACVL,EAIFG,EAAaE,EAAoB,WAAMzB,EAVhDuB,EAAaG,EAAQE,YAhBK,CACxBP,UAAY,EACZQ,QAAQ,EACRzB,cAAc,EACdC,aAAa,EACbK,WAAW,GAYba,EAAaG,EAAQI,MAAQV,EAY7B,IAAIW,EAAiBC,OAAOD,eACxBE,EAAsBD,OAAOC,oBAC7BC,EAAwBF,OAAOE,sBAC/BC,EAA2BH,OAAOG,yBAClCC,EAAiBJ,OAAOI,eACxBC,EAAkBL,OAAOjB,UAsC7B,MArCA,SAASuB,EAAqBC,EAAiBC,EAAiBC,GAC9D,GAA+B,iBAApBD,EAA8B,CAEvC,GAAIH,EAAiB,CACnB,IAAIK,EAAqBN,EAAeI,GAEpCE,GAAsBA,IAAuBL,GAC/CC,EAAqBC,EAAiBG,EAAoBD,GAI9D,IAAIE,EAAOV,EAAoBO,GAE3BN,IACFS,EAAOA,EAAKC,OAAOV,EAAsBM,KAM3C,IAHA,IAAIK,EAAgBrB,EAAWe,GAC3BO,EAAgBtB,EAAWgB,GAEtBO,EAAI,EAAGA,EAAIJ,EAAK7B,SAAUiC,EAAG,CACpC,IAAIC,EAAML,EAAKI,GAEf,KAAKnC,EAAcoC,IAAUP,GAAaA,EAAUO,IAAWF,GAAiBA,EAAcE,IAAWH,GAAiBA,EAAcG,IAAO,CAC7I,IAAIC,EAAad,EAAyBK,EAAiBQ,GAE3D,IAEEjB,EAAeQ,EAAiBS,EAAKC,GACrC,MAAOC,OAKf,OAAOX,GC/EF,IAAMY,EAnBb,WACE,IACE,GAAoB,oBAATC,KACT,OAAOA,KAET,MAAOF,IACT,IACE,GAAsB,oBAAXG,OACT,OAAOA,OAET,MAAOH,IACT,IACE,GAAsB,oBAAXI,OACT,OAAOA,OAET,MAAOJ,IACT,OAAOK,SAAS,cAATA,GAGiCC,GClBpCC,EACJN,EAAyC,sBACzC,IAAIA,EAAyC,sBAAE,SAACO,SAC9C,iBAAAA,MAAAA,SAAAA,EAAOC,iCAAPD,mBAQF,WAAYC,EAAoBC,gBAAAA,OAC9BC,KAAKH,MAAQ,CACXC,SAEFE,KAAKD,WAAaA,EAoBtB,OAjBEE,iBAAA,SAAKC,GAAL,WACMN,EACFA,EAASO,SAASD,EAAQF,KAAKH,MAAOG,KAAKH,OAE3CG,KAAKI,QAAUC,YAAW,uCACxBC,EAAKT,4BAAOC,gCACXE,KAAKD,aAIZE,kBAAA,WACML,EACFA,EAASW,WAAWP,KAAKH,OAEzBW,aAAaR,KAAKI,mCC9BNK,6BCJO,SAACC,GACxB,IAAIC,GAAW,EAQf,OAPAC,QAAQC,QAAQ,GAAGC,MAAK,WAClBH,EACFA,GAAW,EAGbD,OAEK,WACLC,GAAW,ODJbF,iFEAF,mBAEA,uECAuBA,2BACFA,iBAEnBA,oFAOeA,sDAKGA,qSDCSM,ocEEvBN,+IAOkBA,uLAcKA"}
{"version":3,"file":"formily.reactive-vue.umd.development.js","sources":["../../../node_modules/vue-demi/lib/index.esm.js","../src/observer/collectData.ts","../src/observer/observerInVue2.ts","../src/hooks/useObserver.ts","../src/observer/index.ts"],"sourcesContent":["import Vue from 'vue'\nimport VueCompositionAPI from '@vue/composition-api'\n\nfunction install(_vue) {\n  _vue = _vue || Vue\n  if (_vue && !_vue['__composition_api_installed__'])\n    Vue.use(VueCompositionAPI)\n}\n\ninstall(Vue)\n\nvar isVue2 = true\nvar isVue3 = false\nvar Vue2 = Vue\nvar version = Vue.version\n\n/**VCA-EXPORTS**/\nexport { EffectScope, computed, createApp, createRef, customRef, defineAsyncComponent, defineComponent, del, effectScope, getCurrentInstance, getCurrentScope, h, inject, isRaw, isReactive, isReadonly, isRef, markRaw, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onScopeDispose, onServerPrefetch, onUnmounted, onUpdated, provide, proxyRefs, reactive, readonly, ref, set, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref, useAttrs, useCSSModule, useCssModule, useSlots, warn, watch, watchEffect, watchPostEffect, watchSyncEffect } from '@vue/composition-api'\n/**VCA-EXPORTS**/\n\nexport {\n  Vue,\n  Vue2,\n  isVue2,\n  isVue3,\n  version,\n  install,\n}\n","// https://github.com/mobxjs/mobx-vue/blob/master/src/collectData.ts\n\n/**\n * @author Kuitos\n * @homepage https://github.com/kuitos/\n * @since 2018-06-08 10:16\n */\n\nimport { isObservable } from '@formily/reactive'\n\nexport default function collectData(vm: any, data?: any) {\n  const dataDefinition =\n    typeof data === 'function' ? data.call(vm, vm) : data || {}\n  const filteredData = Object.keys(dataDefinition).reduce(\n    (result: any, field) => {\n      const value = dataDefinition[field]\n\n      if (isObservable(value)) {\n        Object.defineProperty(vm, field, {\n          configurable: true,\n          get() {\n            return value\n          },\n          set() {},\n        })\n      } else {\n        result[field] = value\n      }\n\n      return result\n    },\n    {}\n  )\n\n  return filteredData\n}\n","// https://github.com/mobxjs/mobx-vue/blob/master/src/observer.ts\n\n/**\n * @author Kuitos\n * @homepage https://github.com/kuitos/\n * @since 2018-05-22 16:39\n */\nimport { Tracker } from '@formily/reactive'\nimport collectDataForVue from './collectData'\nimport { Vue2 as Vue } from 'vue-demi'\nimport { IObserverOptions } from '../types'\n\nconst noop = () => {}\nconst disposerSymbol = Symbol('disposerSymbol')\n\nfunction observer(Component: any, observerOptions?: IObserverOptions): any {\n  const name =\n    observerOptions?.name ||\n    (Component as any).name ||\n    (Component as any)._componentTag ||\n    (Component.constructor && Component.constructor.name) ||\n    '<component>'\n\n  const originalOptions =\n    typeof Component === 'object' ? Component : (Component as any).options\n  // To not mutate the original component options, we need to construct a new one\n  const dataDefinition = originalOptions.data\n  const options = {\n    name,\n    ...originalOptions,\n    data(vm: any) {\n      return collectDataForVue(vm || this, dataDefinition)\n    },\n    // overrider the cached constructor to avoid extending skip\n    // @see https://github.com/vuejs/vue/blob/6cc070063bd211229dff5108c99f7d11b6778550/src/core/global-api/extend.js#L24\n    _Ctor: {},\n  }\n\n  // we couldn't use the Component as super class when Component was a VueClass, that will invoke the lifecycle twice after we called Component.extend\n  const superProto =\n    typeof Component === 'function' &&\n    Object.getPrototypeOf(Component.prototype)\n  const Super =\n    superProto instanceof (Vue as any) ? superProto.constructor : Vue\n  const ExtendedComponent = Super.extend(options)\n\n  const { $mount, $destroy } = ExtendedComponent.prototype\n\n  ExtendedComponent.prototype.$mount = function (this: any, ...args: any[]) {\n    let mounted = false\n    this[disposerSymbol] = noop\n\n    let nativeRenderOfVue: any\n\n    const reactiveRender = () => {\n      tracker.track(() => {\n        if (!mounted) {\n          $mount.apply(this, args)\n          mounted = true\n          nativeRenderOfVue = this._watcher.getter\n          // rewrite the native render method of vue with our reactive tracker render\n          // thus if component updated by vue watcher, we could re track and collect dependencies by @formily/reactive\n          this._watcher.getter = reactiveRender\n        } else {\n          nativeRenderOfVue.call(this, this)\n        }\n      })\n\n      return this\n    }\n\n    const tracker = new Tracker(reactiveRender)\n\n    this[disposerSymbol] = tracker.dispose\n\n    return reactiveRender()\n  }\n\n  ExtendedComponent.prototype.$destroy = function (this: any) {\n    ;(this as any)[disposerSymbol]()\n    $destroy.apply(this)\n  }\n\n  const extendedComponentNamePropertyDescriptor =\n    Object.getOwnPropertyDescriptor(ExtendedComponent, 'name') || {}\n  if (extendedComponentNamePropertyDescriptor.configurable === true) {\n    Object.defineProperty(ExtendedComponent, 'name', {\n      writable: false,\n      value: name,\n      enumerable: false,\n      configurable: false,\n    })\n  }\n\n  return ExtendedComponent\n}\n\nexport { observer, observer as Observer }\n","import { autorun } from '@formily/reactive'\nimport { getCurrentInstance, onBeforeUnmount, isVue3 } from 'vue-demi'\n\n/* istanbul ignore next */\nexport const useObserver = () => {\n  if (isVue3) {\n    const vm = getCurrentInstance()\n\n    let dispose: () => void | undefined\n\n    onBeforeUnmount(() => {\n      if (dispose) {\n        dispose()\n      }\n    })\n\n    Object.defineProperty(vm, 'update', {\n      get() {\n        return vm['_updateEffect']\n      },\n      set(newValue) {\n        if (dispose) {\n          dispose()\n        }\n        dispose = autorun(newValue)\n        vm['_updateEffect'] = newValue\n      },\n    })\n  }\n}\n","import { isVue2 } from 'vue-demi'\nimport { observer as observerV2 } from './observerInVue2'\nimport { observer as observerV3 } from './observerInVue3'\nimport collectData from './collectData'\nimport { IObserverOptions } from '../types'\n\nexport function observer<C>(\n  baseComponent: C,\n  options?: IObserverOptions & { forwardRef: true }\n): C {\n  if (isVue2) {\n    return observerV2(baseComponent, options)\n  } else {\n    return observerV3(baseComponent, options)\n  }\n}\n\nexport { collectData }\n"],"names":["observerV2"],"mappings":";;;;;;;;;;;;;;;;;;IAGA;IACA;IACA;IACA;IACA;AACA;IACA;IAIA;;AAEA;IACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICnBA;IAEA;;;;;AAMgD;;;;;gBAStC,6BAAY;;;;;;;;;;;;;;;IAkBtB;;ICvBA;IACA;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8BAwDwB,wBAAO;;;;;;;;;;;;;;;;;;IAwB/B;;IC5FA;;IA0BA;;aCvBgB,QAAQ,CACtB,aAAgB,EAChB,OAAiD;QAErC;YACV,OAAOA,UAAU,CAAC,aAAa,EAAE,OAAO,CAAC,CAAA;SAG1C;IACH;;;;;;;;;;;;"}
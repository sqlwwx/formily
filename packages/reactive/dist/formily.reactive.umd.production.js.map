{"version":3,"file":"formily.reactive.umd.production.js","sources":["../src/checkers.ts","../src/array.ts","../src/environment.ts","../src/reaction.ts","../src/externals.ts","../src/handlers.ts","../src/tree.ts","../src/internals.ts","../src/batch.ts","../src/action.ts","../src/untracked.ts","../src/annotations/observable.ts","../src/annotations/box.ts","../src/annotations/ref.ts","../src/annotations/shallow.ts","../src/annotations/computed.ts","../src/observable.ts","../src/model.ts","../src/autorun.ts","../src/tracker.ts","../src/observe.ts"],"sourcesContent":["export const isMap = (val: any): val is Map<any, any> =>\n  val && val instanceof Map\nexport const isSet = (val: any): val is Set<any> => val && val instanceof Set\nexport const isWeakMap = (val: any): val is WeakMap<any, any> =>\n  val && val instanceof WeakMap\nexport const isWeakSet = (val: any): val is WeakSet<any> =>\n  val && val instanceof WeakSet\nexport const isFn = (val: any): val is Function => typeof val === 'function'\nexport const isArr = Array.isArray\nexport const isPlainObj = (val: any): val is object =>\n  Object.prototype.toString.call(val) === '[object Object]'\nexport const isValid = (val: any) => val !== null && val !== undefined\nexport const isCollectionType = (target: any) => {\n  return (\n    isMap(target) || isWeakMap(target) || isSet(target) || isWeakSet(target)\n  )\n}\nexport const isNormalType = (target: any) => {\n  return isPlainObj(target) || isArr(target)\n}\n","export const toArray = (value: any) => {\n  return Array.isArray(value)\n    ? value\n    : value !== undefined && value !== null\n    ? [value]\n    : []\n}\n\nexport class ArraySet<T> {\n  value: T[]\n  batchDeleting = false\n  constructor(value: T[] = []) {\n    this.value = value\n  }\n\n  add(item: T) {\n    if (!this.has(item)) {\n      this.value.push(item)\n    }\n  }\n\n  has(item: T) {\n    return this.value.indexOf(item) > -1\n  }\n\n  delete(item: T) {\n    if (this.batchDeleting) return //批量删除时禁止单独删除，会影响计数执行器\n    const index = this.value.indexOf(item)\n    if (index > -1) {\n      this.value.splice(index, 1)\n    }\n  }\n\n  forEach(callback: (value: T) => void) {\n    if (this.value.length === 0) return\n    for (let index = 0, len = this.value.length; index < len; index++) {\n      callback(this.value[index])\n    }\n  }\n\n  forEachDelete(callback: (value: T) => void) {\n    if (this.value.length === 0) return\n    this.batchDeleting = true\n    for (let index = 0; index < this.value.length; index++) {\n      const item = this.value[index]\n      this.value.splice(index, 1)\n      callback(item)\n      index--\n    }\n    this.batchDeleting = false\n  }\n\n  clear() {\n    this.value.length = 0\n  }\n}\n","import { ObservableListener, Reaction, ReactionsMap } from './types'\nimport { ArraySet } from './array'\nimport { DataNode } from './tree'\n\nexport const ProxyRaw = new WeakMap()\nexport const RawProxy = new WeakMap()\nexport const RawShallowProxy = new WeakMap()\nexport const RawNode = new WeakMap<object, DataNode>()\nexport const RawReactionsMap = new WeakMap<object, ReactionsMap>()\n\nexport const ReactionStack: Reaction[] = []\nexport const BatchCount = { value: 0 }\nexport const UntrackCount = { value: 0 }\nexport const BatchScope = { value: false }\nexport const DependencyCollected = { value: false }\nexport const PendingReactions = new ArraySet<Reaction>()\nexport const PendingScopeReactions = new ArraySet<Reaction>()\nexport const BatchEndpoints = new ArraySet<() => void>()\nexport const MakeObservableSymbol = Symbol('MakeObservableSymbol')\nexport const ObserverListeners = new ArraySet<ObservableListener>()\n","import { isFn } from './checkers'\nimport { ArraySet } from './array'\nimport { IOperation, ReactionsMap, Reaction, PropertyKey } from './types'\nimport {\n  ReactionStack,\n  PendingScopeReactions,\n  BatchEndpoints,\n  DependencyCollected,\n  RawReactionsMap,\n  PendingReactions,\n  BatchCount,\n  UntrackCount,\n  BatchScope,\n  ObserverListeners,\n} from './environment'\n\nconst ITERATION_KEY = Symbol('iteration key')\n\nconst addRawReactionsMap = (\n  target: any,\n  key: PropertyKey,\n  reaction: Reaction\n) => {\n  const reactionsMap = RawReactionsMap.get(target)\n  if (reactionsMap) {\n    const reactions = reactionsMap.get(key)\n    if (reactions) {\n      reactions.add(reaction)\n    } else {\n      reactionsMap.set(key, new ArraySet([reaction]))\n    }\n    return reactionsMap\n  } else {\n    const reactionsMap: ReactionsMap = new Map([\n      [key, new ArraySet([reaction])],\n    ])\n    RawReactionsMap.set(target, reactionsMap)\n    return reactionsMap\n  }\n}\n\nconst addReactionsMapToReaction = (\n  reaction: Reaction,\n  reactionsMap: ReactionsMap\n) => {\n  const bindSet = reaction._reactionsSet\n  if (bindSet) {\n    bindSet.add(reactionsMap)\n  } else {\n    reaction._reactionsSet = new ArraySet([reactionsMap])\n  }\n  return bindSet\n}\n\nconst getReactionsFromTargetKey = (target: any, key: PropertyKey) => {\n  const reactionsMap = RawReactionsMap.get(target)\n  const reactions = []\n  if (reactionsMap) {\n    const map = reactionsMap.get(key)\n    if (map) {\n      map.forEach((reaction) => {\n        if (reactions.indexOf(reaction) === -1) {\n          reactions.push(reaction)\n        }\n      })\n    }\n  }\n  return reactions\n}\n\nconst runReactions = (target: any, key: PropertyKey) => {\n  const reactions = getReactionsFromTargetKey(target, key)\n  const prevUntrackCount = UntrackCount.value\n  UntrackCount.value = 0\n  for (let i = 0, len = reactions.length; i < len; i++) {\n    const reaction = reactions[i]\n    if (reaction._isComputed) {\n      reaction._scheduler(reaction)\n    } else if (isScopeBatching()) {\n      PendingScopeReactions.add(reaction)\n    } else if (isBatching()) {\n      PendingReactions.add(reaction)\n    } else {\n      if (isFn(reaction._scheduler)) {\n        reaction._scheduler(reaction)\n      } else {\n        reaction()\n      }\n    }\n  }\n  UntrackCount.value = prevUntrackCount\n}\n\nconst notifyObservers = (operation: IOperation) => {\n  ObserverListeners.forEach((fn) => fn(operation))\n}\n\nexport const bindTargetKeyWithCurrentReaction = (operation: IOperation) => {\n  let { key, type, target } = operation\n  if (type === 'iterate') {\n    key = ITERATION_KEY\n  }\n\n  const current = ReactionStack[ReactionStack.length - 1]\n  if (isUntracking()) return\n  if (current) {\n    DependencyCollected.value = true\n    addReactionsMapToReaction(current, addRawReactionsMap(target, key, current))\n  }\n}\n\nexport const bindComputedReactions = (reaction: Reaction) => {\n  if (isFn(reaction)) {\n    const current = ReactionStack[ReactionStack.length - 1]\n    if (current) {\n      const computes = current._computesSet\n      if (computes) {\n        computes.add(reaction)\n      } else {\n        current._computesSet = new ArraySet([reaction])\n      }\n    }\n  }\n}\n\nexport const runReactionsFromTargetKey = (operation: IOperation) => {\n  let { key, type, target, oldTarget } = operation\n  batchStart()\n  notifyObservers(operation)\n  if (type === 'clear') {\n    oldTarget.forEach((_: any, key: PropertyKey) => {\n      runReactions(target, key)\n    })\n  } else {\n    runReactions(target, key)\n  }\n  if (type === 'add' || type === 'delete' || type === 'clear') {\n    const newKey = Array.isArray(target) ? 'length' : ITERATION_KEY\n    runReactions(target, newKey)\n  }\n  batchEnd()\n}\n\nexport const hasRunningReaction = () => {\n  return ReactionStack.length > 0\n}\n\nexport const releaseBindingReactions = (reaction: Reaction) => {\n  reaction._reactionsSet?.forEach((reactionsMap) => {\n    reactionsMap.forEach((reactions) => {\n      reactions.delete(reaction)\n    })\n  })\n  PendingReactions.delete(reaction)\n  PendingScopeReactions.delete(reaction)\n  delete reaction._reactionsSet\n}\n\nexport const suspendComputedReactions = (current: Reaction) => {\n  current._computesSet?.forEach((reaction) => {\n    const reactions = getReactionsFromTargetKey(\n      reaction._context,\n      reaction._property\n    )\n    if (reactions.length === 0) {\n      disposeBindingReactions(reaction)\n      reaction._dirty = true\n    }\n  })\n}\n\nexport const disposeBindingReactions = (reaction: Reaction) => {\n  reaction._disposed = true\n  releaseBindingReactions(reaction)\n  suspendComputedReactions(reaction)\n}\n\nexport const batchStart = () => {\n  BatchCount.value++\n}\n\nexport const batchEnd = () => {\n  BatchCount.value--\n  if (BatchCount.value === 0) {\n    const prevUntrackCount = UntrackCount.value\n    UntrackCount.value = 0\n    executePendingReactions()\n    executeBatchEndpoints()\n    UntrackCount.value = prevUntrackCount\n  }\n}\n\nexport const batchScopeStart = () => {\n  BatchScope.value = true\n}\n\nexport const batchScopeEnd = () => {\n  const prevUntrackCount = UntrackCount.value\n  BatchScope.value = false\n  UntrackCount.value = 0\n  PendingScopeReactions.forEachDelete((reaction) => {\n    if (isFn(reaction._scheduler)) {\n      reaction._scheduler(reaction)\n    } else {\n      reaction()\n    }\n  })\n  UntrackCount.value = prevUntrackCount\n}\n\nexport const untrackStart = () => {\n  UntrackCount.value++\n}\n\nexport const untrackEnd = () => {\n  UntrackCount.value--\n}\n\nexport const isBatching = () => BatchCount.value > 0\n\nexport const isScopeBatching = () => BatchScope.value\n\nexport const isUntracking = () => UntrackCount.value > 0\n\nexport const executePendingReactions = () => {\n  PendingReactions.forEachDelete((reaction) => {\n    if (isFn(reaction._scheduler)) {\n      reaction._scheduler(reaction)\n    } else {\n      reaction()\n    }\n  })\n}\n\nexport const executeBatchEndpoints = () => {\n  BatchEndpoints.forEachDelete((callback) => {\n    callback()\n  })\n}\n\nexport const hasDepsChange = (newDeps: any[], oldDeps: any[]) => {\n  if (newDeps === oldDeps) return false\n  if (newDeps.length !== oldDeps.length) return true\n  if (newDeps.some((value, index) => value !== oldDeps[index])) return true\n  return false\n}\n\nexport const disposeEffects = (reaction: Reaction) => {\n  if (reaction._effects) {\n    try {\n      batchStart()\n      reaction._effects.queue.forEach((item) => {\n        if (!item || !item.dispose) return\n        item.dispose()\n      })\n    } finally {\n      batchEnd()\n    }\n  }\n}\n","import {\n  isValid,\n  isFn,\n  isMap,\n  isWeakMap,\n  isSet,\n  isWeakSet,\n  isPlainObj,\n  isArr,\n} from './checkers'\nimport {\n  ProxyRaw,\n  MakeObservableSymbol,\n  DependencyCollected,\n  RawNode,\n} from './environment'\nimport { Annotation } from './types'\n\nconst RAW_TYPE = Symbol('RAW_TYPE')\nconst OBSERVABLE_TYPE = Symbol('OBSERVABLE_TYPE')\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\nexport const isObservable = (target: any) => {\n  return ProxyRaw.has(target)\n}\n\nexport const isAnnotation = (target: any): target is Annotation => {\n  return target && !!target[MakeObservableSymbol]\n}\n\nexport const isSupportObservable = (target: any) => {\n  if (!isValid(target)) return false\n  if (isArr(target)) return true\n  if (isPlainObj(target)) {\n    if (target[RAW_TYPE]) {\n      return false\n    }\n    if (target[OBSERVABLE_TYPE]) {\n      return true\n    }\n    if ('$$typeof' in target && '_owner' in target) {\n      return false\n    }\n    if (target['_isAMomentObject']) {\n      return false\n    }\n    if (target['_isJSONSchemaObject']) {\n      return false\n    }\n    if (isFn(target['toJS'])) {\n      return false\n    }\n    if (isFn(target['toJSON'])) {\n      return false\n    }\n    return true\n  }\n  if (isMap(target) || isWeakMap(target) || isSet(target) || isWeakSet(target))\n    return true\n  return false\n}\n\nexport const markRaw = <T>(target: T): T => {\n  if (!target) return\n  if (isFn(target)) {\n    target.prototype[RAW_TYPE] = true\n  } else {\n    target[RAW_TYPE] = true\n  }\n  return target\n}\n\nexport const markObservable = <T>(target: T): T => {\n  if (!target) return\n  if (isFn(target)) {\n    target.prototype[OBSERVABLE_TYPE] = true\n  } else {\n    target[OBSERVABLE_TYPE] = true\n  }\n  return target\n}\n\nexport const raw = <T>(target: T): T => ProxyRaw.get(target as any)\n\nexport const toJS = <T>(values: T): T => {\n  const visited = new WeakSet<any>()\n  const _toJS: typeof toJS = (values: any) => {\n    if (visited.has(values)) {\n      return values\n    }\n    if (values && values[RAW_TYPE]) return values\n    if (isArr(values)) {\n      if (isObservable(values)) {\n        visited.add(values)\n        const res: any = []\n        values.forEach((item: any) => {\n          res.push(_toJS(item))\n        })\n        visited.delete(values)\n        return res\n      }\n    } else if (isPlainObj(values)) {\n      if (isObservable(values)) {\n        visited.add(values)\n        const res: any = {}\n        for (const key in values) {\n          if (hasOwnProperty.call(values, key)) {\n            res[key] = _toJS(values[key])\n          }\n        }\n        visited.delete(values)\n        return res\n      }\n    }\n    return values\n  }\n\n  return _toJS(values)\n}\n\nexport const contains = (target: any, property: any) => {\n  const targetRaw = ProxyRaw.get(target) || target\n  const propertyRaw = ProxyRaw.get(property) || property\n  if (targetRaw === propertyRaw) return true\n  const targetNode = RawNode.get(targetRaw)\n  const propertyNode = RawNode.get(propertyRaw)\n  if (!targetNode) return false\n  if (!propertyNode) return false\n  return targetNode.contains(propertyNode)\n}\n\nexport const hasCollected = (callback?: () => void) => {\n  DependencyCollected.value = false\n  callback?.()\n  return DependencyCollected.value\n}\n","import {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from './reaction'\nimport { ProxyRaw, RawProxy } from './environment'\nimport { isObservable, isSupportObservable } from './externals'\nimport { createObservable } from './internals'\n\nconst wellKnownSymbols = new Set(\n  Object.getOwnPropertyNames(Symbol)\n    .map((key) => Symbol[key])\n    .filter((value) => typeof value === 'symbol')\n)\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction findObservable(target: any, key: PropertyKey, value: any) {\n  const observableObj = RawProxy.get(value)\n  if (observableObj) {\n    return observableObj\n  }\n  if (!isObservable(value) && isSupportObservable(value)) {\n    return createObservable(target, key, value)\n  }\n  return value\n}\n\nfunction patchIterator(\n  target: any,\n  key: PropertyKey,\n  iterator: IterableIterator<any>,\n  isEntries: boolean\n) {\n  const originalNext = iterator.next\n  iterator.next = () => {\n    let { done, value } = originalNext.call(iterator)\n    if (!done) {\n      if (isEntries) {\n        value[1] = findObservable(target, key, value[1])\n      } else {\n        value = findObservable(target, key, value)\n      }\n    }\n    return { done, value }\n  }\n  return iterator\n}\n\nconst instrumentations = {\n  has(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, key, type: 'has' })\n    return proto.has.apply(target, arguments)\n  },\n  get(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, key, type: 'get' })\n    return findObservable(target, key, proto.get.apply(target, arguments))\n  },\n  add(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadKey = proto.has.call(target, key)\n    // forward the operation before queueing reactions\n    const result = proto.add.apply(target, arguments)\n    if (!hadKey) {\n      runReactionsFromTargetKey({ target, key, value: key, type: 'add' })\n    }\n    return result\n  },\n  set(key: PropertyKey, value: any) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadKey = proto.has.call(target, key)\n    const oldValue = proto.get.call(target, key)\n    // forward the operation before queueing reactions\n    const result = proto.set.apply(target, arguments)\n    if (!hadKey) {\n      runReactionsFromTargetKey({ target, key, value, type: 'add' })\n    } else if (value !== oldValue) {\n      runReactionsFromTargetKey({ target, key, value, oldValue, type: 'set' })\n    }\n    return result\n  },\n  delete(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadKey = proto.has.call(target, key)\n    const oldValue = proto.get ? proto.get.call(target, key) : undefined\n    // forward the operation before queueing reactions\n    const result = proto.delete.apply(target, arguments)\n    if (hadKey) {\n      runReactionsFromTargetKey({ target, key, oldValue, type: 'delete' })\n    }\n    return result\n  },\n  clear() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadItems = target.size !== 0\n    const oldTarget = target instanceof Map ? new Map(target) : new Set(target)\n    // forward the operation before queueing reactions\n    const result = proto.clear.apply(target, arguments)\n    if (hadItems) {\n      runReactionsFromTargetKey({ target, oldTarget, type: 'clear' })\n    }\n    return result\n  },\n  forEach(cb: any, ...args: any[]) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    // swap out the raw values with their observable pairs\n    // before passing them to the callback\n    const wrappedCb = (value: any, key: PropertyKey, ...args: any) =>\n      cb(findObservable(target, key, value), key, ...args)\n    return proto.forEach.call(target, wrappedCb, ...args)\n  },\n  keys() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    return proto.keys.apply(target, arguments)\n  },\n  values() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    const iterator = proto.values.apply(target, arguments)\n    return patchIterator(target, '', iterator, false)\n  },\n  entries() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    const iterator = proto.entries.apply(target, arguments)\n    return patchIterator(target, '', iterator, true)\n  },\n  [Symbol.iterator]() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this)\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    const iterator = proto[Symbol.iterator].apply(target, arguments)\n    return patchIterator(target, '', iterator, target instanceof Map)\n  },\n  get size() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this)\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    return Reflect.get(proto, 'size', target)\n  },\n}\n\nexport const collectionHandlers = {\n  get(target: any, key: PropertyKey, receiver: any) {\n    // instrument methods and property accessors to be reactive\n    target = hasOwnProperty.call(instrumentations, key)\n      ? instrumentations\n      : target\n    return Reflect.get(target, key, receiver)\n  },\n}\n\nexport const baseHandlers: ProxyHandler<any> = {\n  get(target, key, receiver) {\n    const result = target[key] // use Reflect.get is too slow\n    if (typeof key === 'symbol' && wellKnownSymbols.has(key)) {\n      return result\n    }\n    bindTargetKeyWithCurrentReaction({ target, key, receiver, type: 'get' })\n    const observableResult = RawProxy.get(result)\n    if (observableResult) {\n      return observableResult\n    }\n    if (!isObservable(result) && isSupportObservable(result)) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(target, key)\n      if (\n        !descriptor ||\n        !(descriptor.writable === false && descriptor.configurable === false)\n      ) {\n        return createObservable(target, key, result)\n      }\n    }\n    return result\n  },\n  has(target, key) {\n    const result = Reflect.has(target, key)\n    bindTargetKeyWithCurrentReaction({ target, key, type: 'has' })\n    return result\n  },\n  ownKeys(target) {\n    const keys = Reflect.ownKeys(target)\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    return keys\n  },\n  set(target, key, value, receiver) {\n    const hadKey = hasOwnProperty.call(target, key)\n    const newValue = createObservable(target, key, value)\n    const oldValue = target[key]\n    target[key] = newValue // use Reflect.set is too slow\n    if (!hadKey) {\n      runReactionsFromTargetKey({\n        target,\n        key,\n        value: newValue,\n        oldValue,\n        receiver,\n        type: 'add',\n      })\n    } else if (value !== oldValue) {\n      runReactionsFromTargetKey({\n        target,\n        key,\n        value: newValue,\n        oldValue,\n        receiver,\n        type: 'set',\n      })\n    }\n    return true\n  },\n  deleteProperty(target, key) {\n    const oldValue = target[key]\n    delete target[key]\n    runReactionsFromTargetKey({\n      target,\n      key,\n      oldValue,\n      type: 'delete',\n    })\n    return true\n  },\n}\n","import { ProxyRaw, RawNode } from './environment'\nimport { ObservablePath, PropertyKey, IOperation } from './types'\n\nexport class DataChange {\n  path: ObservablePath\n  key: PropertyKey\n  object: object\n  type: string\n  value: any\n  oldValue: any\n  constructor(operation: IOperation, node: DataNode) {\n    this.key = operation.key\n    this.type = operation.type\n    this.object = operation.target\n    this.value = operation.value\n    this.oldValue = operation.oldValue\n    this.path = node.path.concat(operation.key)\n  }\n}\nexport class DataNode {\n  target: any\n\n  key: PropertyKey\n\n  value: any\n\n  constructor(target: any, key: PropertyKey, value: any) {\n    this.target = target\n    this.key = key\n    this.value = value\n  }\n\n  get path() {\n    if (!this.parent) return this.key ? [this.key] : []\n    return this.parent.path.concat(this.key)\n  }\n\n  get targetRaw() {\n    return ProxyRaw.get(this.target) || this.target\n  }\n\n  get parent() {\n    if (!this.target) return\n    return RawNode.get(this.targetRaw)\n  }\n\n  isEqual(node: DataNode) {\n    if (this.key) {\n      return node.targetRaw === this.targetRaw && node.key === this.key\n    }\n    return node.value === this.value\n  }\n\n  contains(node: DataNode) {\n    if (node === this) return true\n    let parent = node.parent\n    while (!!parent) {\n      if (this.isEqual(parent)) return true\n      parent = parent.parent\n    }\n    return false\n  }\n}\n\nexport const buildDataTree = (target: any, key: PropertyKey, value: any) => {\n  const currentNode = RawNode.get(ProxyRaw.get(value) || value)\n  if (currentNode) return currentNode\n  RawNode.set(value, new DataNode(target, key, value))\n}\n","import { isFn, isCollectionType, isNormalType } from './checkers'\nimport {\n  RawProxy,\n  ProxyRaw,\n  MakeObservableSymbol,\n  RawShallowProxy,\n  RawNode,\n} from './environment'\nimport { baseHandlers, collectionHandlers } from './handlers'\nimport { buildDataTree } from './tree'\nimport { isSupportObservable } from './externals'\nimport { PropertyKey, IVisitor, BoundaryFunction } from './types'\n\nconst createNormalProxy = (target: any, shallow?: boolean) => {\n  const proxy = new Proxy(target, baseHandlers)\n  ProxyRaw.set(proxy, target)\n  if (shallow) {\n    RawShallowProxy.set(target, proxy)\n  } else {\n    RawProxy.set(target, proxy)\n  }\n  return proxy\n}\n\nconst createCollectionProxy = (target: any, shallow?: boolean) => {\n  const proxy = new Proxy(target, collectionHandlers)\n  ProxyRaw.set(proxy, target)\n  if (shallow) {\n    RawShallowProxy.set(target, proxy)\n  } else {\n    RawProxy.set(target, proxy)\n  }\n  return proxy\n}\n\nconst createShallowProxy = (target: any) => {\n  if (isNormalType(target)) return createNormalProxy(target, true)\n  if (isCollectionType(target)) return createCollectionProxy(target, true)\n  return target\n}\n\nexport const createObservable = (\n  target: any,\n  key?: PropertyKey,\n  value?: any,\n  shallow?: boolean\n) => {\n  if (typeof value !== 'object') return value\n  const raw = ProxyRaw.get(value)\n  if (!!raw) {\n    const node = RawNode.get(raw)\n    node.key = key\n    return value\n  }\n\n  if (!isSupportObservable(value)) return value\n\n  if (target) {\n    const parentRaw = ProxyRaw.get(target) || target\n    const isShallowParent = RawShallowProxy.get(parentRaw)\n    if (isShallowParent) return value\n  }\n\n  buildDataTree(target, key, value)\n  if (shallow) return createShallowProxy(value)\n  if (isNormalType(value)) return createNormalProxy(value)\n  if (isCollectionType(value)) return createCollectionProxy(value)\n  return value\n}\n\nexport const createAnnotation = <T extends (visitor: IVisitor) => any>(\n  maker: T\n) => {\n  const annotation = (target: any): ReturnType<T> => {\n    return maker({ value: target })\n  }\n  if (isFn(maker)) {\n    annotation[MakeObservableSymbol] = maker\n  }\n  return annotation\n}\n\nexport const getObservableMaker = (target: any) => {\n  if (target[MakeObservableSymbol]) {\n    if (!target[MakeObservableSymbol][MakeObservableSymbol]) {\n      return target[MakeObservableSymbol]\n    }\n    return getObservableMaker(target[MakeObservableSymbol])\n  }\n}\n\nexport const createBoundaryFunction = (\n  start: (...args: any) => void,\n  end: (...args: any) => void\n) => {\n  function boundary<F extends (...args: any) => any>(fn?: F): ReturnType<F> {\n    let results: ReturnType<F>\n    try {\n      start()\n      if (isFn(fn)) {\n        results = fn()\n      }\n    } finally {\n      end()\n    }\n    return results\n  }\n\n  boundary.bound = createBindFunction(boundary)\n  return boundary\n}\n\nexport const createBindFunction = <Boundary extends BoundaryFunction>(\n  boundary: Boundary\n) => {\n  function bind<F extends (...args: any[]) => any>(\n    callback?: F,\n    context?: any\n  ): F {\n    return ((...args: any[]) =>\n      boundary(() => callback.apply(context, args))) as any\n  }\n  return bind\n}\n\nexport const createBoundaryAnnotation = (\n  start: (...args: any) => void,\n  end: (...args: any) => void\n) => {\n  const boundary = createBoundaryFunction(start, end)\n  const annotation = createAnnotation(({ target, key }) => {\n    target[key] = boundary.bound(target[key], target)\n    return target\n  })\n  boundary[MakeObservableSymbol] = annotation\n  boundary.bound[MakeObservableSymbol] = annotation\n  return boundary\n}\n","import {\n  batchStart,\n  batchEnd,\n  batchScopeStart,\n  batchScopeEnd,\n} from './reaction'\nimport { BatchEndpoints, BatchCount } from './environment'\nimport { createBoundaryAnnotation } from './internals'\nimport { IBatch } from './types'\nimport { isFn } from './checkers'\n\nexport const batch: IBatch = createBoundaryAnnotation(batchStart, batchEnd)\nbatch.scope = createBoundaryAnnotation(batchScopeStart, batchScopeEnd)\nbatch.endpoint = (callback?: () => void) => {\n  if (!isFn(callback)) return\n  if (BatchCount.value === 0) {\n    callback()\n  } else {\n    BatchEndpoints.add(callback)\n  }\n}\n","import {\n  batchStart,\n  batchEnd,\n  batchScopeStart,\n  batchScopeEnd,\n  untrackStart,\n  untrackEnd,\n} from './reaction'\nimport { createBoundaryAnnotation } from './internals'\nimport { IAction } from './types'\n\nexport const action: IAction = createBoundaryAnnotation(\n  () => {\n    batchStart()\n    untrackStart()\n  },\n  () => {\n    untrackEnd()\n    batchEnd()\n  }\n)\n\naction.scope = createBoundaryAnnotation(\n  () => {\n    batchScopeStart()\n    untrackStart()\n  },\n  () => {\n    untrackEnd()\n    batchScopeEnd()\n  }\n)\n","import { createBoundaryFunction } from './internals'\nimport { untrackStart, untrackEnd } from './reaction'\n\nexport const untracked = createBoundaryFunction(untrackStart, untrackEnd)\n","import { createAnnotation, createObservable } from '../internals'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\n\nexport interface IObservable {\n  <T>(target: T): T\n}\n\nexport const observable: IObservable = createAnnotation(\n  ({ target, key, value }) => {\n    const store = {\n      value: createObservable(target, key, target ? target[key] : value),\n    }\n\n    function get() {\n      bindTargetKeyWithCurrentReaction({\n        target: target,\n        key: key,\n        type: 'get',\n      })\n      return store.value\n    }\n\n    function set(value: any) {\n      const oldValue = store.value\n      value = createObservable(target, key, value)\n      store.value = value\n      if (oldValue === value) return\n      runReactionsFromTargetKey({\n        target: target,\n        key: key,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n    if (target) {\n      Object.defineProperty(target, key, {\n        set,\n        get,\n        enumerable: true,\n        configurable: false,\n      })\n      return target\n    }\n    return store.value\n  }\n)\n","import { ProxyRaw, RawProxy } from '../environment'\nimport { createAnnotation } from '../internals'\nimport { buildDataTree } from '../tree'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\n\nexport interface IBox {\n  <T>(target: T): { get(): T; set(value: T): void }\n}\n\nexport const box: IBox = createAnnotation(({ target, key, value }) => {\n  const store = {\n    value: target ? target[key] : value,\n  }\n\n  const proxy = {\n    set,\n    get,\n  }\n\n  ProxyRaw.set(proxy, store)\n  RawProxy.set(store, proxy)\n\n  buildDataTree(target, key, store)\n\n  function get() {\n    bindTargetKeyWithCurrentReaction({\n      target: store,\n      key,\n      type: 'get',\n    })\n    return store.value\n  }\n\n  function set(value: any) {\n    const oldValue = store.value\n    store.value = value\n    if (oldValue !== value) {\n      runReactionsFromTargetKey({\n        target: store,\n        key,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n  }\n\n  if (target) {\n    Object.defineProperty(target, key, {\n      value: proxy,\n      enumerable: true,\n      configurable: false,\n      writable: false,\n    })\n    return target\n  }\n  return proxy\n})\n","import { ProxyRaw, RawProxy } from '../environment'\nimport { createAnnotation } from '../internals'\nimport { buildDataTree } from '../tree'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\n\nexport interface IRef {\n  <T>(target: T): { value: T }\n}\n\nexport const ref: IRef = createAnnotation(({ target, key, value }) => {\n  const store = {\n    value: target ? target[key] : value,\n  }\n\n  const proxy = {}\n\n  const context = target ? target : store\n  const property = target ? key : 'value'\n\n  buildDataTree(target, key, store)\n\n  ProxyRaw.set(proxy, store)\n  RawProxy.set(store, proxy)\n\n  function get() {\n    bindTargetKeyWithCurrentReaction({\n      target: context,\n      key: property,\n      type: 'get',\n    })\n    return store.value\n  }\n\n  function set(value: any) {\n    const oldValue = store.value\n    store.value = value\n    if (oldValue !== value) {\n      runReactionsFromTargetKey({\n        target: context,\n        key: property,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n  }\n  if (target) {\n    Object.defineProperty(target, key, {\n      get,\n      set,\n      enumerable: true,\n      configurable: false,\n    })\n    return target\n  } else {\n    Object.defineProperty(proxy, 'value', {\n      set,\n      get,\n    })\n  }\n  return proxy\n})\n","import { createAnnotation, createObservable } from '../internals'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\nimport { IObservable } from './observable'\n\nexport const shallow: IObservable = createAnnotation(\n  ({ target, key, value }) => {\n    const store = {\n      value: createObservable(target, key, target ? target[key] : value, true),\n    }\n\n    function get() {\n      bindTargetKeyWithCurrentReaction({\n        target: target,\n        key: key,\n        type: 'get',\n      })\n      return store.value\n    }\n\n    function set(value: any) {\n      const oldValue = store.value\n      value = createObservable(target, key, value, true)\n      store.value = value\n      if (oldValue === value) return\n      runReactionsFromTargetKey({\n        target: target,\n        key: key,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n    if (target) {\n      Object.defineProperty(target, key, {\n        set,\n        get,\n        enumerable: true,\n        configurable: false,\n      })\n      return target\n    }\n    return store.value\n  }\n)\n","import { ProxyRaw, RawProxy, ReactionStack } from '../environment'\nimport { createAnnotation } from '../internals'\nimport { buildDataTree } from '../tree'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n  bindComputedReactions,\n  hasRunningReaction,\n  isUntracking,\n  batchStart,\n  batchEnd,\n  releaseBindingReactions,\n} from '../reaction'\n\ninterface IValue<T = any> {\n  value?: T\n}\nexport interface IComputed {\n  <T>(compute: () => T): IValue<T>\n  <T>(compute: { get?: () => T; set?: (value: T) => void }): IValue<T>\n}\n\nexport const computed: IComputed = createAnnotation(\n  ({ target, key, value }) => {\n    const store: IValue = {}\n\n    const proxy = {}\n\n    const context = target ? target : store\n    const property = target ? key : 'value'\n    const getter = getGetter(context)\n    const setter = getSetter(context)\n\n    function getGetter(target: any) {\n      if (!target) {\n        if (value && value.get) return value.get\n        return value\n      }\n      const descriptor = Object.getOwnPropertyDescriptor(target, property)\n      if (descriptor && descriptor.get) return descriptor.get\n      return getGetter(Object.getPrototypeOf(target))\n    }\n\n    function getSetter(target: any) {\n      if (!target) {\n        if (value && value.set) return value.set\n        return\n      }\n      const descriptor = Object.getOwnPropertyDescriptor(target, property)\n      if (descriptor && descriptor.set) return descriptor.set\n      return getSetter(Object.getPrototypeOf(target))\n    }\n\n    function compute() {\n      store.value = getter?.call?.(context)\n    }\n    function reaction() {\n      if (ReactionStack.indexOf(reaction) === -1) {\n        releaseBindingReactions(reaction)\n        try {\n          ReactionStack.push(reaction)\n          compute()\n        } finally {\n          ReactionStack.pop()\n        }\n      }\n    }\n    reaction._name = 'ComputedReaction'\n    reaction._scheduler = () => {\n      reaction._dirty = true\n      runReactionsFromTargetKey({\n        target: context,\n        key: property,\n        value: store.value,\n        type: 'set',\n      })\n    }\n    reaction._isComputed = true\n    reaction._dirty = true\n    reaction._context = context\n    reaction._property = property\n\n    ProxyRaw.set(proxy, store)\n    RawProxy.set(store, proxy)\n\n    buildDataTree(target, key, store)\n\n    function get() {\n      if (hasRunningReaction()) {\n        bindComputedReactions(reaction)\n      }\n      if (!isUntracking()) {\n        //如果允许untracked过程中收集依赖，那么永远不会存在绑定，因为_dirty已经设置为false\n        if (reaction._dirty) {\n          reaction()\n          reaction._dirty = false\n        }\n      } else {\n        compute()\n      }\n      bindTargetKeyWithCurrentReaction({\n        target: context,\n        key: property,\n        type: 'get',\n      })\n      return store.value\n    }\n\n    function set(value: any) {\n      try {\n        batchStart()\n        setter?.call?.(context, value)\n      } finally {\n        batchEnd()\n      }\n    }\n    if (target) {\n      Object.defineProperty(target, key, {\n        get,\n        set,\n        enumerable: true,\n        configurable: false,\n      })\n      return target\n    } else {\n      Object.defineProperty(proxy, 'value', {\n        set,\n        get,\n      })\n    }\n    return proxy\n  }\n)\n","import * as annotations from './annotations'\nimport { MakeObservableSymbol } from './environment'\nimport { createObservable } from './internals'\n\nexport function observable<T extends object>(target: T): T {\n  return createObservable(null, null, target)\n}\n\nobservable.box = annotations.box\nobservable.ref = annotations.ref\nobservable.deep = annotations.observable\nobservable.shallow = annotations.shallow\nobservable.computed = annotations.computed\nobservable[MakeObservableSymbol] = annotations.observable\n","import { isFn } from './checkers'\nimport { buildDataTree } from './tree'\nimport { observable } from './observable'\nimport { getObservableMaker } from './internals'\nimport { isObservable, isAnnotation, isSupportObservable } from './externals'\nimport { Annotations } from './types'\nimport { action } from './action'\nimport { ProxyRaw, RawProxy } from './environment'\n\nexport function define<Target extends object = any>(\n  target: Target,\n  annotations?: Annotations<Target>\n): Target {\n  if (isObservable(target)) return target\n  if (!isSupportObservable(target)) return target\n  buildDataTree(undefined, undefined, target)\n  ProxyRaw.set(target, target)\n  RawProxy.set(target, target)\n  for (const key in annotations) {\n    const annotation = annotations[key]\n    if (isAnnotation(annotation)) {\n      getObservableMaker(annotation)({\n        target,\n        key,\n      })\n    }\n  }\n  return target\n}\n\nexport function model<Target extends object = any>(target: Target): Target {\n  const annotations = Object.keys(target || {}).reduce((buf, key) => {\n    const descriptor = Object.getOwnPropertyDescriptor(target, key)\n    if (descriptor && descriptor.get) {\n      buf[key] = observable.computed\n    } else if (isFn(target[key])) {\n      buf[key] = action\n    } else {\n      buf[key] = observable\n    }\n    return buf\n  }, {})\n  return define(target, annotations)\n}\n","import {\n  batchEnd,\n  batchStart,\n  disposeBindingReactions,\n  releaseBindingReactions,\n  disposeEffects,\n  hasDepsChange,\n  untrackStart,\n  untrackEnd,\n} from './reaction'\nimport { isFn } from './checkers'\nimport { ReactionStack } from './environment'\nimport { Reaction, IReactionOptions, Dispose } from './types'\nimport { toArray } from './array'\n\ninterface IValue {\n  currentValue?: any\n  oldValue?: any\n}\n\nexport const autorun = (tracker: Reaction, name = 'AutoRun') => {\n  const reaction: Reaction = () => {\n    if (!isFn(tracker)) return\n    if (reaction._boundary > 0) return\n    if (ReactionStack.indexOf(reaction) === -1) {\n      releaseBindingReactions(reaction)\n      try {\n        batchStart()\n        ReactionStack.push(reaction)\n        tracker()\n      } finally {\n        ReactionStack.pop()\n        reaction._boundary++\n        batchEnd()\n        reaction._boundary = 0\n        reaction._memos.cursor = 0\n        reaction._effects.cursor = 0\n      }\n    }\n  }\n  const cleanRefs = () => {\n    reaction._memos = {\n      queue: [],\n      cursor: 0,\n    }\n    reaction._effects = {\n      queue: [],\n      cursor: 0,\n    }\n  }\n  reaction._boundary = 0\n  reaction._name = name\n  cleanRefs()\n  reaction()\n  return () => {\n    disposeBindingReactions(reaction)\n    disposeEffects(reaction)\n    cleanRefs()\n  }\n}\n\nautorun.memo = <T>(callback: () => T, dependencies?: any[]): T => {\n  if (!isFn(callback)) return\n  const current = ReactionStack[ReactionStack.length - 1]\n  if (!current || !current._memos)\n    throw new Error('autorun.memo must used in autorun function body.')\n  const deps = toArray(dependencies || [])\n  const id = current._memos.cursor++\n  const old = current._memos.queue[id]\n  if (!old || hasDepsChange(deps, old.deps)) {\n    const value = callback()\n    current._memos.queue[id] = {\n      value,\n      deps,\n    }\n    return value\n  }\n  return old.value\n}\n\nautorun.effect = (callback: () => void | Dispose, dependencies?: any[]) => {\n  if (!isFn(callback)) return\n  const current = ReactionStack[ReactionStack.length - 1]\n  if (!current || !current._effects)\n    throw new Error('autorun.effect must used in autorun function body.')\n  const effects = current._effects\n  const deps = toArray(dependencies || [{}])\n  const id = effects.cursor++\n  const old = effects.queue[id]\n  if (!old || hasDepsChange(deps, old.deps)) {\n    Promise.resolve(0).then(() => {\n      if (current._disposed) return\n      const dispose = callback()\n      if (isFn(dispose)) {\n        effects.queue[id].dispose = dispose\n      }\n    })\n    effects.queue[id] = {\n      deps,\n    }\n  }\n}\n\nexport const reaction = <T>(\n  tracker: () => T,\n  subscriber?: (value: T, oldValue: T) => void,\n  options?: IReactionOptions<T>\n) => {\n  const realOptions = {\n    name: 'Reaction',\n    ...options,\n  }\n  const value: IValue = {}\n  const dirtyCheck = () => {\n    if (isFn(realOptions.equals))\n      return !realOptions.equals(value.oldValue, value.currentValue)\n    return value.oldValue !== value.currentValue\n  }\n\n  const fireAction = () => {\n    try {\n      untrackStart()\n      batchStart()\n      if (isFn(subscriber)) subscriber(value.currentValue, value.oldValue)\n    } finally {\n      batchEnd()\n      untrackEnd()\n    }\n  }\n\n  const reaction: Reaction = () => {\n    if (ReactionStack.indexOf(reaction) === -1) {\n      releaseBindingReactions(reaction)\n      try {\n        ReactionStack.push(reaction)\n        value.currentValue = tracker()\n      } finally {\n        ReactionStack.pop()\n      }\n    }\n  }\n  reaction._scheduler = (looping) => {\n    looping()\n    if (dirtyCheck()) fireAction()\n    value.oldValue = value.currentValue\n  }\n  reaction._name = realOptions.name\n  reaction()\n  value.oldValue = value.currentValue\n  if (realOptions.fireImmediately) {\n    fireAction()\n  }\n  return () => {\n    disposeBindingReactions(reaction)\n  }\n}\n","import { ReactionStack } from './environment'\nimport { isFn } from './checkers'\nimport { Reaction } from './types'\nimport {\n  batchEnd,\n  batchStart,\n  disposeBindingReactions,\n  releaseBindingReactions,\n} from './reaction'\n\nexport class Tracker {\n  private results: any\n  constructor(\n    scheduler?: (reaction: Reaction) => void,\n    name = 'TrackerReaction'\n  ) {\n    this.track._scheduler = (callback) => {\n      if (this.track._boundary === 0) this.dispose()\n      if (isFn(callback)) scheduler(callback)\n    }\n    this.track._name = name\n    this.track._boundary = 0\n  }\n\n  track: Reaction = (tracker: Reaction) => {\n    if (!isFn(tracker)) return this.results\n    if (this.track._boundary > 0) return\n    if (ReactionStack.indexOf(this.track) === -1) {\n      releaseBindingReactions(this.track)\n      try {\n        batchStart()\n        ReactionStack.push(this.track)\n        this.results = tracker()\n      } finally {\n        ReactionStack.pop()\n        this.track._boundary++\n        batchEnd()\n        this.track._boundary = 0\n      }\n    }\n    return this.results\n  }\n\n  dispose = () => {\n    disposeBindingReactions(this.track)\n  }\n}\n","import { IOperation } from './types'\nimport { RawNode, ProxyRaw, ObserverListeners } from './environment'\nimport { isFn } from './checkers'\nimport { DataChange } from './tree'\n\nexport const observe = (\n  target: object,\n  observer?: (change: DataChange) => void,\n  deep = true\n) => {\n  const addListener = (target: any) => {\n    const raw = ProxyRaw.get(target) || target\n    const node = RawNode.get(raw)\n\n    const listener = (operation: IOperation) => {\n      const targetRaw = ProxyRaw.get(operation.target) || operation.target\n      const targetNode = RawNode.get(targetRaw)\n      if (deep) {\n        if (node.contains(targetNode)) {\n          observer(new DataChange(operation, targetNode))\n          return\n        }\n      }\n      if (\n        node === targetNode ||\n        (node.targetRaw === targetRaw && node.key === operation.key)\n      ) {\n        observer(new DataChange(operation, targetNode))\n      }\n    }\n\n    if (node && isFn(observer)) {\n      ObserverListeners.add(listener)\n    }\n    return () => {\n      ObserverListeners.delete(listener)\n    }\n  }\n  if (target && typeof target !== 'object')\n    throw Error(`Can not observe ${typeof target} type.`)\n  return addListener(target)\n}\n"],"names":["isMap","val","Map","isSet","Set","isWeakMap","WeakMap","isWeakSet","WeakSet","isFn","isArr","Array","isArray","isPlainObj","Object","prototype","toString","call","isCollectionType","target","isNormalType","toArray","value","this","ArraySet","item","has","push","indexOf","batchDeleting","index","splice","callback","length","len","ProxyRaw","RawProxy","RawShallowProxy","RawNode","RawReactionsMap","ReactionStack","BatchCount","UntrackCount","BatchScope","DependencyCollected","PendingReactions","PendingScopeReactions","BatchEndpoints","MakeObservableSymbol","Symbol","ObserverListeners","ITERATION_KEY","getReactionsFromTargetKey","key","reactionsMap","get","reactions","map","forEach","reaction","runReactions","prevUntrackCount","i","_isComputed","_scheduler","isScopeBatching","add","isBatching","bindTargetKeyWithCurrentReaction","operation","type","current","isUntracking","bindSet","_reactionsSet","addReactionsMapToReaction","set","reactionsMap_1","addRawReactionsMap","runReactionsFromTargetKey","oldTarget","batchStart","fn","notifyObservers","_","newKey","batchEnd","releaseBindingReactions","delete","disposeBindingReactions","_disposed","_computesSet","_context","_property","_dirty","suspendComputedReactions","executePendingReactions","executeBatchEndpoints","batchScopeStart","batchScopeEnd","forEachDelete","untrackStart","untrackEnd","hasDepsChange","newDeps","oldDeps","some","RAW_TYPE","OBSERVABLE_TYPE","hasOwnProperty","isObservable","isAnnotation","isSupportObservable","wellKnownSymbols","getOwnPropertyNames","filter","findObservable","observableObj","createObservable","patchIterator","iterator","isEntries","originalNext","next","_a","done","instrumentations","proto","Reflect","getPrototypeOf","apply","arguments","hadKey","result","oldValue","undefined","clear","hadItems","size","cb","_i","args","wrappedCb","keys","values","entries","collectionHandlers","receiver","baseHandlers","observableResult","descriptor","getOwnPropertyDescriptor","writable","configurable","ownKeys","newValue","deleteProperty","node","object","path","concat","DataNode","parent","targetRaw","isEqual","buildDataTree","currentNode","createNormalProxy","shallow","proxy","Proxy","createCollectionProxy","raw","parentRaw","createShallowProxy","createAnnotation","maker","annotation","getObservableMaker","createBoundaryFunction","start","end","boundary","results","bound","createBindFunction","context","createBoundaryAnnotation","batch","scope","endpoint","action","untracked","observable","store","defineProperty","enumerable","box","ref","property","computed","getter","getGetter","setter","getSetter","compute","pop","computes","bindComputedReactions","_name","define","annotations","annotations.box","annotations.ref","deep","annotations.observable","annotations.shallow","annotations.computed","autorun","tracker","name","_boundary","_memos","cursor","_effects","cleanRefs","queue","dispose","disposeEffects","memo","dependencies","Error","deps","id","old","effect","effects","Promise","resolve","then","scheduler","_this","track","propertyRaw","targetNode","propertyNode","contains","reduce","buf","observer","listener","DataChange","addListener","subscriber","options","realOptions","fireAction","currentValue","looping","equals","fireImmediately","visited","_toJS","res_1","res"],"mappings":"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"}
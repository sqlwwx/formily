{"version":3,"file":"formily.validator.umd.development.js","sources":["../src/types.ts","../src/registry.ts","../src/template.ts","../src/parser.ts","../src/locale.ts","../src/formats.ts","../src/rules.ts","../src/validator.ts"],"sourcesContent":["export type ValidatorFormats =\n  | 'url'\n  | 'email'\n  | 'ipv6'\n  | 'ipv4'\n  | 'number'\n  | 'integer'\n  | 'idcard'\n  | 'qq'\n  | 'phone'\n  | 'money'\n  | 'zh'\n  | 'date'\n  | 'zip'\n  | (string & {})\n\nexport interface IValidateResult {\n  type: 'error' | 'warning' | 'success' | (string & {})\n  message: string\n}\n\nexport interface IValidateResults {\n  error?: string[]\n  warning?: string[]\n  success?: string[]\n}\n\nexport const isValidateResult = (obj: any): obj is IValidateResult =>\n  !!obj['type'] && !!obj['message']\n\nexport type ValidatorFunctionResponse =\n  | null\n  | string\n  | boolean\n  | IValidateResult\n\nexport type ValidatorFunction<Context = any> = (\n  value: any,\n  rule: IValidatorRules<Context>,\n  ctx: Context,\n  render: (message: string, scope?: any) => string\n) => ValidatorFunctionResponse | Promise<ValidatorFunctionResponse> | null\n\nexport type ValidatorParsedFunction<Context = any> = (\n  value: any,\n  ctx: Context\n) => IValidateResult | Promise<IValidateResult> | null\n\nexport type ValidatorTriggerType =\n  | 'onInput'\n  | 'onFocus'\n  | 'onBlur'\n  | (string & {})\n\nexport interface IValidatorRules<Context = any> {\n  triggerType?: ValidatorTriggerType\n  format?: ValidatorFormats\n  validator?: ValidatorFunction<Context>\n  required?: boolean\n  pattern?: RegExp | string\n  max?: number\n  maximum?: number\n  maxItems?: number\n  minItems?: number\n  maxLength?: number\n  minLength?: number\n  exclusiveMaximum?: number\n  exclusiveMinimum?: number\n  minimum?: number\n  min?: number\n  len?: number\n  whitespace?: boolean\n  enum?: any[]\n  const?: any\n  multipleOf?: number\n  uniqueItems?: boolean\n  maxProperties?: number\n  minProperties?: number\n  message?: string\n  [key: string]: any\n}\n\nexport interface IRegistryLocaleMessages {\n  [key: string]: string | IRegistryLocaleMessages\n}\n\nexport interface IRegistryLocales {\n  [language: string]: IRegistryLocaleMessages\n}\n\nexport interface IRegistryRules<Context = any> {\n  [key: string]: ValidatorFunction<Context>\n}\n\nexport interface IRegistryFormats {\n  [key: string]: string | RegExp\n}\n\nexport type ValidatorDescription<Context = any> =\n  | ValidatorFormats\n  | ValidatorFunction<Context>\n  | IValidatorRules<Context>\n\nexport type MultiValidator<Context = any> = ValidatorDescription<Context>[]\n\nexport type Validator<Context = any> =\n  | ValidatorDescription<Context>\n  | MultiValidator<Context>\n\nexport interface IValidatorOptions<Context = any> {\n  validateFirst?: boolean\n  triggerType?: ValidatorTriggerType\n  context?: Context\n}\n","import {\n  FormPath,\n  each,\n  lowerCase,\n  globalThisPolyfill,\n  merge as deepmerge,\n  isFn,\n  isStr,\n} from '@formily/shared'\nimport {\n  ValidatorFunctionResponse,\n  ValidatorFunction,\n  IRegistryFormats,\n  IRegistryLocaleMessages,\n  IRegistryLocales,\n  IRegistryRules,\n} from './types'\n\nconst getIn = FormPath.getIn\n\nconst self: any = globalThisPolyfill\n\nconst defaultLanguage = 'en'\n\nconst getBrowserlanguage = () => {\n  /* istanbul ignore next */\n  if (!self.navigator) {\n    return defaultLanguage\n  }\n  return (\n    self.navigator.browserlanguage || self.navigator.language || defaultLanguage\n  )\n}\n\nconst registry = {\n  locales: {\n    messages: {},\n    language: getBrowserlanguage(),\n  },\n  formats: {},\n  rules: {},\n  template: null,\n}\n\nconst getISOCode = (language: string) => {\n  let isoCode = registry.locales.language\n  const lang = lowerCase(language)\n  if (registry.locales.messages[language]) {\n    return language\n  }\n  each(\n    registry.locales.messages,\n    (messages: IRegistryLocaleMessages, key: string) => {\n      const target = lowerCase(key)\n      if (target.indexOf(lang) > -1 || lang.indexOf(target) > -1) {\n        isoCode = key\n        return false\n      }\n    }\n  )\n  return isoCode\n}\n\nexport const getValidateLocaleIOSCode = getISOCode\n\nexport const setValidateLanguage = (lang: string) => {\n  registry.locales.language = lang || defaultLanguage\n}\n\nexport const getValidateLanguage = () => registry.locales.language\n\nexport const getLocaleByPath = (path: string, lang: string = registry.locales.language) => getIn(\n  registry.locales.messages,\n  `${getISOCode(lang)}.${path}`\n)\n\n\nexport const getValidateLocale = (path: string) => {\n  const message = getLocaleByPath(path);\n  return message || getLocaleByPath('pattern') || getLocaleByPath('pattern', defaultLanguage)\n}\n\nexport const getValidateMessageTemplateEngine = () => registry.template\n\nexport const getValidateFormats = (key?: string) =>\n  key ? registry.formats[key] : registry.formats\n\nexport const getValidateRules = <T>(\n  key?: T\n): T extends string\n  ? ValidatorFunction\n  : { [key: string]: ValidatorFunction } =>\n  key ? registry.rules[key as any] : registry.rules\n\nexport const registerValidateLocale = (locale: IRegistryLocales) => {\n  registry.locales.messages = deepmerge(registry.locales.messages, locale)\n}\n\nexport const registerValidateRules = (rules: IRegistryRules) => {\n  each(rules, (rule, key) => {\n    if (isFn(rule)) {\n      registry.rules[key] = rule\n    }\n  })\n}\n\nexport const registerValidateFormats = (formats: IRegistryFormats) => {\n  each(formats, (pattern, key) => {\n    if (isStr(pattern) || pattern instanceof RegExp) {\n      registry.formats[key] = new RegExp(pattern)\n    }\n  })\n}\n\nexport const registerValidateMessageTemplateEngine = (\n  template: (message: ValidatorFunctionResponse, context: any) => any\n) => {\n  registry.template = template\n}\n","import { isFn, isStr, FormPath } from '@formily/shared'\nimport { IValidateResult, IValidatorRules } from './types'\nimport { getValidateMessageTemplateEngine } from './registry'\n\nexport const render = (\n  result: IValidateResult,\n  rules: IValidatorRules\n): IValidateResult => {\n  const { message } = result\n  if (isStr(result.message)) {\n    const template = getValidateMessageTemplateEngine()\n    if (isFn(template)) {\n      result.message = template(message, rules)\n    }\n    result.message = result.message.replace(\n      /\\{\\{\\s*([\\w.]+)\\s*\\}\\}/g,\n      (_, $0) => {\n        return FormPath.getIn(rules, $0)\n      }\n    )\n  }\n  return result\n}\n","import { isArr, isBool, isFn, isStr } from '@formily/shared'\nimport {\n  ValidatorDescription,\n  ValidatorFunction,\n  ValidatorParsedFunction,\n  Validator,\n  IValidatorRules,\n  isValidateResult,\n  IValidatorOptions,\n} from './types'\nimport { getValidateRules, getValidateLocale } from './registry'\nimport { render } from './template'\n\nconst getRuleMessage = (rule: IValidatorRules, type: string) => {\n  if (rule.format) {\n    return rule.message || getValidateLocale(rule.format)\n  }\n  return rule.message || getValidateLocale(type)\n}\n\nexport const parseValidatorDescription = (\n  description: ValidatorDescription\n): IValidatorRules => {\n  let rules: IValidatorRules = {}\n  if (isStr(description)) {\n    rules.format = description\n  } else if (isFn(description)) {\n    rules.validator = description\n  } else {\n    rules = Object.assign(rules, description)\n  }\n  rules.triggerType = rules.triggerType || 'onInput'\n  return rules\n}\n\nexport const parseValidatorDescriptions = <Context = any>(\n  validator: Validator<Context>\n): IValidatorRules[] => {\n  const array = isArr(validator) ? validator : [validator]\n  return array.map((description) => {\n    return parseValidatorDescription(description)\n  })\n}\n\nexport const parseValidatorRules = (\n  rules: IValidatorRules = {}\n): ValidatorParsedFunction[] => {\n  const getRulesKeys = (): string[] => {\n    const keys = []\n    if ('required' in rules) {\n      keys.push('required')\n    }\n    for (let key in rules) {\n      if (key === 'required' || key === 'validator') continue\n      keys.push(key)\n    }\n    if ('validator' in rules) {\n      keys.push('validator')\n    }\n    return keys\n  }\n  const getContext = (context: any, value: any) => {\n    return {\n      ...rules,\n      ...context,\n      value,\n    }\n  }\n  const createValidate =\n    (callback: ValidatorFunction, message: string) =>\n    async (value: any, context: any) => {\n      const context_ = getContext(context, value)\n      try {\n        const results = await callback(\n          value,\n          { ...rules, message },\n          context_,\n          (message: string, scope: any) => {\n            return render(\n              {\n                type: 'error',\n                message,\n              },\n              Object.assign(context_, scope)\n            )?.message\n          }\n        )\n        if (isBool(results)) {\n          if (!results) {\n            return render(\n              {\n                type: 'error',\n                message,\n              },\n              context_\n            )\n          }\n          return {\n            type: 'error',\n            message: undefined,\n          }\n        } else if (results) {\n          if (isValidateResult(results)) {\n            return render(results, context_)\n          }\n          return render(\n            {\n              type: 'error',\n              message: results,\n            },\n            context_\n          )\n        }\n\n        return {\n          type: 'error',\n          message: undefined,\n        }\n      } catch (e) {\n        return {\n          type: 'error',\n          message: e?.message || e,\n        }\n      }\n    }\n  return getRulesKeys().reduce((buf, key) => {\n    const callback = getValidateRules(key)\n    if (callback) {\n      const validator = createValidate(callback, getRuleMessage(rules, key))\n      return buf.concat(validator)\n    }\n    return buf\n  }, [])\n}\n\nexport const parseValidator = <Context = any>(\n  validator: Validator<Context>,\n  options: IValidatorOptions = {}\n) => {\n  const array = isArr(validator) ? validator : [validator]\n  return array.reduce<ValidatorParsedFunction<Context>[]>(\n    (buf, description) => {\n      const rules = parseValidatorDescription(description)\n      if (options?.triggerType && options.triggerType !== rules.triggerType)\n        return buf\n      return rules ? buf.concat(parseValidatorRules(rules)) : buf\n    },\n    []\n  )\n}\n","export default {\n  en: {\n    pattern: 'This field is invalid',\n    invalid: 'This field is invalid',\n    required: 'The field value is required',\n    number: 'The field value is not a number',\n    integer: 'The field value is not an integer number',\n    url: 'The field value is a invalid url',\n    email: 'The field value is not a email format',\n    ipv6: 'The field value is not a ipv6 format',\n    ipv4: 'The field value is not a ipv4 format',\n    idcard: 'The field value is not an idcard format',\n    qq: 'The field value is not a qq number format',\n    phone: 'The field value is not a phone number format',\n    money: 'The field value is not a currency format',\n    zh: 'The field value is not a chinese string',\n    date: 'The field value is not a valid date format',\n    zip: 'The field value is not a zip format',\n    len: 'The length or number of entries must be {{len}}',\n    min: 'The length or number of entries must be at least {{min}}',\n    minLength: 'The length or number of entries must be at least {{minLength}}',\n    minItems: 'The length or number of entries must be at least {{minItems}}',\n    maximum: 'The field value cannot be greater than {{maximum}}',\n    exclusiveMaximum: 'The field value must be less than {{exclusiveMaximum}}',\n    minimum: 'The field value cannot be less than {{minimum}}',\n    exclusiveMinimum:\n      'The field value must be greater than {{exclusiveMinimum}}',\n    max: 'The field length or number of entries must be at most {{max}}',\n    maxLength:\n      'The field length or number of entries must be at most {{maxLength}}',\n    maxItems:\n      'The field length or number of entries must be at most {{maxItems}}',\n    whitespace: 'This field value cannot be blank string.',\n    enum: 'The field value must be one of {{enum}}',\n\n    const: 'The field value must be equal to {{const}}',\n    multipleOf: 'The field value must be divisible by {{multipleOf}}',\n    maxProperties:\n      'The number of field properties cannot be greater than {{maxProperties}}',\n    minProperties:\n      'The number of field properties cannot be less than {{maxProperties}}',\n    uniqueItems: 'Array elements are not unique',\n  },\n  zh: {\n    pattern: '该字段不是一个合法的字段',\n    invalid: '该字段不是一个合法的字段',\n    required: '该字段是必填字段',\n    number: '该字段不是合法的数字',\n    integer: '该字段不是合法的整型数字',\n    url: '该字段不是合法的url',\n    email: '该字段不是合法的邮箱格式',\n    ipv6: '该字段不是合法的ipv6格式',\n    ipv4: '该字段不是合法的ipv4格式',\n    idcard: '该字段不是合法的身份证格式',\n    qq: '该字段不符合QQ号格式',\n    phone: '该字段不是有效的手机号',\n    money: '该字段不是有效货币格式',\n    zh: '该字段不是合法的中文字符串',\n    date: '该字段不是合法的日期格式',\n    zip: '该字段不是合法的邮编格式',\n    len: '长度或条目数必须为{{len}}',\n    min: '长度或条目数不能小于{{min}}',\n    minLength: '长度或条目数不能小于{{minLength}}',\n    minItems: '长度或条目数不能小于{{minItems}}',\n    max: '长度或条目数不能大于{{max}}',\n    maxLength: '长度或条目数不能大于{{maxLength}}',\n    maxItems: '长度或条目数不能大于{{maxItems}}',\n    maximum: '数值不能大于{{maximum}}',\n    exclusiveMaximum: '数值必须小于{{exclusiveMaximum}}',\n    minimum: '数值不能小于{{minimum}}',\n    exclusiveMinimum: '数值必须大于{{exclusiveMinimum}}',\n    whitespace: '不能为纯空白字符串',\n    enum: '字段值必须为{{enum}}其中一个',\n    const: '字段值必须等于{{const}}',\n    multipleOf: '字段值不能被{{multipleOf}}整除',\n    maxProperties: '字段属性数量不能大于{{maxProperties}}',\n    minProperties: '字段属性数量不能小于{{minProperties}}',\n    uniqueItems: '数组元素不唯一',\n  },\n  'en-US': {\n    pattern: 'This field is invalid',\n    invalid: 'This field is invalid',\n    required: 'The field value is required',\n    number: 'The field value is not a number',\n    integer: 'The field value is not an integer number',\n    url: 'The field value is a invalid url',\n    email: 'The field value is not a email format',\n    ipv6: 'The field value is not a ipv6 format',\n    ipv4: 'The field value is not a ipv4 format',\n    idcard: 'The field value is not an idcard format',\n    qq: 'The field value is not a qq number format',\n    phone: 'The field value is not a phone number format',\n    money: 'The field value is not a currency format',\n    zh: 'The field value is not a chinese string',\n    date: 'The field value is not a valid date format',\n    zip: 'The field value is not a zip format',\n    len: 'The length or number of entries must be {{len}}',\n    min: 'The length or number of entries must be at least {{min}}',\n    minLength: 'The length or number of entries must be at least {{minLength}}',\n    minItems: 'The length or number of entries must be at least {{minItems}}',\n    maximum: 'The field value cannot be greater than {{maximum}}',\n    exclusiveMaximum: 'The field value must be less than {{exclusiveMaximum}}',\n    minimum: 'The field value cannot be less than {{minimum}}',\n    exclusiveMinimum:\n      'The field value must be greater than {{exclusiveMinimum}}',\n    max: 'The field length or number of entries must be at most {{max}}',\n    maxLength:\n      'The field length or number of entries must be at most {{maxLength}}',\n    maxItems:\n      'The field length or number of entries must be at most {{maxItems}}',\n    whitespace: 'This field value cannot be blank string.',\n    enum: 'The field value must be one of {{enum}}',\n    const: 'The field value must be equal to {{const}}',\n    multipleOf: 'The field value must be divisible by {{multipleOf}}',\n    maxProperties:\n      'The number of field properties cannot be greater than {{maxProperties}}',\n    minProperties:\n      'The number of field properties cannot be less than {{maxProperties}}',\n    uniqueItems: 'Array elements are not unique',\n  },\n  'zh-CN': {\n    pattern: '该字段不是一个合法的字段',\n    invalid: '该字段不是一个合法的字段',\n    required: '该字段是必填字段',\n    number: '该字段不是合法的数字',\n    integer: '该字段不是合法的整型数字',\n    url: '该字段不是合法的url',\n    email: '该字段不是合法的邮箱格式',\n    ipv6: '该字段不是合法的ipv6格式',\n    ipv4: '该字段不是合法的ipv4格式',\n    idcard: '该字段不是合法的身份证格式',\n    qq: '该字段不符合QQ号格式',\n    phone: '该字段不是有效的手机号',\n    money: '该字段不是有效货币格式',\n    zh: '该字段不是合法的中文字符串',\n    date: '该字段不是合法的日期格式',\n    zip: '该字段不是合法的邮编格式',\n    len: '长度或条目数必须为{{len}}',\n    min: '长度或条目数不能小于{{min}}',\n    minLength: '长度或条目数不能小于{{minLength}}',\n    minItems: '长度或条目数不能小于{{minItems}}',\n    maxLength: '长度或条目数不能大于{{maxLength}}',\n    maxItems: '长度或条目数不能大于{{maxItems}}',\n    max: '长度或条目数不能大于{{max}}',\n    maximum: '数值不能大于{{maximum}}',\n    exclusiveMaximum: '数值必须小于{{exclusiveMaximum}}',\n    minimum: '数值不能小于{{minimum}}',\n    exclusiveMinimum: '数值必须大于{{exclusiveMinimum}}',\n    whitespace: '不能为纯空白字符串',\n    enum: '字段值必须为{{enum}}其中一个',\n    const: '字段值必须等于{{const}}',\n    multipleOf: '字段值不能被{{multipleOf}}整除',\n    maxProperties: '字段属性数量不能大于{{maxProperties}}',\n    minProperties: '字段属性数量不能小于{{minProperties}}',\n    uniqueItems: '数组元素不唯一',\n  },\n  'zh-TW': {\n    pattern: '該字段不是一個合法的字段',\n    invalid: '該字段不是一個合法的字段',\n    required: '該字段是必填字段',\n    number: '該字段不是合法的數字',\n    integer: '該字段不是合法的整型數字',\n    url: '該字段不是合法的url',\n    email: '該字段不是合法的郵箱格式',\n    ipv6: '該字段不是合法的ipv6格式',\n    ipv4: '該字段不是合法的ipv4格式',\n    idcard: '該字段不是合法的身份證格式',\n    qq: '該字段不符合QQ號格式',\n    phone: '該字段不是有效的手機號',\n    money: '該字段不是有效貨幣格式',\n    zh: '該字段不是合法的中文字符串',\n    date: '該字段不是合法的日期格式',\n    zip: '該字段不是合法的郵編格式',\n    len: '長度或條目數必須為{{len}}',\n    min: '長度或條目數不能小於{{min}}',\n    minItems: '長度或條目數不能小於{{minItems}}',\n    minLength: '長度或條目數不能小於{{minLength}}',\n    max: '長度或條目數不能大於{{max}}',\n    maxItems: '長度或條目數不能大於{{maxItems}}',\n    maxLength: '長度或條目數不能大於{{maxLength}}',\n    maximum: '數值不能大於{{maximum}}',\n    exclusiveMaximum: '數值必須小於{{exclusiveMaximum}}',\n    minimum: '數值不能小於{{minimum}}',\n    exclusiveMinimum: '數值必須大於{{exclusiveMinimum}}',\n    whitespace: '不能為純空白字符串',\n    enum: '字段值必須為{{enum}}其中一個',\n    const: '字段值必須等於{{const}}',\n    multipleOf: '字段值不能被{{multipleOf}}整除',\n    maxProperties: '字段屬性數量不能大於{{maxProperties}}',\n    minProperties: '字段屬性數量不能小於{{minProperties}}',\n    uniqueItems: '數組元素不唯一',\n  },\n  ja: {\n    url: 'このフィールドは無効なURLです',\n    whitespace: 'このフィールドを空の文字列にすることはできません。',\n    zh: 'このフィールドは中国語の文字列ではありません',\n    zip: 'このフィールドはzip形式ではありません',\n    date: 'このフィールドは有効な日付形式ではありません',\n    email: 'このフィールドはメール形式ではありません',\n    exclusiveMaximum: '値は{{exclusiveMaximum}}未満である必要があります',\n    exclusiveMinimum: '値は{{exclusiveMinimum}}より大きい必要があります',\n    idcard: 'このフィールドはIDカード形式ではありません',\n    integer: 'このフィールドは整数ではありません',\n    ipv4: 'このフィールドはIPv4形式ではありません',\n    ipv6: 'このフィールドはIPv6形式ではありません',\n    len: 'エントリの長さまたは数は{{len}}でなければなりません',\n    max: 'エントリの長さまたは数は最大{{max}}でなければなりません',\n    maxItems: 'エントリの長さまたは数は最大{{maxItems}}でなければなりません',\n    maxLength: 'エントリの長さまたは数は最大{{maxLength}}でなければなりません',\n    maximum: '値は{{最大}}を超えることはできません',\n    min: 'エントリの長さまたは数は、少なくとも{{min}}である必要があります',\n    minItems:\n      'エントリの長さまたは数は、少なくとも{{minItems}}である必要があります',\n    minLength:\n      'エントリの長さまたは数は、少なくとも{{minLength}}である必要があります',\n    minimum: '値は{{minimum}}以上にする必要があります',\n    money: 'このフィールドは通貨形式ではありません',\n    number: 'このフィールドは数値ではありません',\n    pattern: 'このフィールドはどのパターンとも一致しません',\n    invalid: 'このフィールドはどのパターンとも一致しません',\n    phone: 'このフィールドは電話番号の形式ではありません',\n    qq: 'このフィールドはqq数値形式ではありません',\n    required: 'この項目は必須です',\n    enum: 'フィールド値は{{enum}}のいずれかである必要があります',\n    cons: 'フィールド値は{{const}}と等しくなければなりません',\n    multipleOf: 'フィールド値を{{multipleOf}}で割り切れない',\n    maxProperties:\n      'フィールドプロパティの数は{{maxProperties}}を超えることはできません',\n    minProperties:\n      'フィールドプロパティの数は{{minProperties}}未満にすることはできません',\n    uniqueItems: '配列要素は一意ではありません',\n  },\n}\n","export default {\n  url: new RegExp(\n    // protocol identifier\n    '^(?:(?:(?:https?|ftp|rtmp):)?//)' +\n      // user:pass authentication\n      '(?:\\\\S+(?::\\\\S*)?@)?' +\n      '(?:' +\n      // IP address exclusion - private & local networks\n      // Reference: https://www.arin.net/knowledge/address_filters.html\n\n      // filter 10.*.*.* and 127.*.*.* adresses\n      '(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})' +\n      // filter 169.254.*.* and 192.168.*.*\n      '(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})' +\n      // filter 172.16.0.0 - 172.31.255.255\n      // TODO: add test to validate that it invalides address in 16-31 range\n      '(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})' +\n      // IP address dotted notation octets\n      // excludes loopback network 0.0.0.0\n      // excludes reserved space >= 224.0.0.0\n      // excludes network & broacast addresses\n      // (first & last IP address of each class)\n\n      // filter 1. part for 1-223\n      '(?:22[0-3]|2[01]\\\\d|[1-9]\\\\d?|1\\\\d\\\\d)' +\n      // filter 2. and 3. part for 0-255\n      '(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1?\\\\d{1,2})){2}' +\n      // filter 4. part for 1-254\n      '(?:\\\\.(?:25[0-4]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d?))' +\n      '|' +\n      // host name\n      '(?:(?:[a-z\\\\u00a1-\\\\uffff0-9_]-*)*[a-z\\\\u00a1-\\\\uffff0-9_]+)' +\n      // domain name\n      '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9_]-*)*[a-z\\\\u00a1-\\\\uffff0-9_]+)*' +\n      // TLD identifier\n      '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff_]{2,}))' +\n      ')' +\n      // port number\n      '(?::\\\\d{2,5})?' +\n      // resource path\n      '(?:/?\\\\S*)?$'\n  ),\n  email: /^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/,\n\n  ipv6: /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/,\n\n  ipv4: /^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})$/,\n\n  number: /^[+-]?\\d+(\\.\\d+)?$/,\n\n  integer: /^[+-]?\\d+$/,\n\n  qq: /^(\\+?[1-9]\\d*|0)$/,\n\n  phone: /^\\d{3}-\\d{8}$|^\\d{4}-\\d{7}$|^\\d{11}$/,\n\n  idcard: /^\\d{15}$|^\\d{17}(\\d|x|X)$/,\n\n  money:\n    /^([\\u0024\\u00A2\\u00A3\\u00A4\\u20AC\\u00A5\\u20B1\\20B9\\uFFE5]\\s*)(\\d+,?)+\\.?\\d*\\s*$/,\n\n  zh: /^[\\u4e00-\\u9fa5]+$/,\n\n  date: /^[0-9]+[./-][0-9]+[./-][0-9]+\\s*(?:[0-9]+\\s*:\\s*[0-9]+\\s*:\\s*[0-9]+)?$/,\n\n  zip: /^[0-9]{6}$/,\n}\n","import {\n  isEmpty,\n  isValid,\n  stringLength,\n  isStr,\n  isArr,\n  isFn,\n  toArr,\n  isBool,\n  isNum,\n  isEqual,\n  each,\n} from '@formily/shared'\nimport { getValidateFormats } from './registry'\nimport { IRegistryRules } from './types'\n\nconst isValidateEmpty = (value: any) => {\n  if (isArr(value)) {\n    for (let i = 0; i < value.length; i++) {\n      if (isValid(value[i])) return false\n    }\n    return true\n  } else {\n    //compat to draft-js\n    if (value?.getCurrentContent) {\n      /* istanbul ignore next */\n      return !value.getCurrentContent()?.hasText()\n    }\n    return isEmpty(value)\n  }\n}\n\nconst getLength = (value: any) =>\n  isStr(value) ? stringLength(value) : value ? value.length : 0\n\nconst extendSameRules = (\n  rules: IRegistryRules,\n  names: Record<string, string>\n) => {\n  each(names, (realName, name) => {\n    rules[name] = (value, rule, ...args) =>\n      rules[realName](value, { ...rule, [realName]: rule[name] }, ...args)\n  })\n}\n\nconst RULES: IRegistryRules = {\n  format(value, rule) {\n    if (isValidateEmpty(value)) return ''\n    return !new RegExp(getValidateFormats(rule.format) || '').test(value)\n      ? rule.message\n      : ''\n  },\n  required(value, rule) {\n    if (rule.required === false) return ''\n    return isValidateEmpty(value) ? rule.message : ''\n  },\n  max(value, rule) {\n    if (isValidateEmpty(value)) return ''\n    const length = isNum(value) ? value : getLength(value)\n    const max = Number(rule.max)\n    return length > max ? rule.message : ''\n  },\n  min(value, rule) {\n    if (isValidateEmpty(value)) return ''\n    const length = isNum(value) ? value : getLength(value)\n    const min = Number(rule.min)\n    return length < min ? rule.message : ''\n  },\n  exclusiveMaximum(value, rule) {\n    if (isValidateEmpty(value)) return ''\n    const length = isNum(value) ? value : getLength(value)\n    const max = Number(rule.exclusiveMaximum)\n    return length >= max ? rule.message : ''\n  },\n  exclusiveMinimum(value, rule) {\n    if (isValidateEmpty(value)) return ''\n    const length = isNum(value) ? value : getLength(value)\n    const min = Number(rule.exclusiveMinimum)\n    return length <= min ? rule.message : ''\n  },\n  len(value, rule) {\n    if (isValidateEmpty(value)) return ''\n    const length = getLength(value)\n    const len = Number(rule.len)\n    return length !== len ? rule.message : ''\n  },\n\n  pattern(value, rule) {\n    if (isValidateEmpty(value)) return ''\n    return !new RegExp(rule.pattern).test(value) ? rule.message : ''\n  },\n  async validator(value, rule, context, format) {\n    if (isFn(rule.validator)) {\n      const response = await Promise.resolve(\n        rule.validator(value, rule, context, format)\n      )\n      if (isBool(response)) {\n        return !response ? rule.message : ''\n      } else {\n        return response\n      }\n    }\n    /* istanbul ignore next */\n    throw new Error(\"The rule's validator property must be a function.\")\n  },\n  whitespace(value, rule) {\n    if (isValidateEmpty(value)) return ''\n    if (rule.whitespace) {\n      return /^\\s+$/.test(value) ? rule.message : ''\n    }\n  },\n  enum(value, rule) {\n    if (isValidateEmpty(value)) return ''\n    const enums = toArr(rule.enum)\n    return enums.indexOf(value) === -1 ? rule.message : ''\n  },\n  const(value, rule) {\n    if (isValidateEmpty(value)) return ''\n    return rule.const !== value ? rule.message : ''\n  },\n  multipleOf(value, rule) {\n    if (isValidateEmpty(value)) return ''\n    return Number(value) % Number(rule.multipleOf) !== 0 ? rule.message : ''\n  },\n  uniqueItems(value, rule) {\n    if (isValidateEmpty(value)) return ''\n    value = toArr(value)\n    return value.some((item: any, index: number) => {\n      for (let i = 0; i < value.length; i++) {\n        if (i !== index && !isEqual(value[i], item)) {\n          return false\n        }\n      }\n      return true\n    })\n      ? ''\n      : rule.message\n  },\n  maxProperties(value, rule) {\n    if (isValidateEmpty(value)) return ''\n    return Object.keys(value || {}).length <= Number(rule.maxProperties)\n      ? ''\n      : rule.message\n  },\n  minProperties(value, rule) {\n    if (isValidateEmpty(value)) return ''\n    return Object.keys(value || {}).length >= Number(rule.minProperties)\n      ? ''\n      : rule.message\n  },\n}\n\nextendSameRules(RULES, {\n  maximum: 'max',\n  minimum: 'min',\n  maxItems: 'max',\n  minItems: 'min',\n  maxLength: 'max',\n  minLength: 'min',\n})\n\nexport default RULES\n","import { parseValidator } from './parser'\nimport { IValidateResults, Validator, IValidatorOptions } from './types'\nimport {\n  registerValidateFormats,\n  registerValidateLocale,\n  registerValidateRules,\n} from './registry'\nimport locales from './locale'\nimport formats from './formats'\nimport rules from './rules'\n\nregisterValidateRules(rules)\n\nregisterValidateLocale(locales)\n\nregisterValidateFormats(formats)\n\nexport const validate = async <Context = any>(\n  value: any,\n  validator: Validator<Context>,\n  options?: IValidatorOptions<Context>\n): Promise<IValidateResults> => {\n  const validates = parseValidator(validator, options)\n  const results: IValidateResults = {\n    error: [],\n    success: [],\n    warning: [],\n  }\n  for (let i = 0; i < validates.length; i++) {\n    const result = await validates[i](value, options?.context)\n    const { type, message } = result\n    results[type] = results[type] || []\n    if (message) {\n      results[type].push(message)\n      if (options?.validateFirst) break\n    }\n  }\n  return results\n}\n"],"names":["rules"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QA2Ba,gBAAgB,GAAG,UAAC,GAAQ;QACvC,OAAA,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC;IAAjC;;ICVF,YAAc,uBAAQ;IAEtB,WAAkB,iCAAkB;IAEpC;IAEA;;;;;;IAQA;IAEA;;;;;;;;;IAUA;;mBAEe,wBAAS;;;;QAItB,mBAAI;yBAGe,wBAAS;;;;;;;IAQ9B;;;;IAMA;;;;;IAI2F;;;;IAS3F;;;;IAKE;;;IAOA;;oCAG4B,oBAAS;IACvC;;QAGE,mBAAI;gBACE,mBAAI;;;;IAIZ;;QAGE,mBAAI;gBACE,oBAAK;;;;IAIb;;;IAMA;;;;YC7GM,oBAAK;;gBAEH,mBAAI;;;;uBAMG,uBAAQ;;;;IAKvB;;ICTA;;;;;IAKA;;;YAMM,oBAAK;;;iBAEE,mBAAI;;;;;;;;IAOjB;;oBAKgB,oBAAK;;;;IAIrB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gCA6CY,qBAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA8ClB;;;oBAMgB,oBAAK;;;;;;;IAUrB;;ACrJA,kBAAe;QACb,EAAE,EAAE;YACF,OAAO,EAAE,uBAAuB;YAChC,OAAO,EAAE,uBAAuB;YAChC,QAAQ,EAAE,6BAA6B;YACvC,MAAM,EAAE,iCAAiC;YACzC,OAAO,EAAE,0CAA0C;YACnD,GAAG,EAAE,kCAAkC;YACvC,KAAK,EAAE,uCAAuC;YAC9C,IAAI,EAAE,sCAAsC;YAC5C,IAAI,EAAE,sCAAsC;YAC5C,MAAM,EAAE,yCAAyC;YACjD,EAAE,EAAE,2CAA2C;YAC/C,KAAK,EAAE,8CAA8C;YACrD,KAAK,EAAE,0CAA0C;YACjD,EAAE,EAAE,yCAAyC;YAC7C,IAAI,EAAE,4CAA4C;YAClD,GAAG,EAAE,qCAAqC;YAC1C,GAAG,EAAE,iDAAiD;YACtD,GAAG,EAAE,0DAA0D;YAC/D,SAAS,EAAE,gEAAgE;YAC3E,QAAQ,EAAE,+DAA+D;YACzE,OAAO,EAAE,oDAAoD;YAC7D,gBAAgB,EAAE,wDAAwD;YAC1E,OAAO,EAAE,iDAAiD;YAC1D,gBAAgB,EACd,2DAA2D;YAC7D,GAAG,EAAE,+DAA+D;YACpE,SAAS,EACP,qEAAqE;YACvE,QAAQ,EACN,oEAAoE;YACtE,UAAU,EAAE,0CAA0C;YACtD,IAAI,EAAE,yCAAyC;YAE/C,KAAK,EAAE,4CAA4C;YACnD,UAAU,EAAE,qDAAqD;YACjE,aAAa,EACX,yEAAyE;YAC3E,aAAa,EACX,sEAAsE;YACxE,WAAW,EAAE,+BAA+B;SAC7C;QACD,EAAE,EAAE;YACF,OAAO,EAAE,cAAc;YACvB,OAAO,EAAE,cAAc;YACvB,QAAQ,EAAE,UAAU;YACpB,MAAM,EAAE,YAAY;YACpB,OAAO,EAAE,cAAc;YACvB,GAAG,EAAE,aAAa;YAClB,KAAK,EAAE,cAAc;YACrB,IAAI,EAAE,gBAAgB;YACtB,IAAI,EAAE,gBAAgB;YACtB,MAAM,EAAE,eAAe;YACvB,EAAE,EAAE,aAAa;YACjB,KAAK,EAAE,aAAa;YACpB,KAAK,EAAE,aAAa;YACpB,EAAE,EAAE,eAAe;YACnB,IAAI,EAAE,cAAc;YACpB,GAAG,EAAE,cAAc;YACnB,GAAG,EAAE,kBAAkB;YACvB,GAAG,EAAE,mBAAmB;YACxB,SAAS,EAAE,yBAAyB;YACpC,QAAQ,EAAE,wBAAwB;YAClC,GAAG,EAAE,mBAAmB;YACxB,SAAS,EAAE,yBAAyB;YACpC,QAAQ,EAAE,wBAAwB;YAClC,OAAO,EAAE,mBAAmB;YAC5B,gBAAgB,EAAE,4BAA4B;YAC9C,OAAO,EAAE,mBAAmB;YAC5B,gBAAgB,EAAE,4BAA4B;YAC9C,UAAU,EAAE,WAAW;YACvB,IAAI,EAAE,oBAAoB;YAC1B,KAAK,EAAE,kBAAkB;YACzB,UAAU,EAAE,wBAAwB;YACpC,aAAa,EAAE,6BAA6B;YAC5C,aAAa,EAAE,6BAA6B;YAC5C,WAAW,EAAE,SAAS;SACvB;QACD,OAAO,EAAE;YACP,OAAO,EAAE,uBAAuB;YAChC,OAAO,EAAE,uBAAuB;YAChC,QAAQ,EAAE,6BAA6B;YACvC,MAAM,EAAE,iCAAiC;YACzC,OAAO,EAAE,0CAA0C;YACnD,GAAG,EAAE,kCAAkC;YACvC,KAAK,EAAE,uCAAuC;YAC9C,IAAI,EAAE,sCAAsC;YAC5C,IAAI,EAAE,sCAAsC;YAC5C,MAAM,EAAE,yCAAyC;YACjD,EAAE,EAAE,2CAA2C;YAC/C,KAAK,EAAE,8CAA8C;YACrD,KAAK,EAAE,0CAA0C;YACjD,EAAE,EAAE,yCAAyC;YAC7C,IAAI,EAAE,4CAA4C;YAClD,GAAG,EAAE,qCAAqC;YAC1C,GAAG,EAAE,iDAAiD;YACtD,GAAG,EAAE,0DAA0D;YAC/D,SAAS,EAAE,gEAAgE;YAC3E,QAAQ,EAAE,+DAA+D;YACzE,OAAO,EAAE,oDAAoD;YAC7D,gBAAgB,EAAE,wDAAwD;YAC1E,OAAO,EAAE,iDAAiD;YAC1D,gBAAgB,EACd,2DAA2D;YAC7D,GAAG,EAAE,+DAA+D;YACpE,SAAS,EACP,qEAAqE;YACvE,QAAQ,EACN,oEAAoE;YACtE,UAAU,EAAE,0CAA0C;YACtD,IAAI,EAAE,yCAAyC;YAC/C,KAAK,EAAE,4CAA4C;YACnD,UAAU,EAAE,qDAAqD;YACjE,aAAa,EACX,yEAAyE;YAC3E,aAAa,EACX,sEAAsE;YACxE,WAAW,EAAE,+BAA+B;SAC7C;QACD,OAAO,EAAE;YACP,OAAO,EAAE,cAAc;YACvB,OAAO,EAAE,cAAc;YACvB,QAAQ,EAAE,UAAU;YACpB,MAAM,EAAE,YAAY;YACpB,OAAO,EAAE,cAAc;YACvB,GAAG,EAAE,aAAa;YAClB,KAAK,EAAE,cAAc;YACrB,IAAI,EAAE,gBAAgB;YACtB,IAAI,EAAE,gBAAgB;YACtB,MAAM,EAAE,eAAe;YACvB,EAAE,EAAE,aAAa;YACjB,KAAK,EAAE,aAAa;YACpB,KAAK,EAAE,aAAa;YACpB,EAAE,EAAE,eAAe;YACnB,IAAI,EAAE,cAAc;YACpB,GAAG,EAAE,cAAc;YACnB,GAAG,EAAE,kBAAkB;YACvB,GAAG,EAAE,mBAAmB;YACxB,SAAS,EAAE,yBAAyB;YACpC,QAAQ,EAAE,wBAAwB;YAClC,SAAS,EAAE,yBAAyB;YACpC,QAAQ,EAAE,wBAAwB;YAClC,GAAG,EAAE,mBAAmB;YACxB,OAAO,EAAE,mBAAmB;YAC5B,gBAAgB,EAAE,4BAA4B;YAC9C,OAAO,EAAE,mBAAmB;YAC5B,gBAAgB,EAAE,4BAA4B;YAC9C,UAAU,EAAE,WAAW;YACvB,IAAI,EAAE,oBAAoB;YAC1B,KAAK,EAAE,kBAAkB;YACzB,UAAU,EAAE,wBAAwB;YACpC,aAAa,EAAE,6BAA6B;YAC5C,aAAa,EAAE,6BAA6B;YAC5C,WAAW,EAAE,SAAS;SACvB;QACD,OAAO,EAAE;YACP,OAAO,EAAE,cAAc;YACvB,OAAO,EAAE,cAAc;YACvB,QAAQ,EAAE,UAAU;YACpB,MAAM,EAAE,YAAY;YACpB,OAAO,EAAE,cAAc;YACvB,GAAG,EAAE,aAAa;YAClB,KAAK,EAAE,cAAc;YACrB,IAAI,EAAE,gBAAgB;YACtB,IAAI,EAAE,gBAAgB;YACtB,MAAM,EAAE,eAAe;YACvB,EAAE,EAAE,aAAa;YACjB,KAAK,EAAE,aAAa;YACpB,KAAK,EAAE,aAAa;YACpB,EAAE,EAAE,eAAe;YACnB,IAAI,EAAE,cAAc;YACpB,GAAG,EAAE,cAAc;YACnB,GAAG,EAAE,kBAAkB;YACvB,GAAG,EAAE,mBAAmB;YACxB,QAAQ,EAAE,wBAAwB;YAClC,SAAS,EAAE,yBAAyB;YACpC,GAAG,EAAE,mBAAmB;YACxB,QAAQ,EAAE,wBAAwB;YAClC,SAAS,EAAE,yBAAyB;YACpC,OAAO,EAAE,mBAAmB;YAC5B,gBAAgB,EAAE,4BAA4B;YAC9C,OAAO,EAAE,mBAAmB;YAC5B,gBAAgB,EAAE,4BAA4B;YAC9C,UAAU,EAAE,WAAW;YACvB,IAAI,EAAE,oBAAoB;YAC1B,KAAK,EAAE,kBAAkB;YACzB,UAAU,EAAE,wBAAwB;YACpC,aAAa,EAAE,6BAA6B;YAC5C,aAAa,EAAE,6BAA6B;YAC5C,WAAW,EAAE,SAAS;SACvB;QACD,EAAE,EAAE;YACF,GAAG,EAAE,kBAAkB;YACvB,UAAU,EAAE,2BAA2B;YACvC,EAAE,EAAE,wBAAwB;YAC5B,GAAG,EAAE,sBAAsB;YAC3B,IAAI,EAAE,wBAAwB;YAC9B,KAAK,EAAE,sBAAsB;YAC7B,gBAAgB,EAAE,oCAAoC;YACtD,gBAAgB,EAAE,oCAAoC;YACtD,MAAM,EAAE,wBAAwB;YAChC,OAAO,EAAE,mBAAmB;YAC5B,IAAI,EAAE,uBAAuB;YAC7B,IAAI,EAAE,uBAAuB;YAC7B,GAAG,EAAE,+BAA+B;YACpC,GAAG,EAAE,iCAAiC;YACtC,QAAQ,EAAE,sCAAsC;YAChD,SAAS,EAAE,uCAAuC;YAClD,OAAO,EAAE,sBAAsB;YAC/B,GAAG,EAAE,qCAAqC;YAC1C,QAAQ,EACN,0CAA0C;YAC5C,SAAS,EACP,2CAA2C;YAC7C,OAAO,EAAE,2BAA2B;YACpC,KAAK,EAAE,qBAAqB;YAC5B,MAAM,EAAE,mBAAmB;YAC3B,OAAO,EAAE,wBAAwB;YACjC,OAAO,EAAE,wBAAwB;YACjC,KAAK,EAAE,wBAAwB;YAC/B,EAAE,EAAE,uBAAuB;YAC3B,QAAQ,EAAE,WAAW;YACrB,IAAI,EAAE,gCAAgC;YACtC,IAAI,EAAE,+BAA+B;YACrC,UAAU,EAAE,8BAA8B;YAC1C,aAAa,EACX,4CAA4C;YAC9C,aAAa,EACX,6CAA6C;YAC/C,WAAW,EAAE,gBAAgB;SAC9B;KACF;;ACxOD,kBAAe;QACb,GAAG,EAAE,IAAI,MAAM;;QAEb,kCAAkC;;YAEhC,sBAAsB;YACtB,KAAK;;;;YAKL,kCAAkC;;YAElC,+CAA+C;;;YAG/C,oDAAoD;;;;;;;YAQpD,wCAAwC;;YAExC,4CAA4C;;YAE5C,gDAAgD;YAChD,GAAG;;YAEH,8DAA8D;;YAE9D,kEAAkE;;YAElE,sCAAsC;YACtC,GAAG;;YAEH,gBAAgB;;YAEhB,cAAc,CACjB;QACD,KAAK,EAAE,+CAA+C;QAEtD,IAAI,EAAE,yjCAAyjC;QAE/jC,IAAI,EAAE,+FAA+F;QAErG,MAAM,EAAE,oBAAoB;QAE5B,OAAO,EAAE,YAAY;QAErB,EAAE,EAAE,mBAAmB;QAEvB,KAAK,EAAE,sCAAsC;QAE7C,MAAM,EAAE,2BAA2B;QAEnC,KAAK,EACH,iFAAiF;QAEnF,EAAE,EAAE,oBAAoB;QAExB,IAAI,EAAE,wEAAwE;QAE9E,GAAG,EAAE,YAAY;KAClB;;IClDD;;YACM,oBAAK;;oBAED,sBAAO;;;;;;;;;;;mBASN,sBAAO;;IAElB;IAEA;eACE,oBAAK,UAAU,2BAAY;IAA3B;IAEF;QAIE,mBAAI;;;;;;;;;;IAIN;IAEA;;;;;;;;;;;;;;;;yBAamB,oBAAK;;;;;;;yBAML,oBAAK;;;;;;;yBAML,oBAAK;;;;;;;yBAML,oBAAK;;;;;;;;;;;;;;;;;;;;;;iCAgBhB,mBAAI;;;;gCAIF,qBAAM;;;;;;;;;;;;;;;;;;;;;;;wBAiBE,oBAAK;;;;;;;;;;;;;;;;oBAaX,oBAAK;;;wCAGW,sBAAO;;;;;;;;;;;;;;;;;;;;;;;;IAuBnC;;;;;;;;;IC7IA,qBAAqB,CAACA,KAAK,CAAC,CAAA;IAE5B,sBAAsB,CAAC,OAAO,CAAC,CAAA;IAE/B,uBAAuB,CAAC,OAAO,CAAC,CAAA;QAEnB,QAAQ,GAAG,UACtB,KAAU,EACV,SAA6B,EAC7B,OAAoC;;;;;oBAE9B,SAAS,GAAG,cAAc,CAAC,SAAS,EAAE,OAAO,CAAC,CAAA;oBAC9C,OAAO,GAAqB;wBAChC,KAAK,EAAE,EAAE;wBACT,OAAO,EAAE,EAAE;wBACX,OAAO,EAAE,EAAE;qBACZ,CAAA;oBACQ,CAAC,GAAG,CAAC;;;0BAAE,CAAC,GAAG,SAAS,CAAC,MAAM,CAAA;oBACnB,qBAAM,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,OAAO,CAAC,EAAA;;oBAApD,MAAM,GAAG,SAA2C;oBAClD,IAAI,GAAc,MAAM,KAApB,EAAE,OAAO,GAAK,MAAM,QAAX,CAAW;oBAChC,OAAO,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,CAAA;oBACnC,IAAI,OAAO,EAAE;wBACX,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;wBAC3B,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,aAAa;4BAAE,wBAAK;qBAClC;;;oBAPmC,CAAC,EAAE,CAAA;;wBASzC,sBAAO,OAAO,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}
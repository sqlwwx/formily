{"version":3,"file":"formily.vue.umd.development.js","sources":["../../json-schema/esm/shared.js","../../json-schema/esm/compiler.js","../../json-schema/esm/transformer.js","../../json-schema/esm/patches.js","../../json-schema/esm/polyfills/SPECIFICATION_1_0.js","../../json-schema/esm/schema.js","../../../node_modules/vue-demi/lib/index.esm.js","../src/shared/context.ts","../src/hooks/useAttach.ts","../src/hooks/useInjectionCleaner.ts","../../../node_modules/vue-frag/dist/frag.esm.js","../src/shared/fragment.ts","../src/shared/h.ts","../src/components/FormProvider.ts","../src/hooks/useForm.ts","../src/hooks/useField.ts","../src/hooks/useFormEffects.ts","../src/hooks/useFieldSchema.ts","../src/hooks/useParentForm.ts","../src/components/FormConsumer.ts","../src/shared/connect.ts","../src/shared/createForm.ts","../src/components/ReactiveField.ts","../src/utils/getRawComponent.ts","../src/components/ArrayField.ts","../src/components/ObjectField.ts","../src/components/VoidField.ts","../src/components/Field.ts","../src/components/RecursionField.ts","../src/utils/resolveSchemaProps.ts","../src/components/SchemaField.ts","../src/vue2-components.ts"],"sourcesContent":["import { isFn, each, isPlainObj, isArr, toArr, FormPath } from '@formily/shared';\nimport { isObservable, untracked } from '@formily/reactive';\nimport { Schema } from './schema';\nvar REVA_ACTIONS_KEY = Symbol.for('__REVA_ACTIONS');\nexport var SchemaNestedMap = {\n    parent: true,\n    root: true,\n    properties: true,\n    patternProperties: true,\n    additionalProperties: true,\n    items: true,\n    additionalItems: true,\n    'x-linkages': true,\n    'x-reactions': true,\n};\nexport var SchemaStateMap = {\n    title: 'title',\n    description: 'description',\n    default: 'initialValue',\n    enum: 'dataSource',\n    readOnly: 'readOnly',\n    writeOnly: 'editable',\n    'x-content': 'content',\n    'x-data': 'data',\n    'x-value': 'value',\n    'x-editable': 'editable',\n    'x-disabled': 'disabled',\n    'x-read-pretty': 'readPretty',\n    'x-read-only': 'readOnly',\n    'x-visible': 'visible',\n    'x-hidden': 'hidden',\n    'x-display': 'display',\n    'x-pattern': 'pattern',\n    'x-validator': 'validator',\n    'x-decorator': 'decoratorType',\n    'x-component': 'componentType',\n    'x-decorator-props': 'decoratorProps',\n    'x-component-props': 'componentProps',\n};\nexport var SchemaValidatorMap = {\n    required: true,\n    format: true,\n    maxItems: true,\n    minItems: true,\n    maxLength: true,\n    minLength: true,\n    maximum: true,\n    minimum: true,\n    exclusiveMaximum: true,\n    exclusiveMinimum: true,\n    pattern: true,\n    const: true,\n    multipleOf: true,\n    maxProperties: true,\n    minProperties: true,\n    uniqueItems: true,\n};\nexport var SchemaNormalKeys = Object.keys(SchemaStateMap);\nexport var SchemaValidatorKeys = Object.keys(SchemaValidatorMap);\nexport var hasOwnProperty = Object.prototype.hasOwnProperty;\nexport var traverse = function (target, visitor) {\n    var seenObjects = [];\n    var root = target;\n    var traverse = function (target, path) {\n        if (path === void 0) { path = []; }\n        if (isPlainObj(target)) {\n            var seenIndex = seenObjects.indexOf(target);\n            if (seenIndex > -1) {\n                return;\n            }\n            var addIndex = seenObjects.length;\n            seenObjects.push(target);\n            if (isNoNeedCompileObject(target) && root !== target) {\n                visitor(target, path);\n                return;\n            }\n            each(target, function (value, key) {\n                traverse(value, path.concat(key));\n            });\n            seenObjects.splice(addIndex, 1);\n        }\n        else {\n            visitor(target, path);\n        }\n    };\n    traverse(target);\n};\nexport var traverseSchema = function (schema, visitor) {\n    if (schema['x-validator'] !== undefined) {\n        visitor(schema['x-validator'], ['x-validator']);\n    }\n    var seenObjects = [];\n    var root = schema;\n    var traverse = function (target, path) {\n        if (path === void 0) { path = []; }\n        if (path[0] === 'x-validator' ||\n            path[0] === 'version' ||\n            path[0] === '_isJSONSchemaObject')\n            return;\n        if (String(path[0]).indexOf('x-') == -1 && isFn(target))\n            return;\n        if (SchemaNestedMap[path[0]])\n            return;\n        if (isPlainObj(target)) {\n            if (path[0] === 'default' || path[0] === 'x-value') {\n                visitor(target, path);\n                return;\n            }\n            var seenIndex = seenObjects.indexOf(target);\n            if (seenIndex > -1) {\n                return;\n            }\n            var addIndex = seenObjects.length;\n            seenObjects.push(target);\n            if (isNoNeedCompileObject(target) && root !== target) {\n                visitor(target, path);\n                return;\n            }\n            each(target, function (value, key) {\n                traverse(value, path.concat(key));\n            });\n            seenObjects.splice(addIndex, 1);\n        }\n        else {\n            visitor(target, path);\n        }\n    };\n    traverse(schema);\n};\nexport var isNoNeedCompileObject = function (source) {\n    if ('$$typeof' in source && '_owner' in source) {\n        return true;\n    }\n    if (source['_isAMomentObject']) {\n        return true;\n    }\n    if (Schema.isSchemaInstance(source)) {\n        return true;\n    }\n    if (source[REVA_ACTIONS_KEY]) {\n        return true;\n    }\n    if (isFn(source['toJS'])) {\n        return true;\n    }\n    if (isFn(source['toJSON'])) {\n        return true;\n    }\n    if (isObservable(source)) {\n        return true;\n    }\n    return false;\n};\nexport var createDataSource = function (source) {\n    return toArr(source).map(function (item) {\n        if (typeof item === 'object') {\n            return item;\n        }\n        else {\n            return {\n                label: item,\n                value: item,\n            };\n        }\n    });\n};\nexport var patchStateFormSchema = function (targetState, pattern, compiled) {\n    untracked(function () {\n        var _a;\n        var path = FormPath.parse(pattern);\n        var segments = path.segments;\n        var key = segments[0];\n        var isEnum = key === 'enum' && isArr(compiled);\n        var schemaMapKey = SchemaStateMap[key];\n        if (schemaMapKey) {\n            FormPath.setIn(targetState, [schemaMapKey].concat(segments.slice(1)), isEnum ? createDataSource(compiled) : compiled);\n        }\n        else {\n            var isValidatorKey = SchemaValidatorMap[key];\n            if (isValidatorKey) {\n                (_a = targetState['setValidatorRule']) === null || _a === void 0 ? void 0 : _a.call(targetState, key, compiled);\n            }\n        }\n    });\n};\n//# sourceMappingURL=shared.js.map","import { isArr, isFn, isPlainObj, isStr, reduce, FormPath, } from '@formily/shared';\nimport { untracked, hasCollected } from '@formily/reactive';\nimport { traverse, traverseSchema, isNoNeedCompileObject, hasOwnProperty, patchStateFormSchema, } from './shared';\nvar ExpRE = /^\\s*\\{\\{([\\s\\S]*)\\}\\}\\s*$/;\nvar Registry = {\n    silent: false,\n    compile: function (expression, scope) {\n        if (scope === void 0) { scope = {}; }\n        if (Registry.silent) {\n            try {\n                return new Function('$root', \"with($root) { return (\".concat(expression, \"); }\"))(scope);\n            }\n            catch (_a) { }\n        }\n        else {\n            return new Function('$root', \"with($root) { return (\".concat(expression, \"); }\"))(scope);\n        }\n    },\n};\nexport var silent = function (value) {\n    if (value === void 0) { value = true; }\n    Registry.silent = !!value;\n};\nexport var registerCompiler = function (compiler) {\n    if (isFn(compiler)) {\n        Registry.compile = compiler;\n    }\n};\nexport var shallowCompile = function (source, scope) {\n    if (isStr(source)) {\n        var matched = source.match(ExpRE);\n        if (!matched)\n            return source;\n        return Registry.compile(matched[1], scope);\n    }\n    return source;\n};\nexport var compile = function (source, scope) {\n    var seenObjects = [];\n    var compile = function (source) {\n        if (isStr(source)) {\n            return shallowCompile(source, scope);\n        }\n        else if (isArr(source)) {\n            return source.map(function (value) { return compile(value); });\n        }\n        else if (isPlainObj(source)) {\n            if (isNoNeedCompileObject(source))\n                return source;\n            var seenIndex = seenObjects.indexOf(source);\n            if (seenIndex > -1) {\n                return source;\n            }\n            var addIndex = seenObjects.length;\n            seenObjects.push(source);\n            var results = reduce(source, function (buf, value, key) {\n                buf[key] = compile(value);\n                return buf;\n            }, {});\n            seenObjects.splice(addIndex, 1);\n            return results;\n        }\n        return source;\n    };\n    return compile(source);\n};\nexport var patchCompile = function (targetState, sourceState, scope) {\n    traverse(sourceState, function (value, pattern) {\n        var path = FormPath.parse(pattern);\n        var compiled = compile(value, scope);\n        var key = path.segments[0];\n        if (compiled === undefined)\n            return;\n        if (hasOwnProperty.call(targetState, key)) {\n            untracked(function () { return FormPath.setIn(targetState, path, compiled); });\n        }\n    });\n};\nexport var patchSchemaCompile = function (targetState, sourceSchema, scope, demand) {\n    if (demand === void 0) { demand = false; }\n    traverseSchema(sourceSchema, function (value, path) {\n        var compiled = value;\n        var collected = hasCollected(function () {\n            compiled = compile(value, scope);\n        });\n        if (compiled === undefined)\n            return;\n        if (demand) {\n            if (collected || !targetState.initialized) {\n                patchStateFormSchema(targetState, path, compiled);\n            }\n        }\n        else {\n            patchStateFormSchema(targetState, path, compiled);\n        }\n    });\n};\n//# sourceMappingURL=compiler.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n/* istanbul ignore file */\nimport { untracked, autorun, observable } from '@formily/reactive';\nimport { isArr, isStr, toArr, each, isFn, isPlainObj, reduce, } from '@formily/shared';\nimport { onFieldInit, onFieldMount, onFieldUnmount, onFieldValueChange, onFieldInputValueChange, onFieldInitialValueChange, onFieldValidateStart, onFieldValidateEnd, onFieldValidateFailed, onFieldValidateSuccess, } from '@formily/core';\nimport { patchCompile, patchSchemaCompile, shallowCompile } from './compiler';\nvar FieldEffects = {\n    onFieldInit: onFieldInit,\n    onFieldMount: onFieldMount,\n    onFieldUnmount: onFieldUnmount,\n    onFieldValueChange: onFieldValueChange,\n    onFieldInputValueChange: onFieldInputValueChange,\n    onFieldInitialValueChange: onFieldInitialValueChange,\n    onFieldValidateStart: onFieldValidateStart,\n    onFieldValidateEnd: onFieldValidateEnd,\n    onFieldValidateFailed: onFieldValidateFailed,\n    onFieldValidateSuccess: onFieldValidateSuccess,\n};\nvar DefaultFieldEffects = ['onFieldInit', 'onFieldValueChange'];\nvar getDependencyValue = function (field, pattern, property) {\n    var _a = __read(String(pattern).split(/\\s*#\\s*/), 2), target = _a[0], path = _a[1];\n    return field.query(target).getIn(path || property || 'value');\n};\nvar getDependencies = function (field, dependencies) {\n    if (isArr(dependencies)) {\n        var results_1 = [];\n        dependencies.forEach(function (pattern) {\n            if (isStr(pattern)) {\n                results_1.push(getDependencyValue(field, pattern));\n            }\n            else if (isPlainObj(pattern)) {\n                if (pattern.name && pattern.source) {\n                    results_1[pattern.name] = getDependencyValue(field, pattern.source, pattern.property);\n                }\n            }\n        });\n        return results_1;\n    }\n    else if (isPlainObj(dependencies)) {\n        return reduce(dependencies, function (buf, pattern, key) {\n            buf[key] = getDependencyValue(field, pattern);\n            return buf;\n        }, {});\n    }\n    return [];\n};\nvar setSchemaFieldState = function (options, demand) {\n    if (demand === void 0) { demand = false; }\n    var _a = options || {}, request = _a.request, target = _a.target, runner = _a.runner, field = _a.field, scope = _a.scope;\n    if (!request)\n        return;\n    if (target) {\n        if (request.state) {\n            field.form.setFieldState(target, function (state) {\n                return patchCompile(state, request.state, __assign(__assign({}, scope), { $target: state }));\n            });\n        }\n        if (request.schema) {\n            field.form.setFieldState(target, function (state) {\n                return patchSchemaCompile(state, request.schema, __assign(__assign({}, scope), { $target: state }), demand);\n            });\n        }\n        if (isStr(runner) && runner) {\n            field.form.setFieldState(target, function (state) {\n                shallowCompile(\"{{function(){\".concat(runner, \"}}}\"), __assign(__assign({}, scope), { $target: state }))();\n            });\n        }\n    }\n    else {\n        if (request.state) {\n            field.setState(function (state) { return patchCompile(state, request.state, scope); });\n        }\n        if (request.schema) {\n            field.setState(function (state) {\n                return patchSchemaCompile(state, request.schema, scope, demand);\n            });\n        }\n        if (isStr(runner) && runner) {\n            shallowCompile(\"{{function(){\".concat(runner, \"}}}\"), scope)();\n        }\n    }\n};\nvar getBaseScope = function (field, options) {\n    if (options === void 0) { options = {}; }\n    var $observable = function (target, deps) {\n        return autorun.memo(function () { return observable(target); }, deps);\n    };\n    var $props = function (props) { return field.setComponentProps(props); };\n    var $effect = autorun.effect;\n    var $memo = autorun.memo;\n    var $self = field;\n    var $form = field.form;\n    var $values = field.form.values;\n    return __assign(__assign({}, options.scope), { $form: $form, $self: $self, $observable: $observable, $effect: $effect, $memo: $memo, $props: $props, $values: $values });\n};\nvar getBaseReactions = function (schema, options) { return function (field) {\n    setSchemaFieldState({\n        field: field,\n        request: { schema: schema },\n        scope: getBaseScope(field, options),\n    }, true);\n}; };\nvar getUserReactions = function (schema, options) { return function (field) {\n    var reactions = toArr(schema['x-reactions']);\n    var baseScope = getBaseScope(field, options);\n    reactions.forEach(function (unCompiled) {\n        var reaction = shallowCompile(unCompiled, baseScope);\n        if (!reaction)\n            return;\n        if (isFn(reaction)) {\n            return reaction(field);\n        }\n        var when = reaction.when, fulfill = reaction.fulfill, otherwise = reaction.otherwise, target = reaction.target, effects = reaction.effects;\n        var run = function () {\n            var $deps = getDependencies(field, reaction.dependencies);\n            var $dependencies = $deps;\n            var scope = __assign(__assign({}, baseScope), { $target: null, $deps: $deps, $dependencies: $dependencies });\n            var compiledWhen = shallowCompile(when, scope);\n            var condition = when ? compiledWhen : true;\n            var request = condition ? fulfill : otherwise;\n            var runner = condition ? fulfill === null || fulfill === void 0 ? void 0 : fulfill.run : otherwise === null || otherwise === void 0 ? void 0 : otherwise.run;\n            setSchemaFieldState({\n                field: field,\n                target: target,\n                request: request,\n                runner: runner,\n                scope: scope,\n            });\n        };\n        if (target) {\n            reaction.effects = (effects === null || effects === void 0 ? void 0 : effects.length) ? effects : DefaultFieldEffects;\n        }\n        if (reaction.effects) {\n            autorun.memo(function () {\n                untracked(function () {\n                    each(reaction.effects, function (type) {\n                        if (FieldEffects[type]) {\n                            FieldEffects[type](field.address, run);\n                        }\n                    });\n                });\n            }, []);\n        }\n        else {\n            run();\n        }\n    });\n}; };\nexport var transformFieldProps = function (schema, options) {\n    return {\n        name: schema.name,\n        reactions: [\n            getBaseReactions(schema, options),\n            getUserReactions(schema, options),\n        ],\n    };\n};\n//# sourceMappingURL=transformer.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { isFn, isArr } from '@formily/shared';\nvar patches = [];\nvar polyfills = {};\nexport var reducePatches = function (schema) {\n    return patches.reduce(function (buf, patch) {\n        return patch(buf);\n    }, __assign({}, schema));\n};\nexport var registerPatches = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    args.forEach(function (patch) {\n        if (isFn(patch)) {\n            patches.push(patch);\n        }\n    });\n};\nexport var registerPolyfills = function (version, patch) {\n    if (version && isFn(patch)) {\n        polyfills[version] = polyfills[version] || [];\n        polyfills[version].push(patch);\n    }\n};\nexport var enablePolyfills = function (versions) {\n    if (isArr(versions)) {\n        versions.forEach(function (version) {\n            if (isArr(polyfills[version])) {\n                polyfills[version].forEach(function (patch) {\n                    registerPatches(patch);\n                });\n            }\n        });\n    }\n};\n//# sourceMappingURL=patches.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { registerPolyfills } from '../patches';\nimport { toArr, isArr, isStr, lowerCase, isValid } from '@formily/shared';\nvar VOID_COMPONENTS = [\n    'card',\n    'block',\n    'grid-col',\n    'grid-row',\n    'grid',\n    'layout',\n    'step',\n    'tab',\n    'text-box',\n];\nvar TYPE_DEFAULT_COMPONENTS = {};\nvar transformCondition = function (condition) {\n    if (isStr(condition)) {\n        return condition.replace(/\\$value/, '$self.value');\n    }\n};\nvar transformXLinkage = function (linkages) {\n    if (isArr(linkages)) {\n        return linkages.reduce(function (buf, item) {\n            if (!item)\n                return buf;\n            if (item.type === 'value:visible') {\n                return buf.concat({\n                    target: item.target,\n                    when: transformCondition(item.condition),\n                    fulfill: {\n                        state: {\n                            visible: true,\n                        },\n                    },\n                    otherwise: {\n                        state: {\n                            visible: false,\n                        },\n                    },\n                });\n            }\n            else if (item.type === 'value:schema') {\n                return buf.concat({\n                    target: item.target,\n                    when: transformCondition(item.condition),\n                    fulfill: {\n                        schema: SpecificationV1Polyfill(__assign({ version: '1.0' }, item.schema)),\n                    },\n                    otherwise: {\n                        schema: SpecificationV1Polyfill(__assign({ version: '1.0' }, item.otherwise)),\n                    },\n                });\n            }\n            else if (item.type === 'value:state') {\n                return buf.concat({\n                    target: item.target,\n                    when: transformCondition(item.condition),\n                    fulfill: {\n                        state: item.state,\n                    },\n                    otherwise: {\n                        state: item.otherwise,\n                    },\n                });\n            }\n        }, []);\n    }\n    return [];\n};\nvar SpecificationV1Polyfill = function (schema) {\n    if (isValid(schema['editable'])) {\n        schema['x-editable'] = schema['x-editable'] || schema['editable'];\n        delete schema['editable'];\n    }\n    if (isValid(schema['visible'])) {\n        schema['x-visible'] = schema['x-visible'] || schema['visible'];\n        delete schema['visible'];\n    }\n    if (isValid(schema['display'])) {\n        schema['x-display'] =\n            schema['x-display'] || (schema['display'] ? 'visible' : 'hidden');\n        delete schema['display'];\n    }\n    if (isValid(schema['x-props'])) {\n        schema['x-decorator-props'] =\n            schema['x-decorator-props'] || schema['x-props'];\n        delete schema['display'];\n    }\n    if (schema['x-linkages']) {\n        schema['x-reactions'] = toArr(schema['x-reactions']).concat(transformXLinkage(schema['x-linkages']));\n        delete schema['x-linkages'];\n    }\n    if (schema['x-component']) {\n        if (VOID_COMPONENTS.some(function (component) { return lowerCase(component) === lowerCase(schema['x-component']); })) {\n            schema['type'] = 'void';\n        }\n    }\n    else {\n        if (TYPE_DEFAULT_COMPONENTS[schema['type']]) {\n            schema['x-component'] = TYPE_DEFAULT_COMPONENTS[schema['type']];\n        }\n    }\n    if (!schema['x-decorator'] &&\n        schema['type'] !== 'void' &&\n        schema['type'] !== 'object') {\n        schema['x-decorator'] = schema['x-decorator'] || 'FormItem';\n    }\n    if (schema['x-rules']) {\n        schema['x-validator'] = []\n            .concat(schema['x-validator'] || [])\n            .concat(schema['x-rules']);\n    }\n    return schema;\n};\nregisterPolyfills('1.0', SpecificationV1Polyfill);\nexport var registerVoidComponents = function (components) {\n    VOID_COMPONENTS.push.apply(VOID_COMPONENTS, __spreadArray([], __read(components), false));\n};\nexport var registerTypeDefaultComponents = function (maps) {\n    Object.assign(TYPE_DEFAULT_COMPONENTS, maps);\n};\n//# sourceMappingURL=SPECIFICATION_1_0.js.map","import { map, each, isFn, instOf, FormPath, isStr } from '@formily/shared';\nimport { compile, silent, shallowCompile, registerCompiler } from './compiler';\nimport { transformFieldProps } from './transformer';\nimport { reducePatches, registerPatches, registerPolyfills, enablePolyfills, } from './patches';\nimport { registerVoidComponents, registerTypeDefaultComponents, } from './polyfills';\nimport { SchemaNestedMap } from './shared';\nvar Schema = /** @class */ (function () {\n    function Schema(json, parent) {\n        var _this = this;\n        this._isJSONSchemaObject = true;\n        this.version = '2.0';\n        this.addProperty = function (key, schema) {\n            _this.properties = _this.properties || {};\n            _this.properties[key] = new Schema(schema, _this);\n            _this.properties[key].name = key;\n            return _this.properties[key];\n        };\n        this.removeProperty = function (key) {\n            var schema = _this.properties[key];\n            delete _this.properties[key];\n            return schema;\n        };\n        this.setProperties = function (properties) {\n            for (var key in properties) {\n                _this.addProperty(key, properties[key]);\n            }\n            return _this;\n        };\n        this.addPatternProperty = function (key, schema) {\n            if (!schema)\n                return;\n            _this.patternProperties = _this.patternProperties || {};\n            _this.patternProperties[key] = new Schema(schema, _this);\n            _this.patternProperties[key].name = key;\n            return _this.patternProperties[key];\n        };\n        this.removePatternProperty = function (key) {\n            var schema = _this.patternProperties[key];\n            delete _this.patternProperties[key];\n            return schema;\n        };\n        this.setPatternProperties = function (properties) {\n            if (!properties)\n                return _this;\n            for (var key in properties) {\n                _this.addPatternProperty(key, properties[key]);\n            }\n            return _this;\n        };\n        this.setAdditionalProperties = function (properties) {\n            if (!properties)\n                return;\n            _this.additionalProperties = new Schema(properties);\n            return _this.additionalProperties;\n        };\n        this.setItems = function (schema) {\n            if (!schema)\n                return;\n            if (Array.isArray(schema)) {\n                _this.items = schema.map(function (item) { return new Schema(item, _this); });\n            }\n            else {\n                _this.items = new Schema(schema, _this);\n            }\n            return _this.items;\n        };\n        this.setAdditionalItems = function (items) {\n            if (!items)\n                return;\n            _this.additionalItems = new Schema(items, _this);\n            return _this.additionalItems;\n        };\n        this.findDefinitions = function (ref) {\n            if (!ref || !_this.root || !isStr(ref))\n                return;\n            if (ref.indexOf('#/') !== 0)\n                return;\n            return FormPath.getIn(_this.root, ref.substring(2).split('/'));\n        };\n        this.mapProperties = function (callback) {\n            return Schema.getOrderProperties(_this).map(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                return callback(schema, key, index);\n            });\n        };\n        this.mapPatternProperties = function (callback) {\n            return Schema.getOrderProperties(_this, 'patternProperties').map(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                return callback(schema, key, index);\n            });\n        };\n        this.reduceProperties = function (callback, predicate) {\n            var results = predicate;\n            Schema.getOrderProperties(_this, 'properties').forEach(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                results = callback(results, schema, key, index);\n            });\n            return results;\n        };\n        this.reducePatternProperties = function (callback, predicate) {\n            var results = predicate;\n            Schema.getOrderProperties(_this, 'patternProperties').forEach(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                results = callback(results, schema, key, index);\n            });\n            return results;\n        };\n        this.compile = function (scope) {\n            var schema = new Schema({}, _this.parent);\n            each(_this, function (value, key) {\n                if (isFn(value) && !key.includes('x-'))\n                    return;\n                if (key === 'parent' || key === 'root')\n                    return;\n                if (!SchemaNestedMap[key]) {\n                    schema[key] = value ? compile(value, scope) : value;\n                }\n                else {\n                    schema[key] = value ? shallowCompile(value, scope) : value;\n                }\n            });\n            return schema;\n        };\n        this.fromJSON = function (json) {\n            if (!json)\n                return _this;\n            if (Schema.isSchemaInstance(json))\n                return json;\n            each(reducePatches(json), function (value, key) {\n                if (isFn(value) && !key.includes('x-'))\n                    return;\n                if (key === 'properties') {\n                    _this.setProperties(value);\n                }\n                else if (key === 'patternProperties') {\n                    _this.setPatternProperties(value);\n                }\n                else if (key === 'additionalProperties') {\n                    _this.setAdditionalProperties(value);\n                }\n                else if (key === 'items') {\n                    _this.setItems(value);\n                }\n                else if (key === 'additionalItems') {\n                    _this.setAdditionalItems(value);\n                }\n                else if (key === '$ref') {\n                    _this.fromJSON(_this.findDefinitions(value));\n                }\n                else {\n                    _this[key] = value;\n                }\n            });\n            return _this;\n        };\n        this.toJSON = function (recursion) {\n            if (recursion === void 0) { recursion = true; }\n            var results = {};\n            each(_this, function (value, key) {\n                var _a, _b;\n                if ((isFn(value) && !key.includes('x-')) ||\n                    key === 'parent' ||\n                    key === 'root')\n                    return;\n                if (key === 'properties' || key === 'patternProperties') {\n                    if (!recursion)\n                        return;\n                    results[key] = map(value, function (item) { var _a; return (_a = item === null || item === void 0 ? void 0 : item.toJSON) === null || _a === void 0 ? void 0 : _a.call(item); });\n                }\n                else if (key === 'additionalProperties' || key === 'additionalItems') {\n                    if (!recursion)\n                        return;\n                    results[key] = (_a = value === null || value === void 0 ? void 0 : value.toJSON) === null || _a === void 0 ? void 0 : _a.call(value);\n                }\n                else if (key === 'items') {\n                    if (!recursion)\n                        return;\n                    if (Array.isArray(value)) {\n                        results[key] = value.map(function (item) { var _a; return (_a = item === null || item === void 0 ? void 0 : item.toJSON) === null || _a === void 0 ? void 0 : _a.call(item); });\n                    }\n                    else {\n                        results[key] = (_b = value === null || value === void 0 ? void 0 : value.toJSON) === null || _b === void 0 ? void 0 : _b.call(value);\n                    }\n                }\n                else {\n                    results[key] = value;\n                }\n            });\n            return results;\n        };\n        this.toFieldProps = function (options) {\n            return transformFieldProps(_this, options);\n        };\n        if (parent) {\n            this.parent = parent;\n            this.root = parent.root;\n        }\n        else {\n            this.root = this;\n        }\n        return this.fromJSON(json);\n    }\n    Schema.getOrderProperties = function (schema, propertiesName) {\n        if (schema === void 0) { schema = {}; }\n        if (propertiesName === void 0) { propertiesName = 'properties'; }\n        var orderProperties = [];\n        var unorderProperties = [];\n        for (var key in schema[propertiesName]) {\n            var item = schema[propertiesName][key];\n            var index = item['x-index'];\n            if (!isNaN(index)) {\n                orderProperties[index] = { schema: item, key: key };\n            }\n            else {\n                unorderProperties.push({ schema: item, key: key });\n            }\n        }\n        return orderProperties.concat(unorderProperties).filter(function (item) { return !!item; });\n    };\n    Schema.compile = function (expression, scope) {\n        return compile(expression, scope);\n    };\n    Schema.shallowCompile = function (expression, scope) {\n        return shallowCompile(expression, scope);\n    };\n    Schema.isSchemaInstance = function (value) {\n        return instOf(value, Schema);\n    };\n    Schema.registerCompiler = registerCompiler;\n    Schema.registerPatches = registerPatches;\n    Schema.registerVoidComponents = registerVoidComponents;\n    Schema.registerTypeDefaultComponents = registerTypeDefaultComponents;\n    Schema.registerPolyfills = registerPolyfills;\n    Schema.enablePolyfills = enablePolyfills;\n    Schema.silent = silent;\n    return Schema;\n}());\nexport { Schema };\n//# sourceMappingURL=schema.js.map","import Vue from 'vue'\nimport VueCompositionAPI from '@vue/composition-api'\n\nfunction install(_vue) {\n  _vue = _vue || Vue\n  if (_vue && !_vue['__composition_api_installed__'])\n    Vue.use(VueCompositionAPI)\n}\n\ninstall(Vue)\n\nvar isVue2 = true\nvar isVue3 = false\nvar Vue2 = Vue\nvar version = Vue.version\n\n/**VCA-EXPORTS**/\nexport { EffectScope, computed, createApp, createRef, customRef, defineAsyncComponent, defineComponent, del, effectScope, getCurrentInstance, getCurrentScope, h, inject, isRaw, isReactive, isReadonly, isRef, markRaw, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onScopeDispose, onServerPrefetch, onUnmounted, onUpdated, provide, proxyRefs, reactive, readonly, ref, set, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref, useAttrs, useCSSModule, useCssModule, useSlots, warn, watch, watchEffect, watchPostEffect, watchSyncEffect } from '@vue/composition-api'\n/**VCA-EXPORTS**/\n\nexport {\n  Vue,\n  Vue2,\n  isVue2,\n  isVue3,\n  version,\n  install,\n}\n","import { InjectionKey, Ref } from 'vue-demi'\nimport { Form, GeneralField } from '@formily/core'\nimport { Schema } from '@formily/json-schema'\nimport { ISchemaFieldVueFactoryOptions } from '../types'\nexport const FormSymbol: InjectionKey<Ref<Form>> = Symbol('form')\nexport const FieldSymbol: InjectionKey<Ref<GeneralField>> = Symbol('field')\nexport const SchemaMarkupSymbol: InjectionKey<Ref<Schema>> =\n  Symbol('schemaMarkup')\nexport const SchemaSymbol: InjectionKey<Ref<Schema>> = Symbol('schema')\nexport const SchemaExpressionScopeSymbol: InjectionKey<\n  Ref<Record<string, any>>\n> = Symbol('schemaExpression')\nexport const SchemaOptionsSymbol: InjectionKey<\n  Ref<ISchemaFieldVueFactoryOptions>\n> = Symbol('schemaOptions')\n","import { onBeforeUnmount, onMounted, shallowRef, Ref } from 'vue-demi'\n\ninterface IRecycleTarget {\n  onMount: () => void\n  onUnmount: () => void\n}\n\nexport const useAttach = <T extends IRecycleTarget>(\n  target: T\n): [Ref<T>, (arg: T) => T] => {\n  const oldTargetRef = shallowRef<T>(null)\n  oldTargetRef.value = target\n  onMounted(() => {\n    target.onMount()\n  })\n\n  onBeforeUnmount(() => {\n    oldTargetRef.value?.onUnmount()\n  })\n\n  const checker = (target: T) => {\n    if (target !== oldTargetRef.value) {\n      if (oldTargetRef.value) {\n        oldTargetRef.value.onUnmount()\n      }\n      oldTargetRef.value = target\n      target.onMount()\n    }\n    return oldTargetRef.value as T\n  }\n\n  return [oldTargetRef, checker]\n}\n","import { InjectionKey, provide, Ref, ref } from 'vue-demi'\n\nexport const useInjectionCleaner = (\n  injectionKeys: InjectionKey<Ref<unknown>>[]\n) => {\n  injectionKeys.forEach((key) => provide(key, ref()))\n}\n","var $placeholder = Symbol();\n\nvar $fakeParent = Symbol();\n\nvar nextSiblingPatched = Symbol();\n\nvar childNodesPatched = Symbol();\n\nvar isFrag = function isFrag(node) {\n    return \"frag\" in node;\n};\n\nfunction patchParentNode(node, fakeParent) {\n    if ($fakeParent in node) {\n        return;\n    }\n    node[$fakeParent] = fakeParent;\n    Object.defineProperty(node, \"parentNode\", {\n        get: function get() {\n            return this[$fakeParent] || this.parentElement;\n        }\n    });\n}\n\nfunction patchNextSibling(node) {\n    if (nextSiblingPatched in node) {\n        return;\n    }\n    node[nextSiblingPatched] = true;\n    Object.defineProperty(node, \"nextSibling\", {\n        get: function get() {\n            var childNodes = this.parentNode.childNodes;\n            var index = childNodes.indexOf(this);\n            if (index > -1) {\n                return childNodes[index + 1] || null;\n            }\n            return null;\n        }\n    });\n}\n\nfunction getTopFragment(node, fromParent) {\n    while (node.parentNode !== fromParent) {\n        var _node = node, parentNode = _node.parentNode;\n        if (parentNode) {\n            node = parentNode;\n        }\n    }\n    return node;\n}\n\nvar getChildNodes;\n\nfunction getChildNodesWithFragments(node) {\n    if (!getChildNodes) {\n        var childNodesDescriptor = Object.getOwnPropertyDescriptor(Node.prototype, \"childNodes\");\n        getChildNodes = childNodesDescriptor.get;\n    }\n    var realChildNodes = getChildNodes.apply(node);\n    var childNodes = Array.from(realChildNodes).map((function(childNode) {\n        return getTopFragment(childNode, node);\n    }));\n    return childNodes.filter((function(childNode, index) {\n        return childNode !== childNodes[index - 1];\n    }));\n}\n\nfunction patchChildNodes(node) {\n    if (childNodesPatched in node) {\n        return;\n    }\n    node[childNodesPatched] = true;\n    Object.defineProperties(node, {\n        childNodes: {\n            get: function get() {\n                return this.frag || getChildNodesWithFragments(this);\n            }\n        },\n        firstChild: {\n            get: function get() {\n                return this.childNodes[0] || null;\n            }\n        }\n    });\n    node.hasChildNodes = function() {\n        return this.childNodes.length > 0;\n    };\n}\n\nfunction before() {\n    var _this$frag$;\n    (_this$frag$ = this.frag[0]).before.apply(_this$frag$, arguments);\n}\n\nfunction remove() {\n    var frag = this.frag;\n    var removed = frag.splice(0, frag.length);\n    removed.forEach((function(node) {\n        node.remove();\n    }));\n}\n\nvar getFragmentLeafNodes = function getFragmentLeafNodes(children) {\n    var _Array$prototype;\n    return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, children.map((function(childNode) {\n        return isFrag(childNode) ? getFragmentLeafNodes(childNode.frag) : childNode;\n    })));\n};\n\nfunction addPlaceholder(node, insertBeforeNode) {\n    var placeholder = node[$placeholder];\n    insertBeforeNode.before(placeholder);\n    patchParentNode(placeholder, node);\n    node.frag.unshift(placeholder);\n}\n\nfunction removeChild(node) {\n    if (isFrag(this)) {\n        var hasChildInFragment = this.frag.indexOf(node);\n        if (hasChildInFragment > -1) {\n            var _this$frag$splice = this.frag.splice(hasChildInFragment, 1), removedNode = _this$frag$splice[0];\n            if (this.frag.length === 0) {\n                addPlaceholder(this, removedNode);\n            }\n            node.remove();\n        }\n    } else {\n        var children = getChildNodesWithFragments(this);\n        var hasChild = children.indexOf(node);\n        if (hasChild > -1) {\n            node.remove();\n        }\n    }\n    return node;\n}\n\nfunction insertBefore(insertNode, insertBeforeNode) {\n    var _this = this;\n    var insertNodes = insertNode.frag || [ insertNode ];\n    if (isFrag(this)) {\n        var _frag = this.frag;\n        if (insertBeforeNode) {\n            var index = _frag.indexOf(insertBeforeNode);\n            if (index > -1) {\n                _frag.splice.apply(_frag, [ index, 0 ].concat(insertNodes));\n                insertBeforeNode.before.apply(insertBeforeNode, insertNodes);\n            }\n        } else {\n            var _lastNode = _frag[_frag.length - 1];\n            _frag.push.apply(_frag, insertNodes);\n            _lastNode.after.apply(_lastNode, insertNodes);\n        }\n        removePlaceholder(this);\n    } else if (insertBeforeNode) {\n        if (this.childNodes.includes(insertBeforeNode)) {\n            insertBeforeNode.before.apply(insertBeforeNode, insertNodes);\n        }\n    } else {\n        this.append.apply(this, insertNodes);\n    }\n    insertNodes.forEach((function(node) {\n        patchParentNode(node, _this);\n    }));\n    var lastNode = insertNodes[insertNodes.length - 1];\n    patchNextSibling(lastNode);\n    return insertNode;\n}\n\nfunction appendChild(node) {\n    var frag = this.frag;\n    var lastChild = frag[frag.length - 1];\n    lastChild.after(node);\n    patchParentNode(node, this);\n    removePlaceholder(this);\n    frag.push(node);\n    return node;\n}\n\nfunction removePlaceholder(node) {\n    var placeholder = node[$placeholder];\n    if (node.frag[0] === placeholder) {\n        node.frag.shift();\n        placeholder.remove();\n    }\n}\n\nvar frag = {\n    inserted: function inserted(element) {\n        var parentNode = element.parentNode, nextSibling = element.nextSibling, previousSibling = element.previousSibling;\n        var childNodes = Array.from(element.childNodes);\n        var placeholder = document.createComment(\"\");\n        if (childNodes.length === 0) {\n            childNodes.push(placeholder);\n        }\n        element.frag = childNodes;\n        element[$placeholder] = placeholder;\n        var fragment = document.createDocumentFragment();\n        fragment.append.apply(fragment, getFragmentLeafNodes(childNodes));\n        element.replaceWith(fragment);\n        childNodes.forEach((function(node) {\n            patchParentNode(node, element);\n            patchNextSibling(node);\n        }));\n        patchChildNodes(element);\n        Object.assign(element, {\n            remove: remove,\n            appendChild: appendChild,\n            insertBefore: insertBefore,\n            removeChild: removeChild,\n            before: before\n        });\n        Object.defineProperty(element, \"innerHTML\", {\n            set: function set(htmlString) {\n                var _this2 = this;\n                var domify = document.createElement(\"div\");\n                domify.innerHTML = htmlString;\n                var oldNodesIndex = this.frag.length;\n                Array.from(domify.childNodes).forEach((function(node) {\n                    _this2.appendChild(node);\n                }));\n                domify.append.apply(domify, this.frag.splice(0, oldNodesIndex));\n            },\n            get: function get() {\n                return \"\";\n            }\n        });\n        if (parentNode) {\n            Object.assign(parentNode, {\n                removeChild: removeChild,\n                insertBefore: insertBefore\n            });\n            patchParentNode(element, parentNode);\n            patchChildNodes(parentNode);\n        }\n        if (nextSibling) {\n            patchNextSibling(element);\n        }\n        if (previousSibling) {\n            patchNextSibling(previousSibling);\n        }\n    },\n    unbind: function unbind(element) {\n        element.remove();\n    }\n};\n\nvar fragment = {\n    directives: {\n        frag: frag\n    },\n    render: function render(h) {\n        return h(\"div\", {\n            directives: [ {\n                name: \"frag\"\n            } ]\n        }, this.$slots[\"default\"]);\n    }\n};\n\nexport { fragment as Fragment, frag as default };\n","import frag from 'vue-frag'\nimport { VueComponent } from '../types'\nimport { isVue2, defineComponent } from 'vue-demi'\n\nexport const Fragment = '#fragment'\n\nlet FragmentComponent: VueComponent\n\nif (isVue2) {\n  FragmentComponent = {\n    name: 'Fragment',\n    directives: {\n      frag,\n    },\n    render(h) {\n      const vm = this as any\n      return h(\n        'div',\n        {\n          directives: [\n            {\n              name: 'frag',\n            },\n          ],\n        },\n        vm?.$scopedSlots?.default?.(vm.$attrs)\n      )\n    },\n  }\n} else {\n  /* istanbul ignore next */\n  FragmentComponent = defineComponent({\n    name: 'Fragment',\n    setup(props: Record<string, any>, { slots, attrs }) {\n      return () => slots?.default?.(attrs)\n    },\n  })\n}\n\nexport { FragmentComponent }\n","import { h, isVue2 } from 'vue-demi'\nimport { Fragment, FragmentComponent } from './fragment'\n\ntype RenderChildren = {\n  [key in string]?: (...args: any[]) => (VNode | string)[]\n}\n\n// TODO: need to compatible with vue2 & vue3\ntype Tag = any\ntype VNodeData = Record<string, any>\ntype VNode = any\ntype VNodeChildren = any\n\nconst compatibleCreateElement = (\n  tag: Tag,\n  data: VNodeData,\n  components: RenderChildren\n): any => {\n  /* istanbul ignore else */\n  if (isVue2) {\n    const hInVue2 = h as (\n      tag: Tag,\n      data?: VNodeData,\n      components?: VNodeChildren\n    ) => VNode\n    const scopedSlots = components // 默认全部作为 scopedSlots 处理\n    const children = []\n\n    /**\n     * scopedSlots 不会映射为slots，所以这里手动映射一遍\n     * 主要为了解决 slots.x 问题\n     */\n    Object.keys(components).forEach((key) => {\n      const func = components[key]\n\n      // 转换为 slots 传递\n      if (typeof func === 'function' && func.length === 0) {\n        /**\n         * func 参数为0的判断不准确，因为composition-api包了一层，导致全部为0\n         * try catch 解决scoped slots 转换参数异常问题\n         * */\n        try {\n          const child = func()\n          children.push(\n            key === 'default'\n              ? child\n              : hInVue2(FragmentComponent, { slot: key }, [child])\n          )\n        } catch (error) {}\n      }\n    })\n    const newData = Object.assign({}, data)\n    if (Object.keys(scopedSlots).length > 0) {\n      if (!newData.scopedSlots) {\n        newData.scopedSlots = scopedSlots\n      } else {\n        newData.scopedSlots = {\n          ...newData.scopedSlots,\n          ...scopedSlots,\n        }\n      }\n    }\n    if (tag === Fragment) {\n      if (Object.keys(newData).length === 0 && children.length === 1) {\n        if (!Array.isArray(children[0])) {\n          return children[0]\n        } else if (children[0].length === 1) {\n          return children[0][0]\n        }\n      }\n      tag = FragmentComponent\n    }\n    return hInVue2(tag, newData, children)\n  } else {\n    if (tag === Fragment) {\n      tag = FragmentComponent\n    }\n    const hInVue3 = h as (\n      tag: Tag,\n      data?: VNodeData,\n      components?: RenderChildren\n    ) => VNode\n    const newData = {}\n    Object.keys(data).forEach((key) => {\n      if (key === 'on') {\n        if (data[key]) {\n          const events = Object.keys(data[key])\n          events.forEach((event) => {\n            const eventName = `on${event[0].toUpperCase()}${event.slice(1)}`\n            newData[eventName] = data[key][event]\n          })\n        }\n      } else if (typeof data[key] === 'object' && data[key] !== null) {\n        Object.assign(newData, data[key])\n      } else {\n        newData[key] = data[key]\n      }\n    })\n    return hInVue3(tag, newData, components)\n  }\n}\n\nexport default compatibleCreateElement\n\nexport { compatibleCreateElement as h }\n","import { provide, defineComponent, watch } from 'vue-demi'\nimport {\n  FormSymbol,\n  FieldSymbol,\n  SchemaMarkupSymbol,\n  SchemaSymbol,\n  SchemaExpressionScopeSymbol,\n  SchemaOptionsSymbol,\n} from '../shared/context'\nimport { IProviderProps } from '../types'\nimport { useAttach } from '../hooks/useAttach'\nimport { useInjectionCleaner } from '../hooks/useInjectionCleaner'\nimport h from '../shared/h'\nimport { Fragment } from '../shared/fragment'\n\nimport type { DefineComponent } from '../types'\n\nexport default defineComponent<IProviderProps>({\n  name: 'FormProvider',\n  inheritAttrs: false,\n  props: {\n    form: {\n      type: Object,\n      required: true,\n    },\n  },\n  setup(props: IProviderProps, { attrs, slots }) {\n    const getForm = () => props.form\n    const [formRef, checker] = useAttach(getForm())\n    watch(\n      () => props.form,\n      () => (formRef.value = checker(getForm()))\n    )\n\n    provide(FormSymbol, formRef)\n    useInjectionCleaner([\n      FieldSymbol,\n      SchemaMarkupSymbol,\n      SchemaSymbol,\n      SchemaExpressionScopeSymbol,\n      SchemaOptionsSymbol,\n    ])\n\n    return () => h(Fragment, { attrs }, slots)\n  },\n}) as unknown as DefineComponent<IProviderProps>\n","import { inject, Ref, ref } from 'vue-demi'\nimport { Form } from '@formily/core'\nimport { FormSymbol } from '../shared/context'\n\nexport const useForm = (): Ref<Form> => {\n  const form = inject(FormSymbol, ref())\n  return form\n}\n","import { inject, Ref, ref } from 'vue-demi'\nimport { GeneralField } from '@formily/core'\nimport { FieldSymbol } from '../shared/context'\n\nexport const useField = <T = GeneralField>(): Ref<T> => {\n  return inject(FieldSymbol, ref()) as any\n}\n","import { onBeforeUnmount } from 'vue-demi'\nimport { Form } from '@formily/core'\nimport { uid } from '@formily/shared'\nimport { useForm } from './useForm'\n\nexport const useFormEffects = (effects?: (form: Form) => void): void => {\n  const formRef = useForm()\n\n  const id = uid()\n  formRef.value.addEffects(id, effects)\n\n  onBeforeUnmount(() => {\n    formRef.value.removeEffects(id)\n  })\n}\n","import { inject, ref } from 'vue-demi'\nimport { SchemaSymbol } from '../shared/context'\n\nexport const useFieldSchema = () => {\n  return inject(SchemaSymbol, ref())\n}\n","import { isObjectField, GeneralField, Form, ObjectField } from '@formily/core'\nimport { computed, Ref } from 'vue-demi'\nimport { useField } from './useField'\nimport { useForm } from './useForm'\n\nexport const useParentForm = (): Ref<Form | ObjectField> => {\n  const field = useField()\n  const form = useForm()\n  const findObjectParent = (field: GeneralField) => {\n    if (!field) return form.value\n    if (isObjectField(field)) return field\n    return findObjectParent(field?.parent)\n  }\n  return computed(() => findObjectParent(field.value))\n}\n","import { defineComponent } from 'vue-demi'\nimport { observer } from '@formily/reactive-vue'\nimport { useForm } from '../hooks'\nimport h from '../shared/h'\nimport { Fragment } from '../shared/fragment'\n\nimport type { DefineComponent } from '../types'\n\nexport default observer(\n  defineComponent({\n    name: 'FormConsumer',\n    inheritAttrs: false,\n    setup(props, { slots }) {\n      const formRef = useForm()\n      return () => {\n        const children = {\n          ...slots,\n        }\n        if (slots.default) {\n          children.default = () =>\n            slots.default({\n              form: formRef.value,\n            })\n        }\n        return h(Fragment, {}, children)\n      }\n    },\n  }) as unknown as DefineComponent\n)\n","import { Vue2Component } from '../types/vue2'\nimport { isVue2, markRaw, defineComponent } from 'vue-demi'\nimport { isFn, isStr, FormPath, each } from '@formily/shared'\nimport { isVoidField, GeneralField } from '@formily/core'\nimport { observer } from '@formily/reactive-vue'\n\nimport { useField } from '../hooks/useField'\nimport h from './h'\n\nimport type {\n  VueComponent,\n  IComponentMapper,\n  IStateMapper,\n  VueComponentProps,\n  DefineComponent,\n} from '../types'\n\nexport function mapProps<T extends VueComponent = VueComponent>(\n  ...args: IStateMapper<VueComponentProps<T>>[]\n) {\n  return (target: T) => {\n    return observer(\n      defineComponent<VueComponentProps<T>>({\n        // listeners is needed for vue2\n        setup(props, { attrs, slots, listeners }: Record<string, any>) {\n          const fieldRef = useField()\n\n          const transform = (\n            input: VueComponentProps<T>,\n            field: GeneralField\n          ) =>\n            args.reduce((props, mapper) => {\n              if (isFn(mapper)) {\n                props = Object.assign(props, mapper(props, field))\n              } else {\n                each(mapper, (to, extract) => {\n                  const extractValue = FormPath.getIn(field, extract)\n                  const targetValue = isStr(to) ? to : extract\n                  if (extract === 'value') {\n                    if (to !== extract) {\n                      delete props['value']\n                    }\n                  }\n                  FormPath.setIn(props, targetValue, extractValue)\n                })\n              }\n              return props\n            }, input)\n\n          return () => {\n            const newAttrs = fieldRef.value\n              ? transform({ ...attrs } as VueComponentProps<T>, fieldRef.value)\n              : { ...attrs }\n            return h(\n              target,\n              {\n                attrs: {\n                  ...newAttrs,\n                },\n                on: listeners,\n              },\n              slots\n            )\n          }\n        },\n      }) as unknown as DefineComponent<VueComponentProps<T>>\n    )\n  }\n}\n\nexport function mapReadPretty<T extends VueComponent, C extends VueComponent>(\n  component: C,\n  readPrettyProps?: Record<string, any>\n) {\n  return (target: T) => {\n    return observer(\n      defineComponent({\n        setup(props, { attrs, slots, listeners }: Record<string, any>) {\n          const fieldRef = useField()\n          return () => {\n            const field = fieldRef.value\n            return h(\n              field && !isVoidField(field) && field.pattern === 'readPretty'\n                ? component\n                : target,\n              {\n                attrs: {\n                  ...readPrettyProps,\n                  ...attrs,\n                },\n                on: listeners,\n              },\n              slots\n            )\n          }\n        },\n      }) as unknown as DefineComponent<VueComponentProps<T>>\n    )\n  }\n}\n\nexport function connect<T extends VueComponent>(\n  target: T,\n  ...args: IComponentMapper[]\n) {\n  const Component = args.reduce((target: VueComponent, mapper) => {\n    return mapper(target)\n  }, target)\n  /* istanbul ignore else */\n  if (isVue2) {\n    const functionalComponent = {\n      functional: true,\n      render(h, context) {\n        return h(Component as Vue2Component, context.data, context.children)\n      },\n    }\n    return markRaw(functionalComponent)\n  } else {\n    const functionalComponent = defineComponent({\n      setup(props: VueComponentProps<T>, { attrs, slots }) {\n        return () => {\n          return h(Component, { props, attrs }, slots)\n        }\n      },\n    })\n    return markRaw(functionalComponent)\n  }\n}\n","import { createForm } from '@formily/core'\nimport { markRaw } from 'vue-demi'\n\nconst createRawForm = (...args: Parameters<typeof createForm>) => {\n  const form = createForm(...args)\n  return markRaw(form)\n}\n\nexport { createRawForm as createForm }\n","import { defineComponent, inject, ref } from 'vue-demi'\nimport { isVoidField } from '@formily/core'\nimport { FormPath } from '@formily/shared'\nimport { observer } from '@formily/reactive-vue'\nimport { toJS } from '@formily/reactive'\nimport { SchemaOptionsSymbol } from '../shared'\nimport h from '../shared/h'\nimport { Fragment } from '../shared/fragment'\n\nimport type {\n  IReactiveFieldProps,\n  VueComponent,\n  DefineComponent,\n  VueComponentProps,\n} from '../types'\n\nfunction isVueOptions(options: any) {\n  if (!options) {\n    return false\n  }\n  return (\n    typeof options.template === 'string' ||\n    typeof options.render === 'function' ||\n    typeof options.setup === 'function'\n  )\n}\n\nexport default observer(\n  defineComponent<IReactiveFieldProps>({\n    name: 'ReactiveField',\n    props: ['field'],\n    setup(props: IReactiveFieldProps, { slots }) {\n      const optionsRef = inject(SchemaOptionsSymbol, ref(null))\n      const key = Math.floor(Date.now() * Math.random()).toString(16)\n      const mergeChildren = (slots: Record<string, any>, content: any) => {\n        if (!Object.keys(slots).length && !content) return {}\n\n        const defaultSlot = slots?.default\n          ? slots?.default(props.field, props.field.form)\n          : []\n        if (typeof content === 'string') {\n          slots['default'] = () => [...defaultSlot, content]\n        } else if (isVueOptions(content) || typeof content === 'function') {\n          // scoped slot for class component\n          if (isVueOptions(content) && content?.render?.length > 1) {\n            slots['default'] = (scopedProps: VueComponentProps<any>) => [\n              ...defaultSlot,\n              h(content, { props: scopedProps }, {}),\n            ]\n          } else {\n            slots['default'] = () => [...defaultSlot, h(content, {}, {})]\n          }\n        } else if (content && typeof content === 'object') {\n          // for named slots\n          Object.keys(content).forEach((key) => {\n            const child = content[key]\n            const slot = slots?.[key] ? slots?.[key]() : []\n            if (typeof child === 'string') {\n              slots[key] = () => [...slot, child]\n            } else if (isVueOptions(child) || typeof child === 'function') {\n              // scoped slot for class component\n              if (isVueOptions(child) && child?.render?.length > 1) {\n                slots[key] = (scopedProps: VueComponentProps<any>) => [\n                  ...slot,\n                  h(child, { props: scopedProps }, {}),\n                ]\n              } else {\n                slots[key] = () => [...slot, h(child, {}, {})]\n              }\n            }\n          })\n        }\n\n        return slots\n      }\n\n      return () => {\n        const field = props.field\n        let children = {}\n        if (!field) {\n          children = slots\n        } else if (field.display !== 'visible') {\n          children = {\n            ...slots,\n            default: () => [h('template', {}, {})],\n          }\n        } else {\n          const renderDecorator = (childNodes: any[]) => {\n            if (!field?.decorator?.[0]) {\n              return {\n                default: () => childNodes,\n              }\n            } else {\n              const decorator = (FormPath.getIn(\n                optionsRef.value?.components,\n                field.decorator[0]\n              ) ?? field.decorator[0]) as VueComponent\n              const decoratorData = toJS(field.decorator[1]) || {}\n              const style = decoratorData?.style\n              const classes = decoratorData?.class\n              delete decoratorData.style\n              delete decoratorData.class\n              return {\n                default: () =>\n                  h(\n                    decorator,\n                    {\n                      style,\n                      class: classes,\n                      attrs: {\n                        ...decoratorData,\n                      },\n                    },\n                    {\n                      default: () => childNodes,\n                    }\n                  ),\n              }\n            }\n          }\n\n          const renderComponent = () => {\n            if (!field?.component?.[0]) {\n              return h(\n                Fragment,\n                {},\n                {\n                  default: () =>\n                    slots.default?.({\n                      field: props.field,\n                      form: props.field.form,\n                    }),\n                }\n              )\n            }\n\n            const component = (FormPath.getIn(\n              optionsRef.value?.components,\n              field.component[0]\n            ) ?? field.component[0]) as VueComponent\n            const originData = toJS(field.component[1]) || {}\n            const events = {} as Record<string, any>\n            const originChange = originData['@change'] || originData['onChange']\n            const originFocus = originData['@focus'] || originData['onFocus']\n            const originBlur = originData['@blur'] || originData['onBlur']\n\n            // '@xxx' has higher priority\n            Object.keys(originData)\n              .filter((key) => key.startsWith('on'))\n              .forEach((eventKey) => {\n                const eventName = `${eventKey[2].toLowerCase()}${eventKey.slice(\n                  3\n                )}`\n                events[eventName] = originData[eventKey]\n              })\n\n            Object.keys(originData)\n              .filter((key) => key.startsWith('@'))\n              .forEach((eventKey) => {\n                events[eventKey.slice(1)] = originData[eventKey]\n                delete originData[eventKey]\n              })\n\n            events.change = (...args: any[]) => {\n              if (!isVoidField(field)) field.onInput(...args)\n              originChange?.(...args)\n            }\n            events.focus = (...args: any[]) => {\n              if (!isVoidField(field)) field.onFocus(...args)\n              originFocus?.(...args)\n            }\n            events.blur = (...args: any[]) => {\n              if (!isVoidField(field)) field.onBlur(...args)\n              originBlur?.(...args)\n            }\n\n            const style = originData?.style\n            const classes = originData?.class\n            delete originData.style\n            delete originData.class\n            const attrs = {\n              disabled: !isVoidField(field)\n                ? field.pattern === 'disabled' || field.pattern === 'readPretty'\n                : undefined,\n              readOnly: !isVoidField(field)\n                ? field.pattern === 'readOnly'\n                : undefined,\n              ...originData,\n              // toJS is used to avoid some render loop.\n              value: !isVoidField(field) ? toJS(field.value) : undefined,\n            }\n            const componentData = {\n              attrs,\n              style,\n              class: classes,\n              on: events,\n            }\n\n            const componentChildren = mergeChildren(\n              {\n                ...slots,\n              },\n              field.content\n            )\n\n            return h(component, componentData, componentChildren)\n          }\n\n          children = renderDecorator([renderComponent()])\n        }\n\n        return h(Fragment, { key }, children)\n      }\n    },\n  }) as unknown as DefineComponent<IReactiveFieldProps>\n)\n","import { IFieldProps, VueComponent } from '../types'\nimport { toRaw } from 'vue-demi'\n\nexport const getRawComponent = (\n  props: IFieldProps<VueComponent, VueComponent>\n) => {\n  const { component, decorator } = props\n  let newComponent: typeof props.component\n  let newDecorator: typeof props.component\n  if (Array.isArray(component)) {\n    newComponent = [toRaw(component[0]), component[1]]\n  }\n  if (Array.isArray(decorator)) {\n    newDecorator = [toRaw(decorator[0]), decorator[1]]\n  }\n  return { component: newComponent, decorator: newDecorator }\n}\n","import { provide, defineComponent, watch, computed } from 'vue-demi'\nimport { useField, useForm } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport ReactiveField from './ReactiveField'\nimport { FieldSymbol } from '../shared/context'\nimport h from '../shared/h'\nimport { getRawComponent } from '../utils/getRawComponent'\nimport { observer } from '@formily/reactive-vue'\n\nimport type { IArrayFieldProps, DefineComponent } from '../types'\n\nexport default observer(\n  defineComponent<IArrayFieldProps>({\n    name: 'ArrayField',\n    props: {\n      name: {},\n      title: {},\n      description: {},\n      value: {},\n      initialValue: {},\n      basePath: {},\n      decorator: Array,\n      component: Array,\n      display: String,\n      pattern: String,\n      required: {\n        type: Boolean,\n        default: undefined,\n      },\n      validateFirst: {\n        type: Boolean,\n        default: undefined,\n      },\n      hidden: {\n        type: Boolean,\n        default: undefined,\n      },\n      visible: {\n        type: Boolean,\n        default: undefined,\n      },\n      editable: {\n        type: Boolean,\n        default: undefined,\n      },\n      disabled: {\n        type: Boolean,\n        default: undefined,\n      },\n      readOnly: {\n        type: Boolean,\n        default: undefined,\n      },\n      readPretty: {\n        type: Boolean,\n        default: undefined,\n      },\n      dataSource: {},\n      validator: {},\n      reactions: [Array, Function],\n    },\n    setup(props: IArrayFieldProps, { slots }) {\n      const formRef = useForm()\n      const parentRef = useField()\n\n      const basePath = computed(() =>\n        props.basePath !== undefined\n          ? props.basePath\n          : parentRef?.value?.address\n      )\n      const createField = () =>\n        formRef.value.createArrayField({\n          ...props,\n          basePath: basePath.value,\n          ...getRawComponent(props),\n        })\n      const [fieldRef, checker] = useAttach(createField())\n      watch(\n        () => props,\n        () => (fieldRef.value = checker(createField())),\n        { deep: true }\n      )\n      watch(\n        [formRef, parentRef],\n        () => (fieldRef.value = checker(createField()))\n      )\n\n      provide(FieldSymbol, fieldRef)\n\n      return () => {\n        const field = fieldRef.value\n        const componentData = {\n          props: {\n            field,\n          },\n        }\n        const children = {\n          ...slots,\n        }\n        if (slots.default) {\n          children.default = () =>\n            slots.default({\n              field: field,\n              form: field.form,\n            })\n        }\n        return h(ReactiveField, componentData, children)\n      }\n    },\n  }) as unknown as DefineComponent<IArrayFieldProps>\n)\n","import { provide, defineComponent, computed, watch } from 'vue-demi'\nimport { useField, useForm } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport ReactiveField from './ReactiveField'\nimport { observer } from '@formily/reactive-vue'\nimport { FieldSymbol } from '../shared/context'\nimport h from '../shared/h'\nimport { getRawComponent } from '../utils/getRawComponent'\n\nimport type { IObjectFieldProps, DefineComponent } from '../types'\n\nexport default observer(\n  defineComponent<IObjectFieldProps>({\n    name: 'ObjectField',\n    props: {\n      name: {},\n      title: {},\n      description: {},\n      value: {},\n      initialValue: {},\n      basePath: {},\n      decorator: Array,\n      component: Array,\n      display: String,\n      pattern: String,\n      required: {\n        type: Boolean,\n        default: undefined,\n      },\n      validateFirst: {\n        type: Boolean,\n        default: undefined,\n      },\n      hidden: {\n        type: Boolean,\n        default: undefined,\n      },\n      visible: {\n        type: Boolean,\n        default: undefined,\n      },\n      editable: {\n        type: Boolean,\n        default: undefined,\n      },\n      disabled: {\n        type: Boolean,\n        default: undefined,\n      },\n      readOnly: {\n        type: Boolean,\n        default: undefined,\n      },\n      readPretty: {\n        type: Boolean,\n        default: undefined,\n      },\n      dataSource: {},\n      validator: {},\n      reactions: [Array, Function],\n    },\n    setup(props: IObjectFieldProps, { slots }) {\n      const formRef = useForm()\n      const parentRef = useField()\n\n      const basePath = computed(() =>\n        props.basePath !== undefined\n          ? props.basePath\n          : parentRef?.value?.address\n      )\n      const createField = () =>\n        formRef.value.createObjectField({\n          ...props,\n          basePath: basePath.value,\n          ...getRawComponent(props),\n        })\n      const [fieldRef, checker] = useAttach(createField())\n      watch(\n        () => props,\n        () => (fieldRef.value = checker(createField())),\n        { deep: true }\n      )\n      watch(\n        [formRef, parentRef],\n        () => (fieldRef.value = checker(createField()))\n      )\n\n      provide(FieldSymbol, fieldRef)\n\n      return () => {\n        const field = fieldRef.value\n        const componentData = {\n          props: {\n            field,\n          },\n        }\n        const children = {\n          ...slots,\n        }\n        if (slots.default) {\n          children.default = () =>\n            slots.default({\n              field: field,\n              form: field.form,\n            })\n        }\n        return h(ReactiveField, componentData, children)\n      }\n    },\n  }) as unknown as DefineComponent<IObjectFieldProps>\n)\n","import { provide, defineComponent, computed, watch } from 'vue-demi'\nimport { useField, useForm } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport ReactiveField from './ReactiveField'\nimport { FieldSymbol } from '../shared/context'\nimport h from '../shared/h'\nimport { getRawComponent } from '../utils/getRawComponent'\n\nimport type { IVoidFieldProps, DefineComponent } from '../types'\n\nexport default defineComponent<IVoidFieldProps>({\n  name: 'VoidField',\n  props: {\n    name: {},\n    title: {},\n    description: {},\n    basePath: {},\n    decorator: Array,\n    component: Array,\n    display: String,\n    pattern: String,\n    hidden: {\n      type: Boolean,\n      default: undefined,\n    },\n    visible: {\n      type: Boolean,\n      default: undefined,\n    },\n    editable: {\n      type: Boolean,\n      default: undefined,\n    },\n    disabled: {\n      type: Boolean,\n      default: undefined,\n    },\n    readOnly: {\n      type: Boolean,\n      default: undefined,\n    },\n    readPretty: {\n      type: Boolean,\n      default: undefined,\n    },\n    reactions: [Array, Function],\n  },\n  setup(props: IVoidFieldProps, { slots }) {\n    const formRef = useForm()\n    const parentRef = useField()\n\n    const basePath = computed(() =>\n      props.basePath !== undefined ? props.basePath : parentRef?.value?.address\n    )\n    const createField = () =>\n      formRef.value.createVoidField({\n        ...props,\n        basePath: basePath.value,\n        ...getRawComponent(props),\n      })\n    const [fieldRef, checker] = useAttach(createField())\n    watch(\n      () => props,\n      () => (fieldRef.value = checker(createField())),\n      { deep: true }\n    )\n    watch([formRef, parentRef], () => (fieldRef.value = checker(createField())))\n\n    provide(FieldSymbol, fieldRef)\n\n    return () => {\n      const field = fieldRef.value\n      const componentData = {\n        props: {\n          field,\n        },\n      }\n      const children = {\n        ...slots,\n      }\n      if (slots.default) {\n        children.default = () =>\n          slots.default({\n            field: field,\n            form: field.form,\n          })\n      }\n      return h(ReactiveField, componentData, children)\n    }\n  },\n}) as unknown as DefineComponent<IVoidFieldProps>\n","import { provide, defineComponent, watch, computed } from 'vue-demi'\nimport { useField, useForm } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport { FieldSymbol } from '../shared/context'\nimport ReactiveField from './ReactiveField'\nimport h from '../shared/h'\nimport { getRawComponent } from '../utils/getRawComponent'\n\nimport type { IFieldProps, DefineComponent } from '../types'\n\nexport default defineComponent<IFieldProps>({\n  name: 'Field',\n  props: {\n    name: {},\n    title: {},\n    description: {},\n    value: {},\n    initialValue: {},\n    basePath: {},\n    decorator: Array,\n    component: Array,\n    display: String,\n    pattern: String,\n    required: {\n      type: Boolean,\n      default: undefined,\n    },\n    validateFirst: {\n      type: Boolean,\n      default: undefined,\n    },\n    hidden: {\n      type: Boolean,\n      default: undefined,\n    },\n    visible: {\n      type: Boolean,\n      default: undefined,\n    },\n    editable: {\n      type: Boolean,\n      default: undefined,\n    },\n    disabled: {\n      type: Boolean,\n      default: undefined,\n    },\n    readOnly: {\n      type: Boolean,\n      default: undefined,\n    },\n    readPretty: {\n      type: Boolean,\n      default: undefined,\n    },\n    dataSource: {},\n    validator: {},\n    reactions: [Array, Function],\n  },\n  setup(props: IFieldProps, { slots }) {\n    const formRef = useForm()\n    const parentRef = useField()\n\n    const basePath = computed(() =>\n      props.basePath !== undefined ? props.basePath : parentRef?.value?.address\n    )\n    const createField = () =>\n      formRef.value.createField({\n        ...props,\n        basePath: basePath.value,\n        ...getRawComponent(props),\n      })\n    const [fieldRef, checker] = useAttach(createField())\n    watch(\n      () => props,\n      () => (fieldRef.value = checker(createField())),\n      { deep: true }\n    )\n    watch([formRef, parentRef], () => (fieldRef.value = checker(createField())))\n\n    provide(FieldSymbol, fieldRef)\n\n    return () => {\n      const field = fieldRef.value\n      const componentData = {\n        props: {\n          field,\n        },\n      }\n      const children = {\n        ...slots,\n      }\n      if (slots.default) {\n        children.default = () =>\n          slots.default({\n            field,\n            form: field.form,\n          })\n      }\n      return h(ReactiveField, componentData, children)\n    }\n  },\n}) as unknown as DefineComponent<IFieldProps>\n","import { inject, provide, watch, defineComponent, shallowRef } from 'vue-demi'\nimport { GeneralField } from '@formily/core'\nimport { isFn, isValid } from '@formily/shared'\nimport { Schema } from '@formily/json-schema'\nimport { observer } from '@formily/reactive-vue'\nimport {\n  SchemaSymbol,\n  SchemaOptionsSymbol,\n  SchemaExpressionScopeSymbol,\n} from '../shared'\nimport { useField } from '../hooks'\nimport ObjectField from './ObjectField'\nimport ArrayField from './ArrayField'\nimport Field from './Field'\nimport VoidField from './VoidField'\nimport { h } from '../shared/h'\nimport { Fragment } from '../shared/fragment'\n\nimport type { IRecursionFieldProps, DefineComponent } from '../types'\n\nconst RecursionField = observer(\n  defineComponent<IRecursionFieldProps>({\n    name: 'RecursionField',\n    inheritAttrs: false,\n    props: {\n      schema: {\n        required: true,\n      },\n      name: [String, Number],\n      basePath: {},\n      onlyRenderProperties: {\n        type: Boolean,\n        default: undefined,\n      },\n      onlyRenderSelf: {\n        type: Boolean,\n        default: undefined,\n      },\n      mapProperties: {},\n      filterProperties: {},\n    },\n    setup(props: IRecursionFieldProps) {\n      const parentRef = useField()\n      const optionsRef = inject(SchemaOptionsSymbol)\n      const scopeRef = inject(SchemaExpressionScopeSymbol)\n      const createSchema = (schemaProp: IRecursionFieldProps['schema']) =>\n        new Schema(schemaProp)\n      const fieldSchemaRef = shallowRef(createSchema(props.schema))\n\n      watch([() => props.schema], () => {\n        fieldSchemaRef.value = createSchema(props.schema)\n      })\n\n      const getPropsFromSchema = (schema: Schema) =>\n        schema?.toFieldProps?.({\n          ...optionsRef.value,\n          get scope() {\n            return {\n              ...optionsRef.value.scope,\n              ...scopeRef.value,\n            }\n          },\n        })\n      const fieldPropsRef = shallowRef(getPropsFromSchema(fieldSchemaRef.value))\n\n      watch([fieldSchemaRef, optionsRef], () => {\n        fieldPropsRef.value = getPropsFromSchema(fieldSchemaRef.value)\n      })\n\n      const getBasePath = () => {\n        if (props.onlyRenderProperties) {\n          return props.basePath || parentRef?.value?.address.concat(props.name)\n        }\n        return props.basePath || parentRef?.value?.address\n      }\n\n      provide(SchemaSymbol, fieldSchemaRef)\n\n      return () => {\n        const basePath = getBasePath()\n        const fieldProps = fieldPropsRef.value\n\n        const renderProperties = (field?: GeneralField) => {\n          if (props.onlyRenderSelf) return\n          const properties = Schema.getOrderProperties(fieldSchemaRef.value)\n          if (!properties.length) return\n          const children = properties.map(({ schema: item, key: name }) => {\n            const base = field?.address || basePath\n            let schema: Schema = item\n            if (isFn(props.mapProperties)) {\n              const mapped = props.mapProperties(item, name)\n              if (mapped) {\n                schema = mapped\n              }\n            }\n            if (isFn(props.filterProperties)) {\n              if (props.filterProperties(schema, name) === false) {\n                return null\n              }\n            }\n            return h(\n              RecursionField,\n              {\n                key: name,\n                attrs: {\n                  schema,\n                  name,\n                  basePath: base,\n                },\n              },\n              {}\n            )\n          })\n\n          const slots: Record<string, () => any> = {}\n          if (children.length > 0) {\n            slots.default = () => [...children]\n          }\n\n          return h(Fragment, {}, slots)\n        }\n\n        const render = () => {\n          if (!isValid(props.name)) return renderProperties()\n          if (fieldSchemaRef.value.type === 'object') {\n            if (props.onlyRenderProperties) return renderProperties()\n            return h(\n              ObjectField,\n              {\n                attrs: {\n                  ...fieldProps,\n                  name: props.name,\n                  basePath: basePath,\n                },\n              },\n              {\n                default: ({ field }) => [renderProperties(field)],\n              }\n            )\n          } else if (fieldSchemaRef.value.type === 'array') {\n            return h(\n              ArrayField,\n              {\n                attrs: {\n                  ...fieldProps,\n                  name: props.name,\n                  basePath: basePath,\n                },\n              },\n              {}\n            )\n          } else if (fieldSchemaRef.value.type === 'void') {\n            if (props.onlyRenderProperties) return renderProperties()\n            return h(\n              VoidField,\n              {\n                attrs: {\n                  ...fieldProps,\n                  name: props.name,\n                  basePath: basePath,\n                },\n              },\n              {\n                default: ({ field }) => [renderProperties(field)],\n              }\n            )\n          }\n\n          return h(\n            Field,\n            {\n              attrs: {\n                ...fieldProps,\n                name: props.name,\n                basePath: basePath,\n              },\n            },\n            {}\n          )\n        }\n\n        if (!fieldSchemaRef.value) return\n\n        return render()\n      }\n    },\n  }) as unknown as DefineComponent<IRecursionFieldProps>\n)\n\nexport default RecursionField\n","import { paramCase } from '@formily/shared'\n\nexport const resolveSchemaProps = (props: Record<string, any>) => {\n  const newProps = {}\n  Object.keys(props).forEach((key) => {\n    if (key.indexOf('x') === 0 && key.indexOf('x-') === -1) {\n      newProps[paramCase(key)] = props[key]\n    } else {\n      newProps[key] = props[key]\n    }\n  })\n  return newProps\n}\n","import {\n  inject,\n  provide,\n  defineComponent,\n  computed,\n  shallowRef,\n  watch,\n} from 'vue-demi'\nimport { ISchema, Schema, SchemaTypes } from '@formily/json-schema'\nimport { RecursionField } from '../components'\nimport {\n  SchemaMarkupSymbol,\n  SchemaExpressionScopeSymbol,\n  SchemaOptionsSymbol,\n} from '../shared'\nimport {\n  ComponentPath,\n  VueComponent,\n  ISchemaFieldVueFactoryOptions,\n  SchemaVueComponents,\n  ISchemaFieldProps,\n  ISchemaMarkupFieldProps,\n  ISchemaTypeFieldProps,\n} from '../types'\nimport { resolveSchemaProps } from '../utils/resolveSchemaProps'\nimport { h } from '../shared/h'\nimport { Fragment } from '../shared/fragment'\n\nimport type { DefineComponent } from '../types'\n\nconst env = {\n  nonameId: 0,\n}\n\nconst getRandomName = () => {\n  return `NO_NAME_FIELD_$${env.nonameId++}`\n}\n\nconst markupProps = {\n  version: String,\n  name: [String, Number],\n  title: {},\n  description: {},\n  default: {},\n  readOnly: {\n    type: Boolean,\n    default: undefined,\n  },\n  writeOnly: {\n    type: Boolean,\n    default: undefined,\n  },\n  enum: {},\n  const: {},\n  multipleOf: Number,\n  maximum: Number,\n  exclusiveMaximum: Number,\n  minimum: Number,\n  exclusiveMinimum: Number,\n  maxLength: Number,\n  minLength: Number,\n  pattern: {},\n  maxItems: Number,\n  minItems: Number,\n  uniqueItems: {\n    type: Boolean,\n    default: undefined,\n  },\n  maxProperties: Number,\n  minProperties: Number,\n  required: {\n    type: [Boolean, Array, String],\n    default: undefined,\n  },\n  format: String,\n  properties: {},\n  items: {},\n  additionalItems: {},\n  patternProperties: {},\n  additionalProperties: {},\n  xIndex: Number,\n  xPattern: {},\n  xDisplay: {},\n  xValidator: {},\n  xDecorator: {},\n  xDecoratorProps: {},\n  xComponent: {},\n  xComponentProps: {},\n  xReactions: {},\n  xContent: {},\n  xVisible: {\n    type: Boolean,\n    default: undefined,\n  },\n  xHidden: {\n    type: Boolean,\n    default: undefined,\n  },\n  xDisabled: {\n    type: Boolean,\n    default: undefined,\n  },\n  xEditable: {\n    type: Boolean,\n    default: undefined,\n  },\n  xReadOnly: {\n    type: Boolean,\n    default: undefined,\n  },\n  xReadPretty: {\n    type: Boolean,\n    default: undefined,\n  },\n}\n\ntype SchemaFieldComponents = {\n  SchemaField: DefineComponent<ISchemaFieldProps>\n  SchemaMarkupField: DefineComponent<ISchemaMarkupFieldProps>\n  SchemaStringField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaObjectField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaArrayField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaBooleanField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateTimeField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaVoidField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaNumberField: DefineComponent<ISchemaTypeFieldProps>\n}\n\nexport function createSchemaField<\n  Components extends SchemaVueComponents = SchemaVueComponents\n>(options: ISchemaFieldVueFactoryOptions<Components>): SchemaFieldComponents {\n  const SchemaField = defineComponent<\n    ISchemaFieldProps<VueComponent, VueComponent>\n  >({\n    name: 'SchemaField',\n    inheritAttrs: false,\n    props: {\n      schema: {},\n      scope: {},\n      components: {},\n      basePath: {},\n      title: {},\n      description: {},\n      value: {},\n      initialValue: {},\n      validator: {},\n      dataSource: {},\n      name: [String, Number],\n      decorator: Array,\n      component: Array,\n      reactions: Array,\n      display: String,\n      pattern: String,\n      required: {\n        type: Boolean,\n        default: undefined,\n      },\n      validateFirst: {\n        type: Boolean,\n        default: undefined,\n      },\n      hidden: {\n        type: Boolean,\n        default: undefined,\n      },\n      visible: {\n        type: Boolean,\n        default: undefined,\n      },\n      editable: {\n        type: Boolean,\n        default: undefined,\n      },\n      disabled: {\n        type: Boolean,\n        default: undefined,\n      },\n      readOnly: {\n        type: Boolean,\n        default: undefined,\n      },\n      readPretty: {\n        type: Boolean,\n        default: undefined,\n      },\n    },\n    setup(props: ISchemaFieldProps<VueComponent, VueComponent>, { slots }) {\n      const schemaRef = computed(() =>\n        Schema.isSchemaInstance(props.schema)\n          ? props.schema\n          : new Schema({\n              type: 'object',\n              ...props.schema,\n            })\n      )\n\n      const scopeRef = computed(() => ({\n        ...options.scope,\n        ...props.scope,\n      }))\n\n      const optionsRef = computed(() => ({\n        ...options,\n        components: {\n          ...options.components,\n          ...props.components,\n        },\n      }))\n\n      provide(SchemaMarkupSymbol, schemaRef)\n      provide(SchemaOptionsSymbol, optionsRef)\n      provide(SchemaExpressionScopeSymbol, scopeRef)\n\n      return () => {\n        env.nonameId = 0\n\n        return h(\n          Fragment,\n          {},\n          {\n            default: () => {\n              const children = []\n              if (slots.default) {\n                children.push(\n                  h(\n                    'template',\n                    {},\n                    {\n                      default: () => slots.default(),\n                    }\n                  )\n                )\n              }\n              children.push(\n                h(\n                  RecursionField,\n                  {\n                    attrs: {\n                      ...props,\n                      schema: schemaRef.value,\n                    },\n                  },\n                  {}\n                )\n              )\n              return children\n            },\n          }\n        )\n      }\n    },\n  })\n\n  const MarkupField = defineComponent<\n    ISchemaMarkupFieldProps<\n      Components,\n      ComponentPath<Components>,\n      ComponentPath<Components>\n    >\n  >({\n    name: 'MarkupField',\n    props: Object.assign({}, markupProps, { type: String }),\n    setup(props, { slots }) {\n      const parentRef = inject(SchemaMarkupSymbol, null)\n      if (!parentRef || !parentRef.value) return () => h(Fragment, {}, {})\n      const resolvedProps = resolveSchemaProps(props)\n\n      const name = props.name || getRandomName()\n      const appendArraySchema = (schema: ISchema) => {\n        if (parentRef.value.items) {\n          return parentRef.value.addProperty(name, schema)\n        } else {\n          return parentRef.value.setItems(resolvedProps)\n        }\n      }\n\n      const schemaRef = shallowRef(null)\n\n      watch(\n        parentRef,\n        () => {\n          if (\n            parentRef.value.type === 'object' ||\n            parentRef.value.type === 'void'\n          ) {\n            schemaRef.value = parentRef.value.addProperty(name, resolvedProps)\n          } else if (parentRef.value.type === 'array') {\n            const schema = appendArraySchema(resolvedProps)\n            schemaRef.value = Array.isArray(schema) ? schema[0] : schema\n          }\n        },\n        { immediate: true }\n      )\n      provide(SchemaMarkupSymbol, schemaRef)\n\n      return () => {\n        const children: Record<string, () => any> = {}\n        if (slots.default) {\n          children.default = () => slots.default()\n        }\n        return h(Fragment, {}, children)\n      }\n    },\n  })\n\n  const SchemaFieldFactory = (type: SchemaTypes, name: string) => {\n    return defineComponent<\n      ISchemaMarkupFieldProps<\n        Components,\n        ComponentPath<Components>,\n        ComponentPath<Components>\n      >\n    >({\n      name: name,\n      props: Object.assign({}, markupProps),\n      setup(\n        props: ISchemaMarkupFieldProps<\n          Components,\n          ComponentPath<Components>,\n          ComponentPath<Components>\n        >,\n        { slots }\n      ) {\n        return () =>\n          h(\n            MarkupField,\n            {\n              attrs: {\n                ...props,\n                type: type,\n              },\n            },\n            slots\n          )\n      },\n    })\n  }\n\n  return {\n    SchemaField,\n    SchemaMarkupField: MarkupField,\n    SchemaStringField: SchemaFieldFactory('string', 'SchemaStringField'),\n    SchemaObjectField: SchemaFieldFactory('object', 'SchemaObjectField'),\n    SchemaArrayField: SchemaFieldFactory('array', 'SchemaArrayField'),\n    SchemaBooleanField: SchemaFieldFactory('boolean', 'SchemaBooleanField'),\n    SchemaDateField: SchemaFieldFactory('date', 'SchemaDateField'),\n    SchemaDateTimeField: SchemaFieldFactory('datetime', 'SchemaDatetimeField'),\n    SchemaVoidField: SchemaFieldFactory('void', 'SchemaVoidField'),\n    SchemaNumberField: SchemaFieldFactory('number', 'SchemaNumberField'),\n  } as any\n}\n","import * as components from './components'\n\nimport type Vue from 'vue'\nimport type { VueConstructor } from 'vue'\nimport type {\n  IVoidFieldProps,\n  IArrayFieldProps,\n  IObjectFieldProps,\n  IFieldProps,\n  IRecursionFieldProps,\n  IProviderProps,\n  ISchemaMarkupFieldProps,\n  ISchemaFieldProps,\n  ISchemaFieldVueFactoryOptions,\n  ISchemaTypeFieldProps,\n  SchemaVueComponents,\n} from './types'\n\nconst {\n  Field: _Field,\n  ArrayField: _ArrayField,\n  FormConsumer: _FormConsumer,\n  FormProvider: _FormProvider,\n  ObjectField: _ObjectField,\n  RecursionField: _RecursionField,\n  VoidField: _VoidField,\n  createSchemaField: _createSchemaField,\n} = components\n\ntype DefineComponent<Props> = Vue & VueConstructor & Props\n\ntype SchemaFieldComponents = {\n  SchemaField: DefineComponent<Omit<ISchemaFieldProps, 'name' | 'components'>>\n  SchemaMarkupField: DefineComponent<ISchemaMarkupFieldProps>\n  SchemaStringField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaObjectField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaArrayField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaBooleanField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateTimeField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaVoidField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaNumberField: DefineComponent<ISchemaTypeFieldProps>\n}\n\ntype CreateSchemaField<\n  Components extends SchemaVueComponents = SchemaVueComponents\n> = (\n  options: ISchemaFieldVueFactoryOptions<Components>\n) => SchemaFieldComponents\n\nconst Field = _Field as unknown as DefineComponent<Omit<IFieldProps, 'name'>>\nconst ArrayField = _ArrayField as unknown as DefineComponent<\n  Omit<IArrayFieldProps, 'name'>\n>\nconst ObjectField = _ObjectField as unknown as DefineComponent<\n  Omit<IObjectFieldProps, 'name'>\n>\nconst VoidField = _VoidField as unknown as DefineComponent<\n  Omit<IVoidFieldProps, 'name'>\n>\nconst RecursionField = _RecursionField as unknown as DefineComponent<\n  Omit<IRecursionFieldProps, 'name'>\n>\nconst FormConsumer = _FormConsumer as unknown as Vue\nconst FormProvider = _FormProvider as unknown as DefineComponent<IProviderProps>\nconst createSchemaField = _createSchemaField as unknown as CreateSchemaField\n\nexport {\n  Field,\n  ArrayField,\n  ObjectField,\n  VoidField,\n  RecursionField,\n  FormConsumer,\n  FormProvider,\n  createSchemaField,\n}\n"],"names":["shallowRef","onMounted","onBeforeUnmount","provide","ref","FragmentComponent","h","defineComponent","watch","inject","toRaw","computed","components.Field","components.ArrayField","components.FormConsumer","components.FormProvider","components.ObjectField","components.RecursionField","components.VoidField","components.createSchemaField"],"mappings":";;;;;;;;;;;;;;;;;;IAGA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;IAKA;IACA;IACA;IACA;IACA,YAAY,yBAAU;IACtB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,YAAY,mBAAI;IAChB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,mDAAmD,mBAAI;IACvD;IACA;IACA;IACA,YAAY,yBAAU;IACtB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,YAAY,mBAAI;IAChB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,mBAAI;IACZ;IACA;IACA,QAAQ,mBAAI;IACZ;IACA;IACA,QAAQ,6BAAY;IACpB;IACA;IACA;IACA;;IAEA,WAAW,oBAAK;IAChB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA,IAAI,0BAAS;IACb;IACA,mBAAmB,uBAAQ;IAC3B;IACA;IACA,uCAAuC,oBAAK;IAC5C;IACA;IACA,YAAY,uBAAQ;IACpB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;ICrLA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;;IAEA,QAAQ,mBAAI;IACZ;IACA;IACA;;IAEA,QAAQ,oBAAK;IACb;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA,YAAY,oBAAK;IACjB;IACA;IACA,iBAAiB,oBAAK;IACtB;IACA;IACA,iBAAiB,yBAAU;IAC3B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,0BAA0B,qBAAM;IAChC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA,mBAAmB,uBAAQ;IAC3B;IACA;IACA;IACA;IACA;IACA,YAAY,0BAAS,sBAAsB,uBAAQ;IACnD;IACA;IACA;;IAEA;IACA;IACA;IACA,wBAAwB,6BAAY;IACpC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IChGA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAMA;IACA,iBAAiB,wBAAW;IAC5B,kBAAkB,yBAAY;IAC9B,oBAAoB,2BAAc;IAClC,wBAAwB,+BAAkB;IAC1C,6BAA6B,oCAAuB;IACpD,+BAA+B,sCAAyB;IACxD,0BAA0B,iCAAoB;IAC9C,wBAAwB,+BAAkB;IAC1C,2BAA2B,kCAAqB;IAChD,4BAA4B,mCAAsB;IAClD;IACA;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,oBAAK;IACb;IACA;IACA,gBAAgB,oBAAK;IACrB;IACA;IACA,qBAAqB,yBAAU;IAC/B;IACA;IACA;IACA;IACA;IACA;IACA;IACA,aAAa,yBAAU;IACvB,eAAe,qBAAM;IACrB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,YAAY,oBAAK;IACjB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,YAAY,oBAAK;IACjB;IACA;IACA;IACA;IACA;IACA;IACA;IACA,eAAe,wBAAO,2BAA2B,2BAAU;IAC3D;IACA;IACA,kBAAkB,wBAAO;IACzB,gBAAgB,wBAAO;IACvB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,oBAAoB,oBAAK;IACzB;IACA;IACA;IACA;IACA;IACA,YAAY,mBAAI;IAChB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,YAAY,wBAAO;IACnB,gBAAgB,0BAAS;IACzB,oBAAoB,mBAAI;IACxB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;ICtLA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AAC8C;IAC9C;IACA;;IAEA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA,YAAY,mBAAI;IAChB;IACA;IACA;IACA;;IAEA,mBAAmB,mBAAI;IACvB;IACA;IACA;IACA;;IAEA,QAAQ,oBAAK;IACb;IACA,gBAAgB,oBAAK;IACrB;IACA;IACA;IACA;IACA;IACA;IACA;;IC9CA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AAE0E;IAC1E;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,oBAAK;IACb;IACA;IACA;IACA;IACA,QAAQ,oBAAK;IACb;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,QAAQ,sBAAO;IACf;IACA;IACA;IACA,QAAQ,sBAAO;IACf;IACA;IACA;IACA,QAAQ,sBAAO;IACf;IACA;IACA;IACA;IACA,QAAQ,sBAAO;IACf;IACA;IACA;IACA;IACA;IACA,gCAAgC,oBAAK;IACrC;IACA;IACA;IACA,+DAA+D,wBAAS,gBAAgB,wBAAS;IACjG;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;;IAEA;IACA;;;ICpJA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,wCAAwC,oBAAK;IAC7C;IACA;IACA;IACA,mBAAmB,uBAAQ;IAC3B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,YAAY,mBAAI;IAChB,oBAAoB,mBAAI;IACxB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,YAAY,mBAAI;IAChB,oBAAoB,mBAAI;IACxB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;I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"}
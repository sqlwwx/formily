{"version":3,"file":"formily.vue.umd.production.js","sources":["../../json-schema/esm/shared.js","../../json-schema/esm/compiler.js","../../json-schema/esm/transformer.js","../../json-schema/esm/patches.js","../../json-schema/esm/polyfills/SPECIFICATION_1_0.js","../../json-schema/esm/schema.js","../../../node_modules/vue-frag/dist/frag.esm.js","../src/shared/context.ts","../src/hooks/useAttach.ts","../src/shared/fragment.ts","../src/shared/h.ts","../src/components/FormProvider.ts","../src/hooks/useInjectionCleaner.ts","../src/hooks/useForm.ts","../src/hooks/useField.ts","../src/components/FormConsumer.ts","../src/components/ReactiveField.ts","../src/utils/getRawComponent.ts","../src/components/ArrayField.ts","../src/components/ObjectField.ts","../src/components/VoidField.ts","../src/components/Field.ts","../src/components/RecursionField.ts","../src/components/SchemaField.ts","../src/utils/resolveSchemaProps.ts","../src/vue2-components.ts","../src/shared/createForm.ts","../src/shared/connect.ts","../src/hooks/useFieldSchema.ts","../src/hooks/useFormEffects.ts","../src/hooks/useParentForm.ts"],"sourcesContent":["import { isFn, each, isPlainObj, isArr, toArr, FormPath } from '@formily/shared';\nimport { isObservable, untracked } from '@formily/reactive';\nimport { Schema } from './schema';\nvar REVA_ACTIONS_KEY = Symbol.for('__REVA_ACTIONS');\nexport var SchemaNestedMap = {\n    parent: true,\n    root: true,\n    properties: true,\n    patternProperties: true,\n    additionalProperties: true,\n    items: true,\n    additionalItems: true,\n    'x-linkages': true,\n    'x-reactions': true,\n};\nexport var SchemaStateMap = {\n    title: 'title',\n    description: 'description',\n    default: 'initialValue',\n    enum: 'dataSource',\n    readOnly: 'readOnly',\n    writeOnly: 'editable',\n    'x-content': 'content',\n    'x-data': 'data',\n    'x-value': 'value',\n    'x-editable': 'editable',\n    'x-disabled': 'disabled',\n    'x-read-pretty': 'readPretty',\n    'x-read-only': 'readOnly',\n    'x-visible': 'visible',\n    'x-hidden': 'hidden',\n    'x-display': 'display',\n    'x-pattern': 'pattern',\n    'x-validator': 'validator',\n    'x-decorator': 'decoratorType',\n    'x-component': 'componentType',\n    'x-decorator-props': 'decoratorProps',\n    'x-component-props': 'componentProps',\n};\nexport var SchemaValidatorMap = {\n    required: true,\n    format: true,\n    maxItems: true,\n    minItems: true,\n    maxLength: true,\n    minLength: true,\n    maximum: true,\n    minimum: true,\n    exclusiveMaximum: true,\n    exclusiveMinimum: true,\n    pattern: true,\n    const: true,\n    multipleOf: true,\n    maxProperties: true,\n    minProperties: true,\n    uniqueItems: true,\n};\nexport var SchemaNormalKeys = Object.keys(SchemaStateMap);\nexport var SchemaValidatorKeys = Object.keys(SchemaValidatorMap);\nexport var hasOwnProperty = Object.prototype.hasOwnProperty;\nexport var traverse = function (target, visitor) {\n    var seenObjects = [];\n    var root = target;\n    var traverse = function (target, path) {\n        if (path === void 0) { path = []; }\n        if (isPlainObj(target)) {\n            var seenIndex = seenObjects.indexOf(target);\n            if (seenIndex > -1) {\n                return;\n            }\n            var addIndex = seenObjects.length;\n            seenObjects.push(target);\n            if (isNoNeedCompileObject(target) && root !== target) {\n                visitor(target, path);\n                return;\n            }\n            each(target, function (value, key) {\n                traverse(value, path.concat(key));\n            });\n            seenObjects.splice(addIndex, 1);\n        }\n        else {\n            visitor(target, path);\n        }\n    };\n    traverse(target);\n};\nexport var traverseSchema = function (schema, visitor) {\n    if (schema['x-validator'] !== undefined) {\n        visitor(schema['x-validator'], ['x-validator']);\n    }\n    var seenObjects = [];\n    var root = schema;\n    var traverse = function (target, path) {\n        if (path === void 0) { path = []; }\n        if (path[0] === 'x-validator' ||\n            path[0] === 'version' ||\n            path[0] === '_isJSONSchemaObject')\n            return;\n        if (String(path[0]).indexOf('x-') == -1 && isFn(target))\n            return;\n        if (SchemaNestedMap[path[0]])\n            return;\n        if (isPlainObj(target)) {\n            if (path[0] === 'default' || path[0] === 'x-value') {\n                visitor(target, path);\n                return;\n            }\n            var seenIndex = seenObjects.indexOf(target);\n            if (seenIndex > -1) {\n                return;\n            }\n            var addIndex = seenObjects.length;\n            seenObjects.push(target);\n            if (isNoNeedCompileObject(target) && root !== target) {\n                visitor(target, path);\n                return;\n            }\n            each(target, function (value, key) {\n                traverse(value, path.concat(key));\n            });\n            seenObjects.splice(addIndex, 1);\n        }\n        else {\n            visitor(target, path);\n        }\n    };\n    traverse(schema);\n};\nexport var isNoNeedCompileObject = function (source) {\n    if ('$$typeof' in source && '_owner' in source) {\n        return true;\n    }\n    if (source['_isAMomentObject']) {\n        return true;\n    }\n    if (Schema.isSchemaInstance(source)) {\n        return true;\n    }\n    if (source[REVA_ACTIONS_KEY]) {\n        return true;\n    }\n    if (isFn(source['toJS'])) {\n        return true;\n    }\n    if (isFn(source['toJSON'])) {\n        return true;\n    }\n    if (isObservable(source)) {\n        return true;\n    }\n    return false;\n};\nexport var createDataSource = function (source) {\n    return toArr(source).map(function (item) {\n        if (typeof item === 'object') {\n            return item;\n        }\n        else {\n            return {\n                label: item,\n                value: item,\n            };\n        }\n    });\n};\nexport var patchStateFormSchema = function (targetState, pattern, compiled) {\n    untracked(function () {\n        var _a;\n        var path = FormPath.parse(pattern);\n        var segments = path.segments;\n        var key = segments[0];\n        var isEnum = key === 'enum' && isArr(compiled);\n        var schemaMapKey = SchemaStateMap[key];\n        if (schemaMapKey) {\n            FormPath.setIn(targetState, [schemaMapKey].concat(segments.slice(1)), isEnum ? createDataSource(compiled) : compiled);\n        }\n        else {\n            var isValidatorKey = SchemaValidatorMap[key];\n            if (isValidatorKey) {\n                (_a = targetState['setValidatorRule']) === null || _a === void 0 ? void 0 : _a.call(targetState, key, compiled);\n            }\n        }\n    });\n};\n//# sourceMappingURL=shared.js.map","import { isArr, isFn, isPlainObj, isStr, reduce, FormPath, } from '@formily/shared';\nimport { untracked, hasCollected } from '@formily/reactive';\nimport { traverse, traverseSchema, isNoNeedCompileObject, hasOwnProperty, patchStateFormSchema, } from './shared';\nvar ExpRE = /^\\s*\\{\\{([\\s\\S]*)\\}\\}\\s*$/;\nvar Registry = {\n    silent: false,\n    compile: function (expression, scope) {\n        if (scope === void 0) { scope = {}; }\n        if (Registry.silent) {\n            try {\n                return new Function('$root', \"with($root) { return (\".concat(expression, \"); }\"))(scope);\n            }\n            catch (_a) { }\n        }\n        else {\n            return new Function('$root', \"with($root) { return (\".concat(expression, \"); }\"))(scope);\n        }\n    },\n};\nexport var silent = function (value) {\n    if (value === void 0) { value = true; }\n    Registry.silent = !!value;\n};\nexport var registerCompiler = function (compiler) {\n    if (isFn(compiler)) {\n        Registry.compile = compiler;\n    }\n};\nexport var shallowCompile = function (source, scope) {\n    if (isStr(source)) {\n        var matched = source.match(ExpRE);\n        if (!matched)\n            return source;\n        return Registry.compile(matched[1], scope);\n    }\n    return source;\n};\nexport var compile = function (source, scope) {\n    var seenObjects = [];\n    var compile = function (source) {\n        if (isStr(source)) {\n            return shallowCompile(source, scope);\n        }\n        else if (isArr(source)) {\n            return source.map(function (value) { return compile(value); });\n        }\n        else if (isPlainObj(source)) {\n            if (isNoNeedCompileObject(source))\n                return source;\n            var seenIndex = seenObjects.indexOf(source);\n            if (seenIndex > -1) {\n                return source;\n            }\n            var addIndex = seenObjects.length;\n            seenObjects.push(source);\n            var results = reduce(source, function (buf, value, key) {\n                buf[key] = compile(value);\n                return buf;\n            }, {});\n            seenObjects.splice(addIndex, 1);\n            return results;\n        }\n        return source;\n    };\n    return compile(source);\n};\nexport var patchCompile = function (targetState, sourceState, scope) {\n    traverse(sourceState, function (value, pattern) {\n        var path = FormPath.parse(pattern);\n        var compiled = compile(value, scope);\n        var key = path.segments[0];\n        if (compiled === undefined)\n            return;\n        if (hasOwnProperty.call(targetState, key)) {\n            untracked(function () { return FormPath.setIn(targetState, path, compiled); });\n        }\n    });\n};\nexport var patchSchemaCompile = function (targetState, sourceSchema, scope, demand) {\n    if (demand === void 0) { demand = false; }\n    traverseSchema(sourceSchema, function (value, path) {\n        var compiled = value;\n        var collected = hasCollected(function () {\n            compiled = compile(value, scope);\n        });\n        if (compiled === undefined)\n            return;\n        if (demand) {\n            if (collected || !targetState.initialized) {\n                patchStateFormSchema(targetState, path, compiled);\n            }\n        }\n        else {\n            patchStateFormSchema(targetState, path, compiled);\n        }\n    });\n};\n//# sourceMappingURL=compiler.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n/* istanbul ignore file */\nimport { untracked, autorun, observable } from '@formily/reactive';\nimport { isArr, isStr, toArr, each, isFn, isPlainObj, reduce, } from '@formily/shared';\nimport { onFieldInit, onFieldMount, onFieldUnmount, onFieldValueChange, onFieldInputValueChange, onFieldInitialValueChange, onFieldValidateStart, onFieldValidateEnd, onFieldValidateFailed, onFieldValidateSuccess, } from '@formily/core';\nimport { patchCompile, patchSchemaCompile, shallowCompile } from './compiler';\nvar FieldEffects = {\n    onFieldInit: onFieldInit,\n    onFieldMount: onFieldMount,\n    onFieldUnmount: onFieldUnmount,\n    onFieldValueChange: onFieldValueChange,\n    onFieldInputValueChange: onFieldInputValueChange,\n    onFieldInitialValueChange: onFieldInitialValueChange,\n    onFieldValidateStart: onFieldValidateStart,\n    onFieldValidateEnd: onFieldValidateEnd,\n    onFieldValidateFailed: onFieldValidateFailed,\n    onFieldValidateSuccess: onFieldValidateSuccess,\n};\nvar DefaultFieldEffects = ['onFieldInit', 'onFieldValueChange'];\nvar getDependencyValue = function (field, pattern, property) {\n    var _a = __read(String(pattern).split(/\\s*#\\s*/), 2), target = _a[0], path = _a[1];\n    return field.query(target).getIn(path || property || 'value');\n};\nvar getDependencies = function (field, dependencies) {\n    if (isArr(dependencies)) {\n        var results_1 = [];\n        dependencies.forEach(function (pattern) {\n            if (isStr(pattern)) {\n                results_1.push(getDependencyValue(field, pattern));\n            }\n            else if (isPlainObj(pattern)) {\n                if (pattern.name && pattern.source) {\n                    results_1[pattern.name] = getDependencyValue(field, pattern.source, pattern.property);\n                }\n            }\n        });\n        return results_1;\n    }\n    else if (isPlainObj(dependencies)) {\n        return reduce(dependencies, function (buf, pattern, key) {\n            buf[key] = getDependencyValue(field, pattern);\n            return buf;\n        }, {});\n    }\n    return [];\n};\nvar setSchemaFieldState = function (options, demand) {\n    if (demand === void 0) { demand = false; }\n    var _a = options || {}, request = _a.request, target = _a.target, runner = _a.runner, field = _a.field, scope = _a.scope;\n    if (!request)\n        return;\n    if (target) {\n        if (request.state) {\n            field.form.setFieldState(target, function (state) {\n                return patchCompile(state, request.state, __assign(__assign({}, scope), { $target: state }));\n            });\n        }\n        if (request.schema) {\n            field.form.setFieldState(target, function (state) {\n                return patchSchemaCompile(state, request.schema, __assign(__assign({}, scope), { $target: state }), demand);\n            });\n        }\n        if (isStr(runner) && runner) {\n            field.form.setFieldState(target, function (state) {\n                shallowCompile(\"{{function(){\".concat(runner, \"}}}\"), __assign(__assign({}, scope), { $target: state }))();\n            });\n        }\n    }\n    else {\n        if (request.state) {\n            field.setState(function (state) { return patchCompile(state, request.state, scope); });\n        }\n        if (request.schema) {\n            field.setState(function (state) {\n                return patchSchemaCompile(state, request.schema, scope, demand);\n            });\n        }\n        if (isStr(runner) && runner) {\n            shallowCompile(\"{{function(){\".concat(runner, \"}}}\"), scope)();\n        }\n    }\n};\nvar getBaseScope = function (field, options) {\n    if (options === void 0) { options = {}; }\n    var $observable = function (target, deps) {\n        return autorun.memo(function () { return observable(target); }, deps);\n    };\n    var $props = function (props) { return field.setComponentProps(props); };\n    var $effect = autorun.effect;\n    var $memo = autorun.memo;\n    var $self = field;\n    var $form = field.form;\n    var $values = field.form.values;\n    return __assign(__assign({}, options.scope), { $form: $form, $self: $self, $observable: $observable, $effect: $effect, $memo: $memo, $props: $props, $values: $values });\n};\nvar getBaseReactions = function (schema, options) { return function (field) {\n    setSchemaFieldState({\n        field: field,\n        request: { schema: schema },\n        scope: getBaseScope(field, options),\n    }, true);\n}; };\nvar getUserReactions = function (schema, options) { return function (field) {\n    var reactions = toArr(schema['x-reactions']);\n    var baseScope = getBaseScope(field, options);\n    reactions.forEach(function (unCompiled) {\n        var reaction = shallowCompile(unCompiled, baseScope);\n        if (!reaction)\n            return;\n        if (isFn(reaction)) {\n            return reaction(field);\n        }\n        var when = reaction.when, fulfill = reaction.fulfill, otherwise = reaction.otherwise, target = reaction.target, effects = reaction.effects;\n        var run = function () {\n            var $deps = getDependencies(field, reaction.dependencies);\n            var $dependencies = $deps;\n            var scope = __assign(__assign({}, baseScope), { $target: null, $deps: $deps, $dependencies: $dependencies });\n            var compiledWhen = shallowCompile(when, scope);\n            var condition = when ? compiledWhen : true;\n            var request = condition ? fulfill : otherwise;\n            var runner = condition ? fulfill === null || fulfill === void 0 ? void 0 : fulfill.run : otherwise === null || otherwise === void 0 ? void 0 : otherwise.run;\n            setSchemaFieldState({\n                field: field,\n                target: target,\n                request: request,\n                runner: runner,\n                scope: scope,\n            });\n        };\n        if (target) {\n            reaction.effects = (effects === null || effects === void 0 ? void 0 : effects.length) ? effects : DefaultFieldEffects;\n        }\n        if (reaction.effects) {\n            autorun.memo(function () {\n                untracked(function () {\n                    each(reaction.effects, function (type) {\n                        if (FieldEffects[type]) {\n                            FieldEffects[type](field.address, run);\n                        }\n                    });\n                });\n            }, []);\n        }\n        else {\n            run();\n        }\n    });\n}; };\nexport var transformFieldProps = function (schema, options) {\n    return {\n        name: schema.name,\n        reactions: [\n            getBaseReactions(schema, options),\n            getUserReactions(schema, options),\n        ],\n    };\n};\n//# sourceMappingURL=transformer.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { isFn, isArr } from '@formily/shared';\nvar patches = [];\nvar polyfills = {};\nexport var reducePatches = function (schema) {\n    return patches.reduce(function (buf, patch) {\n        return patch(buf);\n    }, __assign({}, schema));\n};\nexport var registerPatches = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    args.forEach(function (patch) {\n        if (isFn(patch)) {\n            patches.push(patch);\n        }\n    });\n};\nexport var registerPolyfills = function (version, patch) {\n    if (version && isFn(patch)) {\n        polyfills[version] = polyfills[version] || [];\n        polyfills[version].push(patch);\n    }\n};\nexport var enablePolyfills = function (versions) {\n    if (isArr(versions)) {\n        versions.forEach(function (version) {\n            if (isArr(polyfills[version])) {\n                polyfills[version].forEach(function (patch) {\n                    registerPatches(patch);\n                });\n            }\n        });\n    }\n};\n//# sourceMappingURL=patches.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { registerPolyfills } from '../patches';\nimport { toArr, isArr, isStr, lowerCase, isValid } from '@formily/shared';\nvar VOID_COMPONENTS = [\n    'card',\n    'block',\n    'grid-col',\n    'grid-row',\n    'grid',\n    'layout',\n    'step',\n    'tab',\n    'text-box',\n];\nvar TYPE_DEFAULT_COMPONENTS = {};\nvar transformCondition = function (condition) {\n    if (isStr(condition)) {\n        return condition.replace(/\\$value/, '$self.value');\n    }\n};\nvar transformXLinkage = function (linkages) {\n    if (isArr(linkages)) {\n        return linkages.reduce(function (buf, item) {\n            if (!item)\n                return buf;\n            if (item.type === 'value:visible') {\n                return buf.concat({\n                    target: item.target,\n                    when: transformCondition(item.condition),\n                    fulfill: {\n                        state: {\n                            visible: true,\n                        },\n                    },\n                    otherwise: {\n                        state: {\n                            visible: false,\n                        },\n                    },\n                });\n            }\n            else if (item.type === 'value:schema') {\n                return buf.concat({\n                    target: item.target,\n                    when: transformCondition(item.condition),\n                    fulfill: {\n                        schema: SpecificationV1Polyfill(__assign({ version: '1.0' }, item.schema)),\n                    },\n                    otherwise: {\n                        schema: SpecificationV1Polyfill(__assign({ version: '1.0' }, item.otherwise)),\n                    },\n                });\n            }\n            else if (item.type === 'value:state') {\n                return buf.concat({\n                    target: item.target,\n                    when: transformCondition(item.condition),\n                    fulfill: {\n                        state: item.state,\n                    },\n                    otherwise: {\n                        state: item.otherwise,\n                    },\n                });\n            }\n        }, []);\n    }\n    return [];\n};\nvar SpecificationV1Polyfill = function (schema) {\n    if (isValid(schema['editable'])) {\n        schema['x-editable'] = schema['x-editable'] || schema['editable'];\n        delete schema['editable'];\n    }\n    if (isValid(schema['visible'])) {\n        schema['x-visible'] = schema['x-visible'] || schema['visible'];\n        delete schema['visible'];\n    }\n    if (isValid(schema['display'])) {\n        schema['x-display'] =\n            schema['x-display'] || (schema['display'] ? 'visible' : 'hidden');\n        delete schema['display'];\n    }\n    if (isValid(schema['x-props'])) {\n        schema['x-decorator-props'] =\n            schema['x-decorator-props'] || schema['x-props'];\n        delete schema['display'];\n    }\n    if (schema['x-linkages']) {\n        schema['x-reactions'] = toArr(schema['x-reactions']).concat(transformXLinkage(schema['x-linkages']));\n        delete schema['x-linkages'];\n    }\n    if (schema['x-component']) {\n        if (VOID_COMPONENTS.some(function (component) { return lowerCase(component) === lowerCase(schema['x-component']); })) {\n            schema['type'] = 'void';\n        }\n    }\n    else {\n        if (TYPE_DEFAULT_COMPONENTS[schema['type']]) {\n            schema['x-component'] = TYPE_DEFAULT_COMPONENTS[schema['type']];\n        }\n    }\n    if (!schema['x-decorator'] &&\n        schema['type'] !== 'void' &&\n        schema['type'] !== 'object') {\n        schema['x-decorator'] = schema['x-decorator'] || 'FormItem';\n    }\n    if (schema['x-rules']) {\n        schema['x-validator'] = []\n            .concat(schema['x-validator'] || [])\n            .concat(schema['x-rules']);\n    }\n    return schema;\n};\nregisterPolyfills('1.0', SpecificationV1Polyfill);\nexport var registerVoidComponents = function (components) {\n    VOID_COMPONENTS.push.apply(VOID_COMPONENTS, __spreadArray([], __read(components), false));\n};\nexport var registerTypeDefaultComponents = function (maps) {\n    Object.assign(TYPE_DEFAULT_COMPONENTS, maps);\n};\n//# sourceMappingURL=SPECIFICATION_1_0.js.map","import { map, each, isFn, instOf, FormPath, isStr } from '@formily/shared';\nimport { compile, silent, shallowCompile, registerCompiler } from './compiler';\nimport { transformFieldProps } from './transformer';\nimport { reducePatches, registerPatches, registerPolyfills, enablePolyfills, } from './patches';\nimport { registerVoidComponents, registerTypeDefaultComponents, } from './polyfills';\nimport { SchemaNestedMap } from './shared';\nvar Schema = /** @class */ (function () {\n    function Schema(json, parent) {\n        var _this = this;\n        this._isJSONSchemaObject = true;\n        this.version = '2.0';\n        this.addProperty = function (key, schema) {\n            _this.properties = _this.properties || {};\n            _this.properties[key] = new Schema(schema, _this);\n            _this.properties[key].name = key;\n            return _this.properties[key];\n        };\n        this.removeProperty = function (key) {\n            var schema = _this.properties[key];\n            delete _this.properties[key];\n            return schema;\n        };\n        this.setProperties = function (properties) {\n            for (var key in properties) {\n                _this.addProperty(key, properties[key]);\n            }\n            return _this;\n        };\n        this.addPatternProperty = function (key, schema) {\n            if (!schema)\n                return;\n            _this.patternProperties = _this.patternProperties || {};\n            _this.patternProperties[key] = new Schema(schema, _this);\n            _this.patternProperties[key].name = key;\n            return _this.patternProperties[key];\n        };\n        this.removePatternProperty = function (key) {\n            var schema = _this.patternProperties[key];\n            delete _this.patternProperties[key];\n            return schema;\n        };\n        this.setPatternProperties = function (properties) {\n            if (!properties)\n                return _this;\n            for (var key in properties) {\n                _this.addPatternProperty(key, properties[key]);\n            }\n            return _this;\n        };\n        this.setAdditionalProperties = function (properties) {\n            if (!properties)\n                return;\n            _this.additionalProperties = new Schema(properties);\n            return _this.additionalProperties;\n        };\n        this.setItems = function (schema) {\n            if (!schema)\n                return;\n            if (Array.isArray(schema)) {\n                _this.items = schema.map(function (item) { return new Schema(item, _this); });\n            }\n            else {\n                _this.items = new Schema(schema, _this);\n            }\n            return _this.items;\n        };\n        this.setAdditionalItems = function (items) {\n            if (!items)\n                return;\n            _this.additionalItems = new Schema(items, _this);\n            return _this.additionalItems;\n        };\n        this.findDefinitions = function (ref) {\n            if (!ref || !_this.root || !isStr(ref))\n                return;\n            if (ref.indexOf('#/') !== 0)\n                return;\n            return FormPath.getIn(_this.root, ref.substring(2).split('/'));\n        };\n        this.mapProperties = function (callback) {\n            return Schema.getOrderProperties(_this).map(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                return callback(schema, key, index);\n            });\n        };\n        this.mapPatternProperties = function (callback) {\n            return Schema.getOrderProperties(_this, 'patternProperties').map(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                return callback(schema, key, index);\n            });\n        };\n        this.reduceProperties = function (callback, predicate) {\n            var results = predicate;\n            Schema.getOrderProperties(_this, 'properties').forEach(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                results = callback(results, schema, key, index);\n            });\n            return results;\n        };\n        this.reducePatternProperties = function (callback, predicate) {\n            var results = predicate;\n            Schema.getOrderProperties(_this, 'patternProperties').forEach(function (_a, index) {\n                var schema = _a.schema, key = _a.key;\n                results = callback(results, schema, key, index);\n            });\n            return results;\n        };\n        this.compile = function (scope) {\n            var schema = new Schema({}, _this.parent);\n            each(_this, function (value, key) {\n                if (isFn(value) && !key.includes('x-'))\n                    return;\n                if (key === 'parent' || key === 'root')\n                    return;\n                if (!SchemaNestedMap[key]) {\n                    schema[key] = value ? compile(value, scope) : value;\n                }\n                else {\n                    schema[key] = value ? shallowCompile(value, scope) : value;\n                }\n            });\n            return schema;\n        };\n        this.fromJSON = function (json) {\n            if (!json)\n                return _this;\n            if (Schema.isSchemaInstance(json))\n                return json;\n            each(reducePatches(json), function (value, key) {\n                if (isFn(value) && !key.includes('x-'))\n                    return;\n                if (key === 'properties') {\n                    _this.setProperties(value);\n                }\n                else if (key === 'patternProperties') {\n                    _this.setPatternProperties(value);\n                }\n                else if (key === 'additionalProperties') {\n                    _this.setAdditionalProperties(value);\n                }\n                else if (key === 'items') {\n                    _this.setItems(value);\n                }\n                else if (key === 'additionalItems') {\n                    _this.setAdditionalItems(value);\n                }\n                else if (key === '$ref') {\n                    _this.fromJSON(_this.findDefinitions(value));\n                }\n                else {\n                    _this[key] = value;\n                }\n            });\n            return _this;\n        };\n        this.toJSON = function (recursion) {\n            if (recursion === void 0) { recursion = true; }\n            var results = {};\n            each(_this, function (value, key) {\n                var _a, _b;\n                if ((isFn(value) && !key.includes('x-')) ||\n                    key === 'parent' ||\n                    key === 'root')\n                    return;\n                if (key === 'properties' || key === 'patternProperties') {\n                    if (!recursion)\n                        return;\n                    results[key] = map(value, function (item) { var _a; return (_a = item === null || item === void 0 ? void 0 : item.toJSON) === null || _a === void 0 ? void 0 : _a.call(item); });\n                }\n                else if (key === 'additionalProperties' || key === 'additionalItems') {\n                    if (!recursion)\n                        return;\n                    results[key] = (_a = value === null || value === void 0 ? void 0 : value.toJSON) === null || _a === void 0 ? void 0 : _a.call(value);\n                }\n                else if (key === 'items') {\n                    if (!recursion)\n                        return;\n                    if (Array.isArray(value)) {\n                        results[key] = value.map(function (item) { var _a; return (_a = item === null || item === void 0 ? void 0 : item.toJSON) === null || _a === void 0 ? void 0 : _a.call(item); });\n                    }\n                    else {\n                        results[key] = (_b = value === null || value === void 0 ? void 0 : value.toJSON) === null || _b === void 0 ? void 0 : _b.call(value);\n                    }\n                }\n                else {\n                    results[key] = value;\n                }\n            });\n            return results;\n        };\n        this.toFieldProps = function (options) {\n            return transformFieldProps(_this, options);\n        };\n        if (parent) {\n            this.parent = parent;\n            this.root = parent.root;\n        }\n        else {\n            this.root = this;\n        }\n        return this.fromJSON(json);\n    }\n    Schema.getOrderProperties = function (schema, propertiesName) {\n        if (schema === void 0) { schema = {}; }\n        if (propertiesName === void 0) { propertiesName = 'properties'; }\n        var orderProperties = [];\n        var unorderProperties = [];\n        for (var key in schema[propertiesName]) {\n            var item = schema[propertiesName][key];\n            var index = item['x-index'];\n            if (!isNaN(index)) {\n                orderProperties[index] = { schema: item, key: key };\n            }\n            else {\n                unorderProperties.push({ schema: item, key: key });\n            }\n        }\n        return orderProperties.concat(unorderProperties).filter(function (item) { return !!item; });\n    };\n    Schema.compile = function (expression, scope) {\n        return compile(expression, scope);\n    };\n    Schema.shallowCompile = function (expression, scope) {\n        return shallowCompile(expression, scope);\n    };\n    Schema.isSchemaInstance = function (value) {\n        return instOf(value, Schema);\n    };\n    Schema.registerCompiler = registerCompiler;\n    Schema.registerPatches = registerPatches;\n    Schema.registerVoidComponents = registerVoidComponents;\n    Schema.registerTypeDefaultComponents = registerTypeDefaultComponents;\n    Schema.registerPolyfills = registerPolyfills;\n    Schema.enablePolyfills = enablePolyfills;\n    Schema.silent = silent;\n    return Schema;\n}());\nexport { Schema };\n//# sourceMappingURL=schema.js.map","var $placeholder = Symbol();\n\nvar $fakeParent = Symbol();\n\nvar nextSiblingPatched = Symbol();\n\nvar childNodesPatched = Symbol();\n\nvar isFrag = function isFrag(node) {\n    return \"frag\" in node;\n};\n\nfunction patchParentNode(node, fakeParent) {\n    if ($fakeParent in node) {\n        return;\n    }\n    node[$fakeParent] = fakeParent;\n    Object.defineProperty(node, \"parentNode\", {\n        get: function get() {\n            return this[$fakeParent] || this.parentElement;\n        }\n    });\n}\n\nfunction patchNextSibling(node) {\n    if (nextSiblingPatched in node) {\n        return;\n    }\n    node[nextSiblingPatched] = true;\n    Object.defineProperty(node, \"nextSibling\", {\n        get: function get() {\n            var childNodes = this.parentNode.childNodes;\n            var index = childNodes.indexOf(this);\n            if (index > -1) {\n                return childNodes[index + 1] || null;\n            }\n            return null;\n        }\n    });\n}\n\nfunction getTopFragment(node, fromParent) {\n    while (node.parentNode !== fromParent) {\n        var _node = node, parentNode = _node.parentNode;\n        if (parentNode) {\n            node = parentNode;\n        }\n    }\n    return node;\n}\n\nvar getChildNodes;\n\nfunction getChildNodesWithFragments(node) {\n    if (!getChildNodes) {\n        var childNodesDescriptor = Object.getOwnPropertyDescriptor(Node.prototype, \"childNodes\");\n        getChildNodes = childNodesDescriptor.get;\n    }\n    var realChildNodes = getChildNodes.apply(node);\n    var childNodes = Array.from(realChildNodes).map((function(childNode) {\n        return getTopFragment(childNode, node);\n    }));\n    return childNodes.filter((function(childNode, index) {\n        return childNode !== childNodes[index - 1];\n    }));\n}\n\nfunction patchChildNodes(node) {\n    if (childNodesPatched in node) {\n        return;\n    }\n    node[childNodesPatched] = true;\n    Object.defineProperties(node, {\n        childNodes: {\n            get: function get() {\n                return this.frag || getChildNodesWithFragments(this);\n            }\n        },\n        firstChild: {\n            get: function get() {\n                return this.childNodes[0] || null;\n            }\n        }\n    });\n    node.hasChildNodes = function() {\n        return this.childNodes.length > 0;\n    };\n}\n\nfunction before() {\n    var _this$frag$;\n    (_this$frag$ = this.frag[0]).before.apply(_this$frag$, arguments);\n}\n\nfunction remove() {\n    var frag = this.frag;\n    var removed = frag.splice(0, frag.length);\n    removed.forEach((function(node) {\n        node.remove();\n    }));\n}\n\nvar getFragmentLeafNodes = function getFragmentLeafNodes(children) {\n    var _Array$prototype;\n    return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, children.map((function(childNode) {\n        return isFrag(childNode) ? getFragmentLeafNodes(childNode.frag) : childNode;\n    })));\n};\n\nfunction addPlaceholder(node, insertBeforeNode) {\n    var placeholder = node[$placeholder];\n    insertBeforeNode.before(placeholder);\n    patchParentNode(placeholder, node);\n    node.frag.unshift(placeholder);\n}\n\nfunction removeChild(node) {\n    if (isFrag(this)) {\n        var hasChildInFragment = this.frag.indexOf(node);\n        if (hasChildInFragment > -1) {\n            var _this$frag$splice = this.frag.splice(hasChildInFragment, 1), removedNode = _this$frag$splice[0];\n            if (this.frag.length === 0) {\n                addPlaceholder(this, removedNode);\n            }\n            node.remove();\n        }\n    } else {\n        var children = getChildNodesWithFragments(this);\n        var hasChild = children.indexOf(node);\n        if (hasChild > -1) {\n            node.remove();\n        }\n    }\n    return node;\n}\n\nfunction insertBefore(insertNode, insertBeforeNode) {\n    var _this = this;\n    var insertNodes = insertNode.frag || [ insertNode ];\n    if (isFrag(this)) {\n        var _frag = this.frag;\n        if (insertBeforeNode) {\n            var index = _frag.indexOf(insertBeforeNode);\n            if (index > -1) {\n                _frag.splice.apply(_frag, [ index, 0 ].concat(insertNodes));\n                insertBeforeNode.before.apply(insertBeforeNode, insertNodes);\n            }\n        } else {\n            var _lastNode = _frag[_frag.length - 1];\n            _frag.push.apply(_frag, insertNodes);\n            _lastNode.after.apply(_lastNode, insertNodes);\n        }\n        removePlaceholder(this);\n    } else if (insertBeforeNode) {\n        if (this.childNodes.includes(insertBeforeNode)) {\n            insertBeforeNode.before.apply(insertBeforeNode, insertNodes);\n        }\n    } else {\n        this.append.apply(this, insertNodes);\n    }\n    insertNodes.forEach((function(node) {\n        patchParentNode(node, _this);\n    }));\n    var lastNode = insertNodes[insertNodes.length - 1];\n    patchNextSibling(lastNode);\n    return insertNode;\n}\n\nfunction appendChild(node) {\n    var frag = this.frag;\n    var lastChild = frag[frag.length - 1];\n    lastChild.after(node);\n    patchParentNode(node, this);\n    removePlaceholder(this);\n    frag.push(node);\n    return node;\n}\n\nfunction removePlaceholder(node) {\n    var placeholder = node[$placeholder];\n    if (node.frag[0] === placeholder) {\n        node.frag.shift();\n        placeholder.remove();\n    }\n}\n\nvar frag = {\n    inserted: function inserted(element) {\n        var parentNode = element.parentNode, nextSibling = element.nextSibling, previousSibling = element.previousSibling;\n        var childNodes = Array.from(element.childNodes);\n        var placeholder = document.createComment(\"\");\n        if (childNodes.length === 0) {\n            childNodes.push(placeholder);\n        }\n        element.frag = childNodes;\n        element[$placeholder] = placeholder;\n        var fragment = document.createDocumentFragment();\n        fragment.append.apply(fragment, getFragmentLeafNodes(childNodes));\n        element.replaceWith(fragment);\n        childNodes.forEach((function(node) {\n            patchParentNode(node, element);\n            patchNextSibling(node);\n        }));\n        patchChildNodes(element);\n        Object.assign(element, {\n            remove: remove,\n            appendChild: appendChild,\n            insertBefore: insertBefore,\n            removeChild: removeChild,\n            before: before\n        });\n        Object.defineProperty(element, \"innerHTML\", {\n            set: function set(htmlString) {\n                var _this2 = this;\n                var domify = document.createElement(\"div\");\n                domify.innerHTML = htmlString;\n                var oldNodesIndex = this.frag.length;\n                Array.from(domify.childNodes).forEach((function(node) {\n                    _this2.appendChild(node);\n                }));\n                domify.append.apply(domify, this.frag.splice(0, oldNodesIndex));\n            },\n            get: function get() {\n                return \"\";\n            }\n        });\n        if (parentNode) {\n            Object.assign(parentNode, {\n                removeChild: removeChild,\n                insertBefore: insertBefore\n            });\n            patchParentNode(element, parentNode);\n            patchChildNodes(parentNode);\n        }\n        if (nextSibling) {\n            patchNextSibling(element);\n        }\n        if (previousSibling) {\n            patchNextSibling(previousSibling);\n        }\n    },\n    unbind: function unbind(element) {\n        element.remove();\n    }\n};\n\nvar fragment = {\n    directives: {\n        frag: frag\n    },\n    render: function render(h) {\n        return h(\"div\", {\n            directives: [ {\n                name: \"frag\"\n            } ]\n        }, this.$slots[\"default\"]);\n    }\n};\n\nexport { fragment as Fragment, frag as default };\n","import { InjectionKey, Ref } from 'vue-demi'\nimport { Form, GeneralField } from '@formily/core'\nimport { Schema } from '@formily/json-schema'\nimport { ISchemaFieldVueFactoryOptions } from '../types'\nexport const FormSymbol: InjectionKey<Ref<Form>> = Symbol('form')\nexport const FieldSymbol: InjectionKey<Ref<GeneralField>> = Symbol('field')\nexport const SchemaMarkupSymbol: InjectionKey<Ref<Schema>> =\n  Symbol('schemaMarkup')\nexport const SchemaSymbol: InjectionKey<Ref<Schema>> = Symbol('schema')\nexport const SchemaExpressionScopeSymbol: InjectionKey<\n  Ref<Record<string, any>>\n> = Symbol('schemaExpression')\nexport const SchemaOptionsSymbol: InjectionKey<\n  Ref<ISchemaFieldVueFactoryOptions>\n> = Symbol('schemaOptions')\n","import { onBeforeUnmount, onMounted, shallowRef, Ref } from 'vue-demi'\n\ninterface IRecycleTarget {\n  onMount: () => void\n  onUnmount: () => void\n}\n\nexport const useAttach = <T extends IRecycleTarget>(\n  target: T\n): [Ref<T>, (arg: T) => T] => {\n  const oldTargetRef = shallowRef<T>(null)\n  oldTargetRef.value = target\n  onMounted(() => {\n    target.onMount()\n  })\n\n  onBeforeUnmount(() => {\n    oldTargetRef.value?.onUnmount()\n  })\n\n  const checker = (target: T) => {\n    if (target !== oldTargetRef.value) {\n      if (oldTargetRef.value) {\n        oldTargetRef.value.onUnmount()\n      }\n      oldTargetRef.value = target\n      target.onMount()\n    }\n    return oldTargetRef.value as T\n  }\n\n  return [oldTargetRef, checker]\n}\n","import frag from 'vue-frag'\nimport { VueComponent } from '../types'\nimport { isVue2, defineComponent } from 'vue-demi'\n\nexport const Fragment = '#fragment'\n\nlet FragmentComponent: VueComponent\n\nif (isVue2) {\n  FragmentComponent = {\n    name: 'Fragment',\n    directives: {\n      frag,\n    },\n    render(h) {\n      const vm = this as any\n      return h(\n        'div',\n        {\n          directives: [\n            {\n              name: 'frag',\n            },\n          ],\n        },\n        vm?.$scopedSlots?.default?.(vm.$attrs)\n      )\n    },\n  }\n} else {\n  /* istanbul ignore next */\n  FragmentComponent = defineComponent({\n    name: 'Fragment',\n    setup(props: Record<string, any>, { slots, attrs }) {\n      return () => slots?.default?.(attrs)\n    },\n  })\n}\n\nexport { FragmentComponent }\n","import { h, isVue2 } from 'vue-demi'\nimport { Fragment, FragmentComponent } from './fragment'\n\ntype RenderChildren = {\n  [key in string]?: (...args: any[]) => (VNode | string)[]\n}\n\n// TODO: need to compatible with vue2 & vue3\ntype Tag = any\ntype VNodeData = Record<string, any>\ntype VNode = any\ntype VNodeChildren = any\n\nconst compatibleCreateElement = (\n  tag: Tag,\n  data: VNodeData,\n  components: RenderChildren\n): any => {\n  /* istanbul ignore else */\n  if (isVue2) {\n    const hInVue2 = h as (\n      tag: Tag,\n      data?: VNodeData,\n      components?: VNodeChildren\n    ) => VNode\n    const scopedSlots = components // 默认全部作为 scopedSlots 处理\n    const children = []\n\n    /**\n     * scopedSlots 不会映射为slots，所以这里手动映射一遍\n     * 主要为了解决 slots.x 问题\n     */\n    Object.keys(components).forEach((key) => {\n      const func = components[key]\n\n      // 转换为 slots 传递\n      if (typeof func === 'function' && func.length === 0) {\n        /**\n         * func 参数为0的判断不准确，因为composition-api包了一层，导致全部为0\n         * try catch 解决scoped slots 转换参数异常问题\n         * */\n        try {\n          const child = func()\n          children.push(\n            key === 'default'\n              ? child\n              : hInVue2(FragmentComponent, { slot: key }, [child])\n          )\n        } catch (error) {}\n      }\n    })\n    const newData = Object.assign({}, data)\n    if (Object.keys(scopedSlots).length > 0) {\n      if (!newData.scopedSlots) {\n        newData.scopedSlots = scopedSlots\n      } else {\n        newData.scopedSlots = {\n          ...newData.scopedSlots,\n          ...scopedSlots,\n        }\n      }\n    }\n    if (tag === Fragment) {\n      if (Object.keys(newData).length === 0 && children.length === 1) {\n        if (!Array.isArray(children[0])) {\n          return children[0]\n        } else if (children[0].length === 1) {\n          return children[0][0]\n        }\n      }\n      tag = FragmentComponent\n    }\n    return hInVue2(tag, newData, children)\n  } else {\n    if (tag === Fragment) {\n      tag = FragmentComponent\n    }\n    const hInVue3 = h as (\n      tag: Tag,\n      data?: VNodeData,\n      components?: RenderChildren\n    ) => VNode\n    const newData = {}\n    Object.keys(data).forEach((key) => {\n      if (key === 'on') {\n        if (data[key]) {\n          const events = Object.keys(data[key])\n          events.forEach((event) => {\n            const eventName = `on${event[0].toUpperCase()}${event.slice(1)}`\n            newData[eventName] = data[key][event]\n          })\n        }\n      } else if (typeof data[key] === 'object' && data[key] !== null) {\n        Object.assign(newData, data[key])\n      } else {\n        newData[key] = data[key]\n      }\n    })\n    return hInVue3(tag, newData, components)\n  }\n}\n\nexport default compatibleCreateElement\n\nexport { compatibleCreateElement as h }\n","import { provide, defineComponent, watch } from 'vue-demi'\nimport {\n  FormSymbol,\n  FieldSymbol,\n  SchemaMarkupSymbol,\n  SchemaSymbol,\n  SchemaExpressionScopeSymbol,\n  SchemaOptionsSymbol,\n} from '../shared/context'\nimport { IProviderProps } from '../types'\nimport { useAttach } from '../hooks/useAttach'\nimport { useInjectionCleaner } from '../hooks/useInjectionCleaner'\nimport h from '../shared/h'\nimport { Fragment } from '../shared/fragment'\n\nimport type { DefineComponent } from '../types'\n\nexport default defineComponent<IProviderProps>({\n  name: 'FormProvider',\n  inheritAttrs: false,\n  props: {\n    form: {\n      type: Object,\n      required: true,\n    },\n  },\n  setup(props: IProviderProps, { attrs, slots }) {\n    const getForm = () => props.form\n    const [formRef, checker] = useAttach(getForm())\n    watch(\n      () => props.form,\n      () => (formRef.value = checker(getForm()))\n    )\n\n    provide(FormSymbol, formRef)\n    useInjectionCleaner([\n      FieldSymbol,\n      SchemaMarkupSymbol,\n      SchemaSymbol,\n      SchemaExpressionScopeSymbol,\n      SchemaOptionsSymbol,\n    ])\n\n    return () => h(Fragment, { attrs }, slots)\n  },\n}) as unknown as DefineComponent<IProviderProps>\n","import { InjectionKey, provide, Ref, ref } from 'vue-demi'\n\nexport const useInjectionCleaner = (\n  injectionKeys: InjectionKey<Ref<unknown>>[]\n) => {\n  injectionKeys.forEach((key) => provide(key, ref()))\n}\n","import { inject, Ref, ref } from 'vue-demi'\nimport { Form } from '@formily/core'\nimport { FormSymbol } from '../shared/context'\n\nexport const useForm = (): Ref<Form> => {\n  const form = inject(FormSymbol, ref())\n  return form\n}\n","import { inject, Ref, ref } from 'vue-demi'\nimport { GeneralField } from '@formily/core'\nimport { FieldSymbol } from '../shared/context'\n\nexport const useField = <T = GeneralField>(): Ref<T> => {\n  return inject(FieldSymbol, ref()) as any\n}\n","import { defineComponent } from 'vue-demi'\nimport { observer } from '@formily/reactive-vue'\nimport { useForm } from '../hooks'\nimport h from '../shared/h'\nimport { Fragment } from '../shared/fragment'\n\nimport type { DefineComponent } from '../types'\n\nexport default observer(\n  defineComponent({\n    name: 'FormConsumer',\n    inheritAttrs: false,\n    setup(props, { slots }) {\n      const formRef = useForm()\n      return () => {\n        const children = {\n          ...slots,\n        }\n        if (slots.default) {\n          children.default = () =>\n            slots.default({\n              form: formRef.value,\n            })\n        }\n        return h(Fragment, {}, children)\n      }\n    },\n  }) as unknown as DefineComponent\n)\n","import { defineComponent, inject, ref } from 'vue-demi'\nimport { isVoidField } from '@formily/core'\nimport { FormPath } from '@formily/shared'\nimport { observer } from '@formily/reactive-vue'\nimport { toJS } from '@formily/reactive'\nimport { SchemaOptionsSymbol } from '../shared'\nimport h from '../shared/h'\nimport { Fragment } from '../shared/fragment'\n\nimport type {\n  IReactiveFieldProps,\n  VueComponent,\n  DefineComponent,\n  VueComponentProps,\n} from '../types'\n\nfunction isVueOptions(options: any) {\n  if (!options) {\n    return false\n  }\n  return (\n    typeof options.template === 'string' ||\n    typeof options.render === 'function' ||\n    typeof options.setup === 'function'\n  )\n}\n\nexport default observer(\n  defineComponent<IReactiveFieldProps>({\n    name: 'ReactiveField',\n    props: ['field'],\n    setup(props: IReactiveFieldProps, { slots }) {\n      const optionsRef = inject(SchemaOptionsSymbol, ref(null))\n      const key = Math.floor(Date.now() * Math.random()).toString(16)\n      const mergeChildren = (slots: Record<string, any>, content: any) => {\n        if (!Object.keys(slots).length && !content) return {}\n\n        const defaultSlot = slots?.default\n          ? slots?.default(props.field, props.field.form)\n          : []\n        if (typeof content === 'string') {\n          slots['default'] = () => [...defaultSlot, content]\n        } else if (isVueOptions(content) || typeof content === 'function') {\n          // scoped slot for class component\n          if (isVueOptions(content) && content?.render?.length > 1) {\n            slots['default'] = (scopedProps: VueComponentProps<any>) => [\n              ...defaultSlot,\n              h(content, { props: scopedProps }, {}),\n            ]\n          } else {\n            slots['default'] = () => [...defaultSlot, h(content, {}, {})]\n          }\n        } else if (content && typeof content === 'object') {\n          // for named slots\n          Object.keys(content).forEach((key) => {\n            const child = content[key]\n            const slot = slots?.[key] ? slots?.[key]() : []\n            if (typeof child === 'string') {\n              slots[key] = () => [...slot, child]\n            } else if (isVueOptions(child) || typeof child === 'function') {\n              // scoped slot for class component\n              if (isVueOptions(child) && child?.render?.length > 1) {\n                slots[key] = (scopedProps: VueComponentProps<any>) => [\n                  ...slot,\n                  h(child, { props: scopedProps }, {}),\n                ]\n              } else {\n                slots[key] = () => [...slot, h(child, {}, {})]\n              }\n            }\n          })\n        }\n\n        return slots\n      }\n\n      return () => {\n        const field = props.field\n        let children = {}\n        if (!field) {\n          children = slots\n        } else if (field.display !== 'visible') {\n          children = {\n            ...slots,\n            default: () => [h('template', {}, {})],\n          }\n        } else {\n          const renderDecorator = (childNodes: any[]) => {\n            if (!field?.decorator?.[0]) {\n              return {\n                default: () => childNodes,\n              }\n            } else {\n              const decorator = (FormPath.getIn(\n                optionsRef.value?.components,\n                field.decorator[0]\n              ) ?? field.decorator[0]) as VueComponent\n              const decoratorData = toJS(field.decorator[1]) || {}\n              const style = decoratorData?.style\n              const classes = decoratorData?.class\n              delete decoratorData.style\n              delete decoratorData.class\n              return {\n                default: () =>\n                  h(\n                    decorator,\n                    {\n                      style,\n                      class: classes,\n                      attrs: {\n                        ...decoratorData,\n                      },\n                    },\n                    {\n                      default: () => childNodes,\n                    }\n                  ),\n              }\n            }\n          }\n\n          const renderComponent = () => {\n            if (!field?.component?.[0]) {\n              return h(\n                Fragment,\n                {},\n                {\n                  default: () =>\n                    slots.default?.({\n                      field: props.field,\n                      form: props.field.form,\n                    }),\n                }\n              )\n            }\n\n            const component = (FormPath.getIn(\n              optionsRef.value?.components,\n              field.component[0]\n            ) ?? field.component[0]) as VueComponent\n            const originData = toJS(field.component[1]) || {}\n            const events = {} as Record<string, any>\n            const originChange = originData['@change'] || originData['onChange']\n            const originFocus = originData['@focus'] || originData['onFocus']\n            const originBlur = originData['@blur'] || originData['onBlur']\n\n            // '@xxx' has higher priority\n            Object.keys(originData)\n              .filter((key) => key.startsWith('on'))\n              .forEach((eventKey) => {\n                const eventName = `${eventKey[2].toLowerCase()}${eventKey.slice(\n                  3\n                )}`\n                events[eventName] = originData[eventKey]\n              })\n\n            Object.keys(originData)\n              .filter((key) => key.startsWith('@'))\n              .forEach((eventKey) => {\n                events[eventKey.slice(1)] = originData[eventKey]\n                delete originData[eventKey]\n              })\n\n            events.change = (...args: any[]) => {\n              if (!isVoidField(field)) field.onInput(...args)\n              originChange?.(...args)\n            }\n            events.focus = (...args: any[]) => {\n              if (!isVoidField(field)) field.onFocus(...args)\n              originFocus?.(...args)\n            }\n            events.blur = (...args: any[]) => {\n              if (!isVoidField(field)) field.onBlur(...args)\n              originBlur?.(...args)\n            }\n\n            const style = originData?.style\n            const classes = originData?.class\n            delete originData.style\n            delete originData.class\n            const attrs = {\n              disabled: !isVoidField(field)\n                ? field.pattern === 'disabled' || field.pattern === 'readPretty'\n                : undefined,\n              readOnly: !isVoidField(field)\n                ? field.pattern === 'readOnly'\n                : undefined,\n              ...originData,\n              // toJS is used to avoid some render loop.\n              value: !isVoidField(field) ? toJS(field.value) : undefined,\n            }\n            const componentData = {\n              attrs,\n              style,\n              class: classes,\n              on: events,\n            }\n\n            const componentChildren = mergeChildren(\n              {\n                ...slots,\n              },\n              field.content\n            )\n\n            return h(component, componentData, componentChildren)\n          }\n\n          children = renderDecorator([renderComponent()])\n        }\n\n        return h(Fragment, { key }, children)\n      }\n    },\n  }) as unknown as DefineComponent<IReactiveFieldProps>\n)\n","import { IFieldProps, VueComponent } from '../types'\nimport { toRaw } from 'vue-demi'\n\nexport const getRawComponent = (\n  props: IFieldProps<VueComponent, VueComponent>\n) => {\n  const { component, decorator } = props\n  let newComponent: typeof props.component\n  let newDecorator: typeof props.component\n  if (Array.isArray(component)) {\n    newComponent = [toRaw(component[0]), component[1]]\n  }\n  if (Array.isArray(decorator)) {\n    newDecorator = [toRaw(decorator[0]), decorator[1]]\n  }\n  return { component: newComponent, decorator: newDecorator }\n}\n","import { provide, defineComponent, watch, computed } from 'vue-demi'\nimport { useField, useForm } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport ReactiveField from './ReactiveField'\nimport { FieldSymbol } from '../shared/context'\nimport h from '../shared/h'\nimport { getRawComponent } from '../utils/getRawComponent'\nimport { observer } from '@formily/reactive-vue'\n\nimport type { IArrayFieldProps, DefineComponent } from '../types'\n\nexport default observer(\n  defineComponent<IArrayFieldProps>({\n    name: 'ArrayField',\n    props: {\n      name: {},\n      title: {},\n      description: {},\n      value: {},\n      initialValue: {},\n      basePath: {},\n      decorator: Array,\n      component: Array,\n      display: String,\n      pattern: String,\n      required: {\n        type: Boolean,\n        default: undefined,\n      },\n      validateFirst: {\n        type: Boolean,\n        default: undefined,\n      },\n      hidden: {\n        type: Boolean,\n        default: undefined,\n      },\n      visible: {\n        type: Boolean,\n        default: undefined,\n      },\n      editable: {\n        type: Boolean,\n        default: undefined,\n      },\n      disabled: {\n        type: Boolean,\n        default: undefined,\n      },\n      readOnly: {\n        type: Boolean,\n        default: undefined,\n      },\n      readPretty: {\n        type: Boolean,\n        default: undefined,\n      },\n      dataSource: {},\n      validator: {},\n      reactions: [Array, Function],\n    },\n    setup(props: IArrayFieldProps, { slots }) {\n      const formRef = useForm()\n      const parentRef = useField()\n\n      const basePath = computed(() =>\n        props.basePath !== undefined\n          ? props.basePath\n          : parentRef?.value?.address\n      )\n      const createField = () =>\n        formRef.value.createArrayField({\n          ...props,\n          basePath: basePath.value,\n          ...getRawComponent(props),\n        })\n      const [fieldRef, checker] = useAttach(createField())\n      watch(\n        () => props,\n        () => (fieldRef.value = checker(createField())),\n        { deep: true }\n      )\n      watch(\n        [formRef, parentRef],\n        () => (fieldRef.value = checker(createField()))\n      )\n\n      provide(FieldSymbol, fieldRef)\n\n      return () => {\n        const field = fieldRef.value\n        const componentData = {\n          props: {\n            field,\n          },\n        }\n        const children = {\n          ...slots,\n        }\n        if (slots.default) {\n          children.default = () =>\n            slots.default({\n              field: field,\n              form: field.form,\n            })\n        }\n        return h(ReactiveField, componentData, children)\n      }\n    },\n  }) as unknown as DefineComponent<IArrayFieldProps>\n)\n","import { provide, defineComponent, computed, watch } from 'vue-demi'\nimport { useField, useForm } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport ReactiveField from './ReactiveField'\nimport { observer } from '@formily/reactive-vue'\nimport { FieldSymbol } from '../shared/context'\nimport h from '../shared/h'\nimport { getRawComponent } from '../utils/getRawComponent'\n\nimport type { IObjectFieldProps, DefineComponent } from '../types'\n\nexport default observer(\n  defineComponent<IObjectFieldProps>({\n    name: 'ObjectField',\n    props: {\n      name: {},\n      title: {},\n      description: {},\n      value: {},\n      initialValue: {},\n      basePath: {},\n      decorator: Array,\n      component: Array,\n      display: String,\n      pattern: String,\n      required: {\n        type: Boolean,\n        default: undefined,\n      },\n      validateFirst: {\n        type: Boolean,\n        default: undefined,\n      },\n      hidden: {\n        type: Boolean,\n        default: undefined,\n      },\n      visible: {\n        type: Boolean,\n        default: undefined,\n      },\n      editable: {\n        type: Boolean,\n        default: undefined,\n      },\n      disabled: {\n        type: Boolean,\n        default: undefined,\n      },\n      readOnly: {\n        type: Boolean,\n        default: undefined,\n      },\n      readPretty: {\n        type: Boolean,\n        default: undefined,\n      },\n      dataSource: {},\n      validator: {},\n      reactions: [Array, Function],\n    },\n    setup(props: IObjectFieldProps, { slots }) {\n      const formRef = useForm()\n      const parentRef = useField()\n\n      const basePath = computed(() =>\n        props.basePath !== undefined\n          ? props.basePath\n          : parentRef?.value?.address\n      )\n      const createField = () =>\n        formRef.value.createObjectField({\n          ...props,\n          basePath: basePath.value,\n          ...getRawComponent(props),\n        })\n      const [fieldRef, checker] = useAttach(createField())\n      watch(\n        () => props,\n        () => (fieldRef.value = checker(createField())),\n        { deep: true }\n      )\n      watch(\n        [formRef, parentRef],\n        () => (fieldRef.value = checker(createField()))\n      )\n\n      provide(FieldSymbol, fieldRef)\n\n      return () => {\n        const field = fieldRef.value\n        const componentData = {\n          props: {\n            field,\n          },\n        }\n        const children = {\n          ...slots,\n        }\n        if (slots.default) {\n          children.default = () =>\n            slots.default({\n              field: field,\n              form: field.form,\n            })\n        }\n        return h(ReactiveField, componentData, children)\n      }\n    },\n  }) as unknown as DefineComponent<IObjectFieldProps>\n)\n","import { provide, defineComponent, computed, watch } from 'vue-demi'\nimport { useField, useForm } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport ReactiveField from './ReactiveField'\nimport { FieldSymbol } from '../shared/context'\nimport h from '../shared/h'\nimport { getRawComponent } from '../utils/getRawComponent'\n\nimport type { IVoidFieldProps, DefineComponent } from '../types'\n\nexport default defineComponent<IVoidFieldProps>({\n  name: 'VoidField',\n  props: {\n    name: {},\n    title: {},\n    description: {},\n    basePath: {},\n    decorator: Array,\n    component: Array,\n    display: String,\n    pattern: String,\n    hidden: {\n      type: Boolean,\n      default: undefined,\n    },\n    visible: {\n      type: Boolean,\n      default: undefined,\n    },\n    editable: {\n      type: Boolean,\n      default: undefined,\n    },\n    disabled: {\n      type: Boolean,\n      default: undefined,\n    },\n    readOnly: {\n      type: Boolean,\n      default: undefined,\n    },\n    readPretty: {\n      type: Boolean,\n      default: undefined,\n    },\n    reactions: [Array, Function],\n  },\n  setup(props: IVoidFieldProps, { slots }) {\n    const formRef = useForm()\n    const parentRef = useField()\n\n    const basePath = computed(() =>\n      props.basePath !== undefined ? props.basePath : parentRef?.value?.address\n    )\n    const createField = () =>\n      formRef.value.createVoidField({\n        ...props,\n        basePath: basePath.value,\n        ...getRawComponent(props),\n      })\n    const [fieldRef, checker] = useAttach(createField())\n    watch(\n      () => props,\n      () => (fieldRef.value = checker(createField())),\n      { deep: true }\n    )\n    watch([formRef, parentRef], () => (fieldRef.value = checker(createField())))\n\n    provide(FieldSymbol, fieldRef)\n\n    return () => {\n      const field = fieldRef.value\n      const componentData = {\n        props: {\n          field,\n        },\n      }\n      const children = {\n        ...slots,\n      }\n      if (slots.default) {\n        children.default = () =>\n          slots.default({\n            field: field,\n            form: field.form,\n          })\n      }\n      return h(ReactiveField, componentData, children)\n    }\n  },\n}) as unknown as DefineComponent<IVoidFieldProps>\n","import { provide, defineComponent, watch, computed } from 'vue-demi'\nimport { useField, useForm } from '../hooks'\nimport { useAttach } from '../hooks/useAttach'\nimport { FieldSymbol } from '../shared/context'\nimport ReactiveField from './ReactiveField'\nimport h from '../shared/h'\nimport { getRawComponent } from '../utils/getRawComponent'\n\nimport type { IFieldProps, DefineComponent } from '../types'\n\nexport default defineComponent<IFieldProps>({\n  name: 'Field',\n  props: {\n    name: {},\n    title: {},\n    description: {},\n    value: {},\n    initialValue: {},\n    basePath: {},\n    decorator: Array,\n    component: Array,\n    display: String,\n    pattern: String,\n    required: {\n      type: Boolean,\n      default: undefined,\n    },\n    validateFirst: {\n      type: Boolean,\n      default: undefined,\n    },\n    hidden: {\n      type: Boolean,\n      default: undefined,\n    },\n    visible: {\n      type: Boolean,\n      default: undefined,\n    },\n    editable: {\n      type: Boolean,\n      default: undefined,\n    },\n    disabled: {\n      type: Boolean,\n      default: undefined,\n    },\n    readOnly: {\n      type: Boolean,\n      default: undefined,\n    },\n    readPretty: {\n      type: Boolean,\n      default: undefined,\n    },\n    dataSource: {},\n    validator: {},\n    reactions: [Array, Function],\n  },\n  setup(props: IFieldProps, { slots }) {\n    const formRef = useForm()\n    const parentRef = useField()\n\n    const basePath = computed(() =>\n      props.basePath !== undefined ? props.basePath : parentRef?.value?.address\n    )\n    const createField = () =>\n      formRef.value.createField({\n        ...props,\n        basePath: basePath.value,\n        ...getRawComponent(props),\n      })\n    const [fieldRef, checker] = useAttach(createField())\n    watch(\n      () => props,\n      () => (fieldRef.value = checker(createField())),\n      { deep: true }\n    )\n    watch([formRef, parentRef], () => (fieldRef.value = checker(createField())))\n\n    provide(FieldSymbol, fieldRef)\n\n    return () => {\n      const field = fieldRef.value\n      const componentData = {\n        props: {\n          field,\n        },\n      }\n      const children = {\n        ...slots,\n      }\n      if (slots.default) {\n        children.default = () =>\n          slots.default({\n            field,\n            form: field.form,\n          })\n      }\n      return h(ReactiveField, componentData, children)\n    }\n  },\n}) as unknown as DefineComponent<IFieldProps>\n","import { inject, provide, watch, defineComponent, shallowRef } from 'vue-demi'\nimport { GeneralField } from '@formily/core'\nimport { isFn, isValid } from '@formily/shared'\nimport { Schema } from '@formily/json-schema'\nimport { observer } from '@formily/reactive-vue'\nimport {\n  SchemaSymbol,\n  SchemaOptionsSymbol,\n  SchemaExpressionScopeSymbol,\n} from '../shared'\nimport { useField } from '../hooks'\nimport ObjectField from './ObjectField'\nimport ArrayField from './ArrayField'\nimport Field from './Field'\nimport VoidField from './VoidField'\nimport { h } from '../shared/h'\nimport { Fragment } from '../shared/fragment'\n\nimport type { IRecursionFieldProps, DefineComponent } from '../types'\n\nconst RecursionField = observer(\n  defineComponent<IRecursionFieldProps>({\n    name: 'RecursionField',\n    inheritAttrs: false,\n    props: {\n      schema: {\n        required: true,\n      },\n      name: [String, Number],\n      basePath: {},\n      onlyRenderProperties: {\n        type: Boolean,\n        default: undefined,\n      },\n      onlyRenderSelf: {\n        type: Boolean,\n        default: undefined,\n      },\n      mapProperties: {},\n      filterProperties: {},\n    },\n    setup(props: IRecursionFieldProps) {\n      const parentRef = useField()\n      const optionsRef = inject(SchemaOptionsSymbol)\n      const scopeRef = inject(SchemaExpressionScopeSymbol)\n      const createSchema = (schemaProp: IRecursionFieldProps['schema']) =>\n        new Schema(schemaProp)\n      const fieldSchemaRef = shallowRef(createSchema(props.schema))\n\n      watch([() => props.schema], () => {\n        fieldSchemaRef.value = createSchema(props.schema)\n      })\n\n      const getPropsFromSchema = (schema: Schema) =>\n        schema?.toFieldProps?.({\n          ...optionsRef.value,\n          get scope() {\n            return {\n              ...optionsRef.value.scope,\n              ...scopeRef.value,\n            }\n          },\n        })\n      const fieldPropsRef = shallowRef(getPropsFromSchema(fieldSchemaRef.value))\n\n      watch([fieldSchemaRef, optionsRef], () => {\n        fieldPropsRef.value = getPropsFromSchema(fieldSchemaRef.value)\n      })\n\n      const getBasePath = () => {\n        if (props.onlyRenderProperties) {\n          return props.basePath || parentRef?.value?.address.concat(props.name)\n        }\n        return props.basePath || parentRef?.value?.address\n      }\n\n      provide(SchemaSymbol, fieldSchemaRef)\n\n      return () => {\n        const basePath = getBasePath()\n        const fieldProps = fieldPropsRef.value\n\n        const renderProperties = (field?: GeneralField) => {\n          if (props.onlyRenderSelf) return\n          const properties = Schema.getOrderProperties(fieldSchemaRef.value)\n          if (!properties.length) return\n          const children = properties.map(({ schema: item, key: name }) => {\n            const base = field?.address || basePath\n            let schema: Schema = item\n            if (isFn(props.mapProperties)) {\n              const mapped = props.mapProperties(item, name)\n              if (mapped) {\n                schema = mapped\n              }\n            }\n            if (isFn(props.filterProperties)) {\n              if (props.filterProperties(schema, name) === false) {\n                return null\n              }\n            }\n            return h(\n              RecursionField,\n              {\n                key: name,\n                attrs: {\n                  schema,\n                  name,\n                  basePath: base,\n                },\n              },\n              {}\n            )\n          })\n\n          const slots: Record<string, () => any> = {}\n          if (children.length > 0) {\n            slots.default = () => [...children]\n          }\n\n          return h(Fragment, {}, slots)\n        }\n\n        const render = () => {\n          if (!isValid(props.name)) return renderProperties()\n          if (fieldSchemaRef.value.type === 'object') {\n            if (props.onlyRenderProperties) return renderProperties()\n            return h(\n              ObjectField,\n              {\n                attrs: {\n                  ...fieldProps,\n                  name: props.name,\n                  basePath: basePath,\n                },\n              },\n              {\n                default: ({ field }) => [renderProperties(field)],\n              }\n            )\n          } else if (fieldSchemaRef.value.type === 'array') {\n            return h(\n              ArrayField,\n              {\n                attrs: {\n                  ...fieldProps,\n                  name: props.name,\n                  basePath: basePath,\n                },\n              },\n              {}\n            )\n          } else if (fieldSchemaRef.value.type === 'void') {\n            if (props.onlyRenderProperties) return renderProperties()\n            return h(\n              VoidField,\n              {\n                attrs: {\n                  ...fieldProps,\n                  name: props.name,\n                  basePath: basePath,\n                },\n              },\n              {\n                default: ({ field }) => [renderProperties(field)],\n              }\n            )\n          }\n\n          return h(\n            Field,\n            {\n              attrs: {\n                ...fieldProps,\n                name: props.name,\n                basePath: basePath,\n              },\n            },\n            {}\n          )\n        }\n\n        if (!fieldSchemaRef.value) return\n\n        return render()\n      }\n    },\n  }) as unknown as DefineComponent<IRecursionFieldProps>\n)\n\nexport default RecursionField\n","import {\n  inject,\n  provide,\n  defineComponent,\n  computed,\n  shallowRef,\n  watch,\n} from 'vue-demi'\nimport { ISchema, Schema, SchemaTypes } from '@formily/json-schema'\nimport { RecursionField } from '../components'\nimport {\n  SchemaMarkupSymbol,\n  SchemaExpressionScopeSymbol,\n  SchemaOptionsSymbol,\n} from '../shared'\nimport {\n  ComponentPath,\n  VueComponent,\n  ISchemaFieldVueFactoryOptions,\n  SchemaVueComponents,\n  ISchemaFieldProps,\n  ISchemaMarkupFieldProps,\n  ISchemaTypeFieldProps,\n} from '../types'\nimport { resolveSchemaProps } from '../utils/resolveSchemaProps'\nimport { h } from '../shared/h'\nimport { Fragment } from '../shared/fragment'\n\nimport type { DefineComponent } from '../types'\n\nconst env = {\n  nonameId: 0,\n}\n\nconst getRandomName = () => {\n  return `NO_NAME_FIELD_$${env.nonameId++}`\n}\n\nconst markupProps = {\n  version: String,\n  name: [String, Number],\n  title: {},\n  description: {},\n  default: {},\n  readOnly: {\n    type: Boolean,\n    default: undefined,\n  },\n  writeOnly: {\n    type: Boolean,\n    default: undefined,\n  },\n  enum: {},\n  const: {},\n  multipleOf: Number,\n  maximum: Number,\n  exclusiveMaximum: Number,\n  minimum: Number,\n  exclusiveMinimum: Number,\n  maxLength: Number,\n  minLength: Number,\n  pattern: {},\n  maxItems: Number,\n  minItems: Number,\n  uniqueItems: {\n    type: Boolean,\n    default: undefined,\n  },\n  maxProperties: Number,\n  minProperties: Number,\n  required: {\n    type: [Boolean, Array, String],\n    default: undefined,\n  },\n  format: String,\n  properties: {},\n  items: {},\n  additionalItems: {},\n  patternProperties: {},\n  additionalProperties: {},\n  xIndex: Number,\n  xPattern: {},\n  xDisplay: {},\n  xValidator: {},\n  xDecorator: {},\n  xDecoratorProps: {},\n  xComponent: {},\n  xComponentProps: {},\n  xReactions: {},\n  xContent: {},\n  xVisible: {\n    type: Boolean,\n    default: undefined,\n  },\n  xHidden: {\n    type: Boolean,\n    default: undefined,\n  },\n  xDisabled: {\n    type: Boolean,\n    default: undefined,\n  },\n  xEditable: {\n    type: Boolean,\n    default: undefined,\n  },\n  xReadOnly: {\n    type: Boolean,\n    default: undefined,\n  },\n  xReadPretty: {\n    type: Boolean,\n    default: undefined,\n  },\n}\n\ntype SchemaFieldComponents = {\n  SchemaField: DefineComponent<ISchemaFieldProps>\n  SchemaMarkupField: DefineComponent<ISchemaMarkupFieldProps>\n  SchemaStringField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaObjectField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaArrayField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaBooleanField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateTimeField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaVoidField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaNumberField: DefineComponent<ISchemaTypeFieldProps>\n}\n\nexport function createSchemaField<\n  Components extends SchemaVueComponents = SchemaVueComponents\n>(options: ISchemaFieldVueFactoryOptions<Components>): SchemaFieldComponents {\n  const SchemaField = defineComponent<\n    ISchemaFieldProps<VueComponent, VueComponent>\n  >({\n    name: 'SchemaField',\n    inheritAttrs: false,\n    props: {\n      schema: {},\n      scope: {},\n      components: {},\n      basePath: {},\n      title: {},\n      description: {},\n      value: {},\n      initialValue: {},\n      validator: {},\n      dataSource: {},\n      name: [String, Number],\n      decorator: Array,\n      component: Array,\n      reactions: Array,\n      display: String,\n      pattern: String,\n      required: {\n        type: Boolean,\n        default: undefined,\n      },\n      validateFirst: {\n        type: Boolean,\n        default: undefined,\n      },\n      hidden: {\n        type: Boolean,\n        default: undefined,\n      },\n      visible: {\n        type: Boolean,\n        default: undefined,\n      },\n      editable: {\n        type: Boolean,\n        default: undefined,\n      },\n      disabled: {\n        type: Boolean,\n        default: undefined,\n      },\n      readOnly: {\n        type: Boolean,\n        default: undefined,\n      },\n      readPretty: {\n        type: Boolean,\n        default: undefined,\n      },\n    },\n    setup(props: ISchemaFieldProps<VueComponent, VueComponent>, { slots }) {\n      const schemaRef = computed(() =>\n        Schema.isSchemaInstance(props.schema)\n          ? props.schema\n          : new Schema({\n              type: 'object',\n              ...props.schema,\n            })\n      )\n\n      const scopeRef = computed(() => ({\n        ...options.scope,\n        ...props.scope,\n      }))\n\n      const optionsRef = computed(() => ({\n        ...options,\n        components: {\n          ...options.components,\n          ...props.components,\n        },\n      }))\n\n      provide(SchemaMarkupSymbol, schemaRef)\n      provide(SchemaOptionsSymbol, optionsRef)\n      provide(SchemaExpressionScopeSymbol, scopeRef)\n\n      return () => {\n        env.nonameId = 0\n\n        return h(\n          Fragment,\n          {},\n          {\n            default: () => {\n              const children = []\n              if (slots.default) {\n                children.push(\n                  h(\n                    'template',\n                    {},\n                    {\n                      default: () => slots.default(),\n                    }\n                  )\n                )\n              }\n              children.push(\n                h(\n                  RecursionField,\n                  {\n                    attrs: {\n                      ...props,\n                      schema: schemaRef.value,\n                    },\n                  },\n                  {}\n                )\n              )\n              return children\n            },\n          }\n        )\n      }\n    },\n  })\n\n  const MarkupField = defineComponent<\n    ISchemaMarkupFieldProps<\n      Components,\n      ComponentPath<Components>,\n      ComponentPath<Components>\n    >\n  >({\n    name: 'MarkupField',\n    props: Object.assign({}, markupProps, { type: String }),\n    setup(props, { slots }) {\n      const parentRef = inject(SchemaMarkupSymbol, null)\n      if (!parentRef || !parentRef.value) return () => h(Fragment, {}, {})\n      const resolvedProps = resolveSchemaProps(props)\n\n      const name = props.name || getRandomName()\n      const appendArraySchema = (schema: ISchema) => {\n        if (parentRef.value.items) {\n          return parentRef.value.addProperty(name, schema)\n        } else {\n          return parentRef.value.setItems(resolvedProps)\n        }\n      }\n\n      const schemaRef = shallowRef(null)\n\n      watch(\n        parentRef,\n        () => {\n          if (\n            parentRef.value.type === 'object' ||\n            parentRef.value.type === 'void'\n          ) {\n            schemaRef.value = parentRef.value.addProperty(name, resolvedProps)\n          } else if (parentRef.value.type === 'array') {\n            const schema = appendArraySchema(resolvedProps)\n            schemaRef.value = Array.isArray(schema) ? schema[0] : schema\n          }\n        },\n        { immediate: true }\n      )\n      provide(SchemaMarkupSymbol, schemaRef)\n\n      return () => {\n        const children: Record<string, () => any> = {}\n        if (slots.default) {\n          children.default = () => slots.default()\n        }\n        return h(Fragment, {}, children)\n      }\n    },\n  })\n\n  const SchemaFieldFactory = (type: SchemaTypes, name: string) => {\n    return defineComponent<\n      ISchemaMarkupFieldProps<\n        Components,\n        ComponentPath<Components>,\n        ComponentPath<Components>\n      >\n    >({\n      name: name,\n      props: Object.assign({}, markupProps),\n      setup(\n        props: ISchemaMarkupFieldProps<\n          Components,\n          ComponentPath<Components>,\n          ComponentPath<Components>\n        >,\n        { slots }\n      ) {\n        return () =>\n          h(\n            MarkupField,\n            {\n              attrs: {\n                ...props,\n                type: type,\n              },\n            },\n            slots\n          )\n      },\n    })\n  }\n\n  return {\n    SchemaField,\n    SchemaMarkupField: MarkupField,\n    SchemaStringField: SchemaFieldFactory('string', 'SchemaStringField'),\n    SchemaObjectField: SchemaFieldFactory('object', 'SchemaObjectField'),\n    SchemaArrayField: SchemaFieldFactory('array', 'SchemaArrayField'),\n    SchemaBooleanField: SchemaFieldFactory('boolean', 'SchemaBooleanField'),\n    SchemaDateField: SchemaFieldFactory('date', 'SchemaDateField'),\n    SchemaDateTimeField: SchemaFieldFactory('datetime', 'SchemaDatetimeField'),\n    SchemaVoidField: SchemaFieldFactory('void', 'SchemaVoidField'),\n    SchemaNumberField: SchemaFieldFactory('number', 'SchemaNumberField'),\n  } as any\n}\n","import { paramCase } from '@formily/shared'\n\nexport const resolveSchemaProps = (props: Record<string, any>) => {\n  const newProps = {}\n  Object.keys(props).forEach((key) => {\n    if (key.indexOf('x') === 0 && key.indexOf('x-') === -1) {\n      newProps[paramCase(key)] = props[key]\n    } else {\n      newProps[key] = props[key]\n    }\n  })\n  return newProps\n}\n","import * as components from './components'\n\nimport type Vue from 'vue'\nimport type { VueConstructor } from 'vue'\nimport type {\n  IVoidFieldProps,\n  IArrayFieldProps,\n  IObjectFieldProps,\n  IFieldProps,\n  IRecursionFieldProps,\n  IProviderProps,\n  ISchemaMarkupFieldProps,\n  ISchemaFieldProps,\n  ISchemaFieldVueFactoryOptions,\n  ISchemaTypeFieldProps,\n  SchemaVueComponents,\n} from './types'\n\nconst {\n  Field: _Field,\n  ArrayField: _ArrayField,\n  FormConsumer: _FormConsumer,\n  FormProvider: _FormProvider,\n  ObjectField: _ObjectField,\n  RecursionField: _RecursionField,\n  VoidField: _VoidField,\n  createSchemaField: _createSchemaField,\n} = components\n\ntype DefineComponent<Props> = Vue & VueConstructor & Props\n\ntype SchemaFieldComponents = {\n  SchemaField: DefineComponent<Omit<ISchemaFieldProps, 'name' | 'components'>>\n  SchemaMarkupField: DefineComponent<ISchemaMarkupFieldProps>\n  SchemaStringField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaObjectField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaArrayField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaBooleanField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateTimeField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaVoidField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaNumberField: DefineComponent<ISchemaTypeFieldProps>\n}\n\ntype CreateSchemaField<\n  Components extends SchemaVueComponents = SchemaVueComponents\n> = (\n  options: ISchemaFieldVueFactoryOptions<Components>\n) => SchemaFieldComponents\n\nconst Field = _Field as unknown as DefineComponent<Omit<IFieldProps, 'name'>>\nconst ArrayField = _ArrayField as unknown as DefineComponent<\n  Omit<IArrayFieldProps, 'name'>\n>\nconst ObjectField = _ObjectField as unknown as DefineComponent<\n  Omit<IObjectFieldProps, 'name'>\n>\nconst VoidField = _VoidField as unknown as DefineComponent<\n  Omit<IVoidFieldProps, 'name'>\n>\nconst RecursionField = _RecursionField as unknown as DefineComponent<\n  Omit<IRecursionFieldProps, 'name'>\n>\nconst FormConsumer = _FormConsumer as unknown as Vue\nconst FormProvider = _FormProvider as unknown as DefineComponent<IProviderProps>\nconst createSchemaField = _createSchemaField as unknown as CreateSchemaField\n\nexport {\n  Field,\n  ArrayField,\n  ObjectField,\n  VoidField,\n  RecursionField,\n  FormConsumer,\n  FormProvider,\n  createSchemaField,\n}\n","import { createForm } from '@formily/core'\nimport { markRaw } from 'vue-demi'\n\nconst createRawForm = (...args: Parameters<typeof createForm>) => {\n  const form = createForm(...args)\n  return markRaw(form)\n}\n\nexport { createRawForm as createForm }\n","import { Vue2Component } from '../types/vue2'\nimport { isVue2, markRaw, defineComponent } from 'vue-demi'\nimport { isFn, isStr, FormPath, each } from '@formily/shared'\nimport { isVoidField, GeneralField } from '@formily/core'\nimport { observer } from '@formily/reactive-vue'\n\nimport { useField } from '../hooks/useField'\nimport h from './h'\n\nimport type {\n  VueComponent,\n  IComponentMapper,\n  IStateMapper,\n  VueComponentProps,\n  DefineComponent,\n} from '../types'\n\nexport function mapProps<T extends VueComponent = VueComponent>(\n  ...args: IStateMapper<VueComponentProps<T>>[]\n) {\n  return (target: T) => {\n    return observer(\n      defineComponent<VueComponentProps<T>>({\n        // listeners is needed for vue2\n        setup(props, { attrs, slots, listeners }: Record<string, any>) {\n          const fieldRef = useField()\n\n          const transform = (\n            input: VueComponentProps<T>,\n            field: GeneralField\n          ) =>\n            args.reduce((props, mapper) => {\n              if (isFn(mapper)) {\n                props = Object.assign(props, mapper(props, field))\n              } else {\n                each(mapper, (to, extract) => {\n                  const extractValue = FormPath.getIn(field, extract)\n                  const targetValue = isStr(to) ? to : extract\n                  if (extract === 'value') {\n                    if (to !== extract) {\n                      delete props['value']\n                    }\n                  }\n                  FormPath.setIn(props, targetValue, extractValue)\n                })\n              }\n              return props\n            }, input)\n\n          return () => {\n            const newAttrs = fieldRef.value\n              ? transform({ ...attrs } as VueComponentProps<T>, fieldRef.value)\n              : { ...attrs }\n            return h(\n              target,\n              {\n                attrs: {\n                  ...newAttrs,\n                },\n                on: listeners,\n              },\n              slots\n            )\n          }\n        },\n      }) as unknown as DefineComponent<VueComponentProps<T>>\n    )\n  }\n}\n\nexport function mapReadPretty<T extends VueComponent, C extends VueComponent>(\n  component: C,\n  readPrettyProps?: Record<string, any>\n) {\n  return (target: T) => {\n    return observer(\n      defineComponent({\n        setup(props, { attrs, slots, listeners }: Record<string, any>) {\n          const fieldRef = useField()\n          return () => {\n            const field = fieldRef.value\n            return h(\n              field && !isVoidField(field) && field.pattern === 'readPretty'\n                ? component\n                : target,\n              {\n                attrs: {\n                  ...readPrettyProps,\n                  ...attrs,\n                },\n                on: listeners,\n              },\n              slots\n            )\n          }\n        },\n      }) as unknown as DefineComponent<VueComponentProps<T>>\n    )\n  }\n}\n\nexport function connect<T extends VueComponent>(\n  target: T,\n  ...args: IComponentMapper[]\n) {\n  const Component = args.reduce((target: VueComponent, mapper) => {\n    return mapper(target)\n  }, target)\n  /* istanbul ignore else */\n  if (isVue2) {\n    const functionalComponent = {\n      functional: true,\n      render(h, context) {\n        return h(Component as Vue2Component, context.data, context.children)\n      },\n    }\n    return markRaw(functionalComponent)\n  } else {\n    const functionalComponent = defineComponent({\n      setup(props: VueComponentProps<T>, { attrs, slots }) {\n        return () => {\n          return h(Component, { props, attrs }, slots)\n        }\n      },\n    })\n    return markRaw(functionalComponent)\n  }\n}\n","import { inject, ref } from 'vue-demi'\nimport { SchemaSymbol } from '../shared/context'\n\nexport const useFieldSchema = () => {\n  return inject(SchemaSymbol, ref())\n}\n","import { onBeforeUnmount } from 'vue-demi'\nimport { Form } from '@formily/core'\nimport { uid } from '@formily/shared'\nimport { useForm } from './useForm'\n\nexport const useFormEffects = (effects?: (form: Form) => void): void => {\n  const formRef = useForm()\n\n  const id = uid()\n  formRef.value.addEffects(id, effects)\n\n  onBeforeUnmount(() => {\n    formRef.value.removeEffects(id)\n  })\n}\n","import { isObjectField, GeneralField, Form, ObjectField } from '@formily/core'\nimport { computed, Ref } from 'vue-demi'\nimport { useField } from './useField'\nimport { useForm } from './useForm'\n\nexport const useParentForm = (): Ref<Form | ObjectField> => {\n  const field = useField()\n  const form = useForm()\n  const findObjectParent = (field: GeneralField) => {\n    if (!field) return form.value\n    if (isObjectField(field)) return field\n    return findObjectParent(field?.parent)\n  }\n  return computed(() => findObjectParent(field.value))\n}\n"],"names":["Formily","registerPolyfills","getChildNodes","FormSymbol","Symbol","FieldSymbol","SchemaMarkupSymbol","SchemaSymbol","SchemaExpressionScopeSymbol","SchemaOptionsSymbol","useAttach","target","oldTargetRef","shallowRef","value","onMounted","onMount","onBeforeUnmount","onUnmount","$placeholder","$fakeParent","nextSiblingPatched","childNodesPatched","isFrag","node","patchParentNode","fakeParent","Object","defineProperty","get","this","parentElement","patchNextSibling","childNodes","parentNode","index","indexOf","getChildNodesWithFragments","childNodesDescriptor","getOwnPropertyDescriptor","Node","prototype","realChildNodes","apply","Array","from","map","childNode","fromParent","getTopFragment","filter","patchChildNodes","defineProperties","frag","firstChild","hasChildNodes","length","before","_this$frag$","arguments","remove","splice","forEach","getFragmentLeafNodes","children","_Array$prototype","concat","removeChild","hasChildInFragment","removedNode","insertBeforeNode","placeholder","unshift","addPlaceholder","insertBefore","insertNode","_this","insertNodes","_frag","_lastNode","push","after","removePlaceholder","includes","append","appendChild","shift","inserted","element","nextSibling","previousSibling","document","createComment","fragment","createDocumentFragment","replaceWith","assign","set","htmlString","_this2","domify","createElement","innerHTML","oldNodesIndex","unbind","Fragment","FragmentComponent","name","directives","render","h","vm","$scopedSlots","default","$attrs","compatibleCreateElement","tag","data","components","hInVue2_1","scopedSlots","children_1","keys","key","func","child","slot","error","newData","isArray","defineComponent","inheritAttrs","props","form","type","required","setup","_a","attrs","slots","getForm","_b","__read","formRef","checker","watch","provide","ref","useForm","inject","useField","getRawComponent","newComponent","newDecorator","component","decorator","toRaw","title","description","basePath","display","String","pattern","hidden","Boolean","undefined","visible","editable","disabled","readOnly","readPretty","reactions","Function","parentRef","computed","address","createField","createVoidField","fieldRef","deep","field","componentData","ReactiveField","initialValue","validateFirst","dataSource","validator","Field","components.Field","ArrayField","components.ArrayField","ObjectField","components.ObjectField","VoidField","components.VoidField","RecursionField","components.RecursionField","FormConsumer","components.FormConsumer","FormProvider","components.FormProvider","createSchemaField","components.createSchemaField"],"mappings":"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"}